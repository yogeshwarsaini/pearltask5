{"version":3,"file":"content-type.mjs","sources":["../../../../server/src/controllers/validation/content-type.ts"],"sourcesContent":["/* eslint-disable no-template-curly-in-string */ // yup templates need to be in this format\n\nimport { flatMap, getOr, has, snakeCase } from 'lodash/fp';\nimport { yup, validateYupSchema } from '@strapi/utils';\n\nimport type { Struct, Internal, UID } from '@strapi/types';\n\nimport { getService } from '../../utils';\nimport { modelTypes, DEFAULT_TYPES, typeKinds } from '../../services/constants';\nimport { createSchema } from './model-schema';\nimport { removeEmptyDefaults, removeDeletedUIDTargetFields } from './data-transform';\nimport { nestedComponentSchema } from './component';\n\n// Input flattens some fields of the \"info\" into the root type\nexport type CreateContentTypeInput = {\n  uid?: UID.ContentType;\n  contentType?: Partial<Struct.ContentTypeSchema> & Partial<Struct.ContentTypeSchemaInfo>;\n  components?: Array<\n    Partial<Struct.ComponentSchema> &\n      Partial<Struct.SchemaInfo> & { tmpUID?: Internal.UID.Component }\n  >;\n  singularName: Struct.ContentTypeSchemaInfo['singularName'];\n  attributes: Struct.SchemaAttributes & Record<string, any>;\n  kind: Struct.ContentTypeKind;\n  collectionName?: Struct.CollectionTypeSchema['collectionName'];\n  pluralName: Struct.ContentTypeSchemaInfo['pluralName'];\n  displayName: Struct.ContentTypeSchemaInfo['displayName'];\n  description?: Struct.ContentTypeSchemaInfo['description'];\n  options?: Struct.SchemaOptions;\n  draftAndPublish?: Struct.SchemaOptions['draftAndPublish'];\n  pluginOptions?: Struct.ContentTypeSchema['pluginOptions'];\n  config?: object;\n};\n\n/**\n * Allowed relation per type kind\n */\nconst VALID_RELATIONS = {\n  [typeKinds.SINGLE_TYPE]: [\n    'oneToOne',\n    'oneToMany',\n    'morphOne',\n    'morphMany',\n    'morphToOne',\n    'morphToMany',\n  ],\n  [typeKinds.COLLECTION_TYPE]: [\n    'oneToOne',\n    'oneToMany',\n    'manyToOne',\n    'manyToMany',\n    'morphOne',\n    'morphMany',\n    'morphToOne',\n    'morphToMany',\n  ],\n} as const;\n\n/**\n * Allowed types\n */\nconst VALID_TYPES = [...DEFAULT_TYPES, 'uid', 'component', 'dynamiczone', 'customField'];\n\n/**\n * Returns a yup schema to validate a content type payload\n */\nconst createContentTypeSchema = (data: CreateContentTypeInput, { isEdition = false } = {}) => {\n  const kind: keyof typeof VALID_RELATIONS = getOr(\n    typeKinds.COLLECTION_TYPE,\n    'contentType.kind',\n    data\n  );\n\n  const contentTypeSchema = createSchema(VALID_TYPES, VALID_RELATIONS[kind] || [], {\n    modelType: modelTypes.CONTENT_TYPE,\n  })\n    .shape({\n      displayName: yup.string().min(1).required(),\n      singularName: yup\n        .string()\n        .min(1)\n        .test(nameIsAvailable(isEdition))\n        .test(forbiddenContentTypeNameValidator())\n        .isKebabCase()\n        .required(),\n      pluralName: yup\n        .string()\n        .min(1)\n        .test(nameIsAvailable(isEdition))\n        .test(nameIsNotExistingCollectionName(isEdition)) // TODO: v5: require singularName to not match a collection name\n        .test(forbiddenContentTypeNameValidator())\n        .isKebabCase()\n        .required(),\n    })\n    .test(\n      'singularName-not-equal-pluralName',\n      '${path}: singularName and pluralName should be different',\n      (value) => value.singularName !== value.pluralName\n    );\n\n  return yup\n    .object({\n      // FIXME .noUnknown(false) will strip off the unwanted properties without throwing an error\n      // Why not having .noUnknown() ? Because we want to be able to add options relatable to EE features\n      // without having any reference to them in CE.\n      // Why not handle an \"options\" object in the content-type ? The admin panel needs lots of rework\n      // to be able to send this options object instead of top-level attributes.\n      // @nathan-pichon 20/02/2023\n      contentType: contentTypeSchema.required().noUnknown(false),\n      components: nestedComponentSchema,\n    })\n    .noUnknown();\n};\n\n/**\n * Validator for content type creation\n */\nexport const validateContentTypeInput = (data: CreateContentTypeInput) => {\n  return validateYupSchema(createContentTypeSchema(data))(data);\n};\n\n/**\n * Validator for content type edition\n */\nexport const validateUpdateContentTypeInput = (data: CreateContentTypeInput) => {\n  if (has('contentType', data)) {\n    removeEmptyDefaults(data.contentType);\n    removeDeletedUIDTargetFields(data.contentType as Struct.ContentTypeSchema);\n  }\n\n  if (has('components', data) && Array.isArray(data.components)) {\n    data.components.forEach((comp) => {\n      if (has('uid', comp)) {\n        removeEmptyDefaults(comp as Struct.ComponentSchema);\n      }\n    });\n  }\n\n  return validateYupSchema(createContentTypeSchema(data, { isEdition: true }))(data);\n};\n\nconst forbiddenContentTypeNameValidator = () => {\n  const reservedNames = getService('builder').getReservedNames().models;\n\n  return {\n    name: 'forbiddenContentTypeName',\n    message: `Content Type name cannot be one of ${reservedNames.join(', ')}`,\n    test(value: unknown) {\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      return !getService('builder').isReservedModelName(value);\n    },\n  };\n};\n\nconst nameIsAvailable = (isEdition: boolean) => {\n  // TODO TS: if strapi.contentTypes (ie, ContentTypes) works as an ArrayLike and is used like this, we may want to ensure it is typed so that it can be without using as\n  const usedNames = flatMap((ct: Struct.ContentTypeSchema) => {\n    return [ct.info?.singularName, ct.info?.pluralName];\n  })(strapi.contentTypes as any);\n\n  return {\n    name: 'nameAlreadyUsed',\n    message: 'contentType: name `${value}` is already being used by another content type.',\n    test(value: unknown) {\n      // don't check on edition\n      if (isEdition) return true;\n\n      // ignore if not a string (will be caught in another validator)\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      // compare snake case to check the actual column names that will be used in the database\n      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));\n    },\n  };\n};\n\nconst nameIsNotExistingCollectionName = (isEdition: boolean) => {\n  const usedNames = Object.keys(strapi.contentTypes).map(\n    (key) => strapi.contentTypes[key as Internal.UID.ContentType].collectionName\n  ) as string[];\n\n  return {\n    name: 'nameAlreadyUsed',\n    message: 'contentType: name `${value}` is already being used by another content type.',\n    test(value: unknown) {\n      // don't check on edition\n      if (isEdition) return true;\n\n      // ignore if not a string (will be caught in another validator)\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      // compare snake case to check the actual column names that will be used in the database\n      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));\n    },\n  };\n};\n\n/**\n * Validates type kind\n */\nconst kindSchema = yup.string().oneOf([typeKinds.SINGLE_TYPE, typeKinds.COLLECTION_TYPE]);\n\nexport const validateKind = validateYupSchema(kindSchema);\n"],"names":["VALID_RELATIONS","typeKinds","SINGLE_TYPE","COLLECTION_TYPE","VALID_TYPES","DEFAULT_TYPES","createContentTypeSchema","data","isEdition","kind","getOr","contentTypeSchema","createSchema","modelType","modelTypes","CONTENT_TYPE","shape","displayName","yup","string","min","required","singularName","test","nameIsAvailable","forbiddenContentTypeNameValidator","isKebabCase","pluralName","nameIsNotExistingCollectionName","value","object","contentType","noUnknown","components","nestedComponentSchema","validateContentTypeInput","validateYupSchema","validateUpdateContentTypeInput","has","removeEmptyDefaults","removeDeletedUIDTargetFields","Array","isArray","forEach","comp","reservedNames","getService","getReservedNames","models","name","message","join","isReservedModelName","usedNames","flatMap","ct","info","strapi","contentTypes","every","usedName","snakeCase","Object","keys","map","key","collectionName","kindSchema","oneOf","validateKind"],"mappings":"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"}