{"version":3,"file":"schema.mjs","sources":["../../src/schema/schema.ts"],"sourcesContent":["import * as types from '../utils/types';\nimport { identifiers } from '../utils/identifiers';\nimport type { Metadata, Meta } from '../metadata';\nimport type { Column, Schema, Table } from './types';\nimport type { Attribute } from '../types';\n\n/**\n * TODO: This needs to be refactored to support incoming names such as\n * (column, table, index) that are of the form string | NameToken[] so\n * that pieces can be passed through and shortened here.\n *\n * Currently, we are potentially shortening twice, although in reality\n * that won't happen since the shortened attribute column names will\n * fit here because they are already shortened to the max identifier\n * length\n *\n * That is the reason we use getName() here and not getColumnName();\n * we just want the exact shortened name for the value without doing\n * any other potential manipulation to it\n * */\n\nconst createColumn = (name: string, attribute: Attribute): Column => {\n  const { type, args = [], ...opts } = getColumnType(attribute);\n\n  return {\n    name: identifiers.getName(name),\n    type,\n    args,\n    defaultTo: null,\n    notNullable: false,\n    unsigned: false,\n    ...opts,\n    ...('column' in attribute ? (attribute.column ?? {}) : {}),\n  };\n};\n\nconst createTable = (meta: Meta): Table => {\n  const table: Table = {\n    name: meta.tableName,\n    indexes: meta.indexes || [],\n    foreignKeys: meta.foreignKeys || [],\n    columns: [],\n  };\n\n  for (const key of Object.keys(meta.attributes)) {\n    const attribute = meta.attributes[key];\n\n    // if (types.isRelation(attribute.type)) {\n    if (attribute.type === 'relation') {\n      if ('morphColumn' in attribute && attribute.morphColumn && attribute.owner) {\n        const { idColumn, typeColumn } = attribute.morphColumn;\n\n        const idColumnName = identifiers.getName(idColumn.name);\n        const typeColumnName = identifiers.getName(typeColumn.name);\n\n        table.columns.push(\n          createColumn(idColumnName, {\n            type: 'integer',\n            column: {\n              unsigned: true,\n            },\n          })\n        );\n\n        table.columns.push(createColumn(typeColumnName, { type: 'string' }));\n      } else if (\n        'joinColumn' in attribute &&\n        attribute.joinColumn &&\n        attribute.owner &&\n        attribute.joinColumn.referencedTable\n      ) {\n        // NOTE: we could pass uniquness for oneToOne to avoid creating more than one to one\n\n        const {\n          name: columnNameFull,\n          referencedColumn,\n          referencedTable,\n          columnType = 'integer',\n        } = attribute.joinColumn;\n\n        const columnName = identifiers.getName(columnNameFull);\n\n        const column = createColumn(columnName, {\n          // TODO: find the column type automatically, or allow passing all the column params\n          type: columnType,\n          column: {\n            unsigned: true,\n          },\n        });\n\n        table.columns.push(column);\n\n        const fkName = identifiers.getFkIndexName([table.name, columnName]);\n        table.foreignKeys.push({\n          name: fkName,\n          columns: [column.name],\n          referencedTable,\n          referencedColumns: [referencedColumn],\n          // NOTE: could allow configuration\n          onDelete: 'SET NULL',\n        });\n\n        table.indexes.push({\n          name: fkName,\n          columns: [column.name],\n        });\n      }\n    } else if (types.isScalarAttribute(attribute)) {\n      const columnName = identifiers.getName(attribute.columnName || key);\n\n      const column = createColumn(columnName, attribute);\n\n      if (column.unique) {\n        table.indexes.push({\n          type: 'unique',\n          name: identifiers.getUniqueIndexName([table.name, column.name]),\n          columns: [columnName],\n        });\n      }\n\n      if (column.primary) {\n        table.indexes.push({\n          type: 'primary',\n          name: identifiers.getPrimaryIndexName([table.name, column.name]),\n          columns: [columnName],\n        });\n      }\n\n      table.columns.push(column);\n    }\n  }\n\n  return table;\n};\n\nconst getColumnType = (attribute: Attribute) => {\n  if ('columnType' in attribute && attribute.columnType) {\n    return attribute.columnType;\n  }\n\n  switch (attribute.type) {\n    case 'increments': {\n      return {\n        type: 'increments',\n        args: [{ primary: true, primaryKey: true }],\n        notNullable: true,\n      };\n    }\n\n    // We might want to convert email/password to string types before going into the orm with specific validators & transformers\n    case 'password':\n    case 'email':\n    case 'string':\n    case 'enumeration': {\n      return { type: 'string' };\n    }\n    case 'uid': {\n      return {\n        type: 'string',\n      };\n    }\n    case 'richtext':\n    case 'text': {\n      return {\n        type: 'text',\n        args: ['longtext'],\n      };\n    }\n    case 'blocks':\n    case 'json': {\n      return { type: 'jsonb' };\n    }\n    case 'integer': {\n      return { type: 'integer' };\n    }\n    case 'biginteger': {\n      return { type: 'bigInteger' };\n    }\n    case 'float': {\n      return { type: 'double' };\n    }\n    case 'decimal': {\n      return { type: 'decimal', args: [10, 2] };\n    }\n    case 'date': {\n      return { type: 'date' };\n    }\n    case 'time': {\n      return { type: 'time', args: [{ precision: 3 }] };\n    }\n    case 'datetime': {\n      return {\n        type: 'datetime',\n        args: [\n          {\n            useTz: false,\n            precision: 6,\n          },\n        ],\n      };\n    }\n    case 'timestamp': {\n      return {\n        type: 'timestamp',\n        args: [\n          {\n            useTz: false,\n            precision: 6,\n          },\n        ],\n      };\n    }\n    case 'boolean': {\n      return { type: 'boolean' };\n    }\n    default: {\n      throw new Error(`Unknown type ${attribute.type}`);\n    }\n  }\n};\n\nexport const metadataToSchema = (metadata: Metadata): Schema => {\n  const schema: Schema = {\n    tables: [],\n  };\n\n  metadata.forEach((metadata) => {\n    schema.tables.push(createTable(metadata));\n  });\n\n  return schema;\n};\n"],"names":["createColumn","name","attribute","type","args","opts","getColumnType","identifiers","getName","defaultTo","notNullable","unsigned","column","createTable","meta","table","tableName","indexes","foreignKeys","columns","key","Object","keys","attributes","morphColumn","owner","idColumn","typeColumn","idColumnName","typeColumnName","push","joinColumn","referencedTable","columnNameFull","referencedColumn","columnType","columnName","fkName","getFkIndexName","referencedColumns","onDelete","types","unique","getUniqueIndexName","primary","getPrimaryIndexName","primaryKey","precision","useTz","Error","metadataToSchema","metadata","schema","tables","forEach"],"mappings":";;;AAMA;;;;;;;;;;;;;MAeA,MAAMA,YAAe,GAAA,CAACC,IAAcC,EAAAA,SAAAA,GAAAA;IAClC,MAAM,EAAEC,IAAI,EAAEC,IAAAA,GAAO,EAAE,EAAE,GAAGC,IAAM,EAAA,GAAGC,aAAcJ,CAAAA,SAAAA,CAAAA;IAEnD,OAAO;QACLD,IAAMM,EAAAA,WAAAA,CAAYC,OAAO,CAACP,IAAAA,CAAAA;AAC1BE,QAAAA,IAAAA;AACAC,QAAAA,IAAAA;QACAK,SAAW,EAAA,IAAA;QACXC,WAAa,EAAA,KAAA;QACbC,QAAU,EAAA,KAAA;AACV,QAAA,GAAGN,IAAI;QACP,GAAI,QAAA,IAAYH,YAAaA,SAAUU,CAAAA,MAAM,IAAI,EAAC,GAAK;AACzD,KAAA;AACF,CAAA;AAEA,MAAMC,cAAc,CAACC,IAAAA,GAAAA;AACnB,IAAA,MAAMC,KAAe,GAAA;AACnBd,QAAAA,IAAAA,EAAMa,KAAKE,SAAS;QACpBC,OAASH,EAAAA,IAAAA,CAAKG,OAAO,IAAI,EAAE;QAC3BC,WAAaJ,EAAAA,IAAAA,CAAKI,WAAW,IAAI,EAAE;AACnCC,QAAAA,OAAAA,EAAS;AACX,KAAA;AAEA,IAAA,KAAK,MAAMC,GAAOC,IAAAA,MAAAA,CAAOC,IAAI,CAACR,IAAAA,CAAKS,UAAU,CAAG,CAAA;AAC9C,QAAA,MAAMrB,SAAYY,GAAAA,IAAAA,CAAKS,UAAU,CAACH,GAAI,CAAA;;QAGtC,IAAIlB,SAAAA,CAAUC,IAAI,KAAK,UAAY,EAAA;AACjC,YAAA,IAAI,iBAAiBD,SAAaA,IAAAA,SAAAA,CAAUsB,WAAW,IAAItB,SAAAA,CAAUuB,KAAK,EAAE;AAC1E,gBAAA,MAAM,EAAEC,QAAQ,EAAEC,UAAU,EAAE,GAAGzB,UAAUsB,WAAW;AAEtD,gBAAA,MAAMI,YAAerB,GAAAA,WAAAA,CAAYC,OAAO,CAACkB,SAASzB,IAAI,CAAA;AACtD,gBAAA,MAAM4B,cAAiBtB,GAAAA,WAAAA,CAAYC,OAAO,CAACmB,WAAW1B,IAAI,CAAA;AAE1Dc,gBAAAA,KAAAA,CAAMI,OAAO,CAACW,IAAI,CAChB9B,aAAa4B,YAAc,EAAA;oBACzBzB,IAAM,EAAA,SAAA;oBACNS,MAAQ,EAAA;wBACND,QAAU,EAAA;AACZ;AACF,iBAAA,CAAA,CAAA;AAGFI,gBAAAA,KAAAA,CAAMI,OAAO,CAACW,IAAI,CAAC9B,aAAa6B,cAAgB,EAAA;oBAAE1B,IAAM,EAAA;AAAS,iBAAA,CAAA,CAAA;AACnE,aAAA,MAAO,IACL,YAAA,IAAgBD,SAChBA,IAAAA,SAAAA,CAAU6B,UAAU,IACpB7B,SAAUuB,CAAAA,KAAK,IACfvB,SAAAA,CAAU6B,UAAU,CAACC,eAAe,EACpC;;AAGA,gBAAA,MAAM,EACJ/B,IAAAA,EAAMgC,cAAc,EACpBC,gBAAgB,EAChBF,eAAe,EACfG,UAAa,GAAA,SAAS,EACvB,GAAGjC,UAAU6B,UAAU;gBAExB,MAAMK,UAAAA,GAAa7B,WAAYC,CAAAA,OAAO,CAACyB,cAAAA,CAAAA;gBAEvC,MAAMrB,MAAAA,GAASZ,aAAaoC,UAAY,EAAA;;oBAEtCjC,IAAMgC,EAAAA,UAAAA;oBACNvB,MAAQ,EAAA;wBACND,QAAU,EAAA;AACZ;AACF,iBAAA,CAAA;gBAEAI,KAAMI,CAAAA,OAAO,CAACW,IAAI,CAAClB,MAAAA,CAAAA;gBAEnB,MAAMyB,MAAAA,GAAS9B,WAAY+B,CAAAA,cAAc,CAAC;AAACvB,oBAAAA,KAAAA,CAAMd,IAAI;AAAEmC,oBAAAA;AAAW,iBAAA,CAAA;gBAClErB,KAAMG,CAAAA,WAAW,CAACY,IAAI,CAAC;oBACrB7B,IAAMoC,EAAAA,MAAAA;oBACNlB,OAAS,EAAA;AAACP,wBAAAA,MAAAA,CAAOX;AAAK,qBAAA;AACtB+B,oBAAAA,eAAAA;oBACAO,iBAAmB,EAAA;AAACL,wBAAAA;AAAiB,qBAAA;;oBAErCM,QAAU,EAAA;AACZ,iBAAA,CAAA;gBAEAzB,KAAME,CAAAA,OAAO,CAACa,IAAI,CAAC;oBACjB7B,IAAMoC,EAAAA,MAAAA;oBACNlB,OAAS,EAAA;AAACP,wBAAAA,MAAAA,CAAOX;AAAK;AACxB,iBAAA,CAAA;AACF;AACF,SAAA,MAAO,IAAIwC,iBAAuB,CAACvC,SAAY,CAAA,EAAA;AAC7C,YAAA,MAAMkC,aAAa7B,WAAYC,CAAAA,OAAO,CAACN,SAAAA,CAAUkC,UAAU,IAAIhB,GAAAA,CAAAA;YAE/D,MAAMR,MAAAA,GAASZ,aAAaoC,UAAYlC,EAAAA,SAAAA,CAAAA;YAExC,IAAIU,MAAAA,CAAO8B,MAAM,EAAE;gBACjB3B,KAAME,CAAAA,OAAO,CAACa,IAAI,CAAC;oBACjB3B,IAAM,EAAA,QAAA;oBACNF,IAAMM,EAAAA,WAAAA,CAAYoC,kBAAkB,CAAC;AAAC5B,wBAAAA,KAAAA,CAAMd,IAAI;AAAEW,wBAAAA,MAAAA,CAAOX;AAAK,qBAAA,CAAA;oBAC9DkB,OAAS,EAAA;AAACiB,wBAAAA;AAAW;AACvB,iBAAA,CAAA;AACF;YAEA,IAAIxB,MAAAA,CAAOgC,OAAO,EAAE;gBAClB7B,KAAME,CAAAA,OAAO,CAACa,IAAI,CAAC;oBACjB3B,IAAM,EAAA,SAAA;oBACNF,IAAMM,EAAAA,WAAAA,CAAYsC,mBAAmB,CAAC;AAAC9B,wBAAAA,KAAAA,CAAMd,IAAI;AAAEW,wBAAAA,MAAAA,CAAOX;AAAK,qBAAA,CAAA;oBAC/DkB,OAAS,EAAA;AAACiB,wBAAAA;AAAW;AACvB,iBAAA,CAAA;AACF;YAEArB,KAAMI,CAAAA,OAAO,CAACW,IAAI,CAAClB,MAAAA,CAAAA;AACrB;AACF;IAEA,OAAOG,KAAAA;AACT,CAAA;AAEA,MAAMT,gBAAgB,CAACJ,SAAAA,GAAAA;AACrB,IAAA,IAAI,YAAgBA,IAAAA,SAAAA,IAAaA,SAAUiC,CAAAA,UAAU,EAAE;AACrD,QAAA,OAAOjC,UAAUiC,UAAU;AAC7B;AAEA,IAAA,OAAQjC,UAAUC,IAAI;QACpB,KAAK,YAAA;AAAc,YAAA;gBACjB,OAAO;oBACLA,IAAM,EAAA,YAAA;oBACNC,IAAM,EAAA;AAAC,wBAAA;4BAAEwC,OAAS,EAAA,IAAA;4BAAME,UAAY,EAAA;AAAK;AAAE,qBAAA;oBAC3CpC,WAAa,EAAA;AACf,iBAAA;AACF;;QAGA,KAAK,UAAA;QACL,KAAK,OAAA;QACL,KAAK,QAAA;QACL,KAAK,aAAA;AAAe,YAAA;gBAClB,OAAO;oBAAEP,IAAM,EAAA;AAAS,iBAAA;AAC1B;QACA,KAAK,KAAA;AAAO,YAAA;gBACV,OAAO;oBACLA,IAAM,EAAA;AACR,iBAAA;AACF;QACA,KAAK,UAAA;QACL,KAAK,MAAA;AAAQ,YAAA;gBACX,OAAO;oBACLA,IAAM,EAAA,MAAA;oBACNC,IAAM,EAAA;AAAC,wBAAA;AAAW;AACpB,iBAAA;AACF;QACA,KAAK,QAAA;QACL,KAAK,MAAA;AAAQ,YAAA;gBACX,OAAO;oBAAED,IAAM,EAAA;AAAQ,iBAAA;AACzB;QACA,KAAK,SAAA;AAAW,YAAA;gBACd,OAAO;oBAAEA,IAAM,EAAA;AAAU,iBAAA;AAC3B;QACA,KAAK,YAAA;AAAc,YAAA;gBACjB,OAAO;oBAAEA,IAAM,EAAA;AAAa,iBAAA;AAC9B;QACA,KAAK,OAAA;AAAS,YAAA;gBACZ,OAAO;oBAAEA,IAAM,EAAA;AAAS,iBAAA;AAC1B;QACA,KAAK,SAAA;AAAW,YAAA;gBACd,OAAO;oBAAEA,IAAM,EAAA,SAAA;oBAAWC,IAAM,EAAA;AAAC,wBAAA,EAAA;AAAI,wBAAA;AAAE;AAAC,iBAAA;AAC1C;QACA,KAAK,MAAA;AAAQ,YAAA;gBACX,OAAO;oBAAED,IAAM,EAAA;AAAO,iBAAA;AACxB;QACA,KAAK,MAAA;AAAQ,YAAA;gBACX,OAAO;oBAAEA,IAAM,EAAA,MAAA;oBAAQC,IAAM,EAAA;AAAC,wBAAA;4BAAE2C,SAAW,EAAA;AAAE;AAAE;AAAC,iBAAA;AAClD;QACA,KAAK,UAAA;AAAY,YAAA;gBACf,OAAO;oBACL5C,IAAM,EAAA,UAAA;oBACNC,IAAM,EAAA;AACJ,wBAAA;4BACE4C,KAAO,EAAA,KAAA;4BACPD,SAAW,EAAA;AACb;AACD;AACH,iBAAA;AACF;QACA,KAAK,WAAA;AAAa,YAAA;gBAChB,OAAO;oBACL5C,IAAM,EAAA,WAAA;oBACNC,IAAM,EAAA;AACJ,wBAAA;4BACE4C,KAAO,EAAA,KAAA;4BACPD,SAAW,EAAA;AACb;AACD;AACH,iBAAA;AACF;QACA,KAAK,SAAA;AAAW,YAAA;gBACd,OAAO;oBAAE5C,IAAM,EAAA;AAAU,iBAAA;AAC3B;AACA,QAAA;AAAS,YAAA;gBACP,MAAM,IAAI8C,MAAM,CAAC,aAAa,EAAE/C,SAAUC,CAAAA,IAAI,CAAC,CAAC,CAAA;AAClD;AACF;AACF,CAAA;AAEO,MAAM+C,mBAAmB,CAACC,QAAAA,GAAAA;AAC/B,IAAA,MAAMC,MAAiB,GAAA;AACrBC,QAAAA,MAAAA,EAAQ;AACV,KAAA;IAEAF,QAASG,CAAAA,OAAO,CAAC,CAACH,QAAAA,GAAAA;AAChBC,QAAAA,MAAAA,CAAOC,MAAM,CAACvB,IAAI,CAACjB,WAAYsC,CAAAA,QAAAA,CAAAA,CAAAA;AACjC,KAAA,CAAA;IAEA,OAAOC,MAAAA;AACT;;;;"}