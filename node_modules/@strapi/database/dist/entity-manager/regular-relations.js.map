{"version":3,"file":"regular-relations.js","sources":["../../src/entity-manager/regular-relations.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-namespace */\nimport { map, isEmpty } from 'lodash/fp';\nimport type { Knex } from 'knex';\n\nimport {\n  isBidirectional,\n  isOneToAny,\n  isManyToAny,\n  isAnyToOne,\n  hasOrderColumn,\n  hasInverseOrderColumn,\n} from '../metadata';\nimport { createQueryBuilder } from '../query';\nimport { addSchema } from '../utils/knex';\nimport type { Database } from '..';\nimport type { ID, Relation, Model } from '../types';\n\ndeclare module 'knex' {\n  namespace Knex {\n    interface ChainableInterface {\n      transacting(trx?: Knex.Transaction): this;\n    }\n  }\n}\n\n//  TODO: This is a short term solution, to not steal relations from the same document.\nconst getDocumentSiblingIdsQuery = (tableName: string, id: ID) => {\n  // Find if the model is a content type or something else (e.g. component)\n  // to only get the documentId if it's a content type\n  const models: Model[] = Array.from(strapi.db.metadata.values());\n\n  const isContentType = models.find((model) => {\n    return model.tableName === tableName && model.attributes.documentId;\n  });\n\n  if (!isContentType) {\n    return [id];\n  }\n\n  // NOTE: SubQueries are wrapped in a function to not reuse the same connection,\n  // which causes infinite self references\n  return function (query) {\n    query\n      .select('id')\n      .from(tableName)\n      // Get all child ids of the document id\n      .whereIn('document_id', (documentIDSubQuery) => {\n        documentIDSubQuery\n          .from(tableName)\n          // get document id related to the current id\n          .select('document_id')\n          .where('id', id);\n      });\n  } satisfies Knex.QueryCallback;\n};\n\n/**\n * If some relations currently exist for this oneToX relation, on the one side, this function removes them and update the inverse order if needed.\n */\nconst deletePreviousOneToAnyRelations = async ({\n  id,\n  attribute,\n  relIdsToadd,\n  db,\n  transaction: trx,\n}: {\n  id: ID;\n  attribute: Relation.Bidirectional;\n  relIdsToadd: ID[];\n  db: Database;\n  transaction?: Knex.Transaction;\n}) => {\n  if (!(isBidirectional(attribute) && isOneToAny(attribute))) {\n    throw new Error(\n      'deletePreviousOneToAnyRelations can only be called for bidirectional oneToAny relations'\n    );\n  }\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn } = joinTable;\n\n  const con = db.getConnection();\n\n  await con\n    .delete()\n    .from(joinTable.name)\n    // Exclude the ids of the current document\n    .whereNotIn(joinColumn.name, getDocumentSiblingIdsQuery(joinColumn.referencedTable!, id))\n    // Include all the ids that are being connected\n    .whereIn(inverseJoinColumn.name, relIdsToadd)\n    .where(joinTable.on || {})\n    .transacting(trx);\n\n  await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToadd, transaction: trx });\n};\n\n/**\n * If a relation currently exists for this xToOne relations, this function removes it and update the inverse order if needed.\n */\nconst deletePreviousAnyToOneRelations = async ({\n  id,\n  attribute,\n  relIdToadd,\n  db,\n  transaction: trx,\n}: {\n  id: ID;\n  attribute: Relation.Bidirectional;\n  relIdToadd: ID;\n  db: Database;\n  transaction?: Knex.Transaction;\n}) => {\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn } = joinTable;\n  const con = db.getConnection();\n\n  if (!isAnyToOne(attribute)) {\n    throw new Error('deletePreviousAnyToOneRelations can only be called for anyToOne relations');\n  }\n  // handling manyToOne\n  if (isManyToAny(attribute)) {\n    // if the database integrity was not broken relsToDelete is supposed to be of length 1\n    const relsToDelete = await con\n      .select(inverseJoinColumn.name)\n      .from(joinTable.name)\n      .where(joinColumn.name, id)\n      .whereNotIn(\n        inverseJoinColumn.name,\n        getDocumentSiblingIdsQuery(inverseJoinColumn.referencedTable!, relIdToadd)\n      )\n      .where(joinTable.on || {})\n      .transacting(trx);\n\n    const relIdsToDelete = map(inverseJoinColumn.name, relsToDelete);\n\n    await createQueryBuilder(joinTable.name, db)\n      .delete()\n      .where({\n        [joinColumn.name]: id,\n        [inverseJoinColumn.name]: { $in: relIdsToDelete },\n      })\n      .where(joinTable.on || {})\n      .transacting(trx)\n      .execute();\n\n    await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToDelete, transaction: trx });\n\n    // handling oneToOne\n  } else {\n    await con\n      .delete()\n      .from(joinTable.name)\n      .where(joinColumn.name, id)\n      // Exclude the ids of the current document\n      .whereNotIn(\n        inverseJoinColumn.name,\n        getDocumentSiblingIdsQuery(inverseJoinColumn.referencedTable!, relIdToadd)\n      )\n      .where(joinTable.on || {})\n      .transacting(trx);\n  }\n};\n\n/**\n * Delete all or some relations of entity field\n */\nconst deleteRelations = async ({\n  id,\n  attribute,\n  db,\n  relIdsToNotDelete = [],\n  relIdsToDelete = [],\n  transaction: trx,\n}: {\n  id: ID;\n  attribute: Relation.Bidirectional;\n  db: Database;\n  relIdsToNotDelete?: ID[];\n  relIdsToDelete?: ID[] | 'all';\n  transaction?: Knex.Transaction;\n}) => {\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn } = joinTable;\n  const all = relIdsToDelete === 'all';\n\n  if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {\n    let lastId: ID = 0;\n    let done = false;\n    const batchSize = 100;\n\n    while (!done) {\n      const batchToDelete: { id: ID }[] = await createQueryBuilder(joinTable.name, db)\n        .select(inverseJoinColumn.name)\n        .where({\n          [joinColumn.name]: id,\n          id: { $gt: lastId },\n          [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },\n          ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),\n        })\n        .where(joinTable.on || {})\n        .orderBy('id')\n        .limit(batchSize)\n        .transacting(trx)\n        .execute();\n\n      done = batchToDelete.length < batchSize;\n      lastId = batchToDelete[batchToDelete.length - 1]?.id || 0;\n\n      const batchIds = map(inverseJoinColumn.name, batchToDelete);\n\n      await createQueryBuilder(joinTable.name, db)\n        .delete()\n        .where({\n          [joinColumn.name]: id,\n          [inverseJoinColumn.name]: { $in: batchIds },\n        })\n        .where(joinTable.on || {})\n        .transacting(trx)\n        .execute();\n\n      await cleanOrderColumns({ attribute, db, id, inverseRelIds: batchIds, transaction: trx });\n    }\n  } else {\n    await createQueryBuilder(joinTable.name, db)\n      .delete()\n      .where({\n        [joinColumn.name]: id,\n        [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },\n        ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),\n      })\n      .where(joinTable.on || {})\n      .transacting(trx)\n      .execute();\n  }\n};\n\n/**\n * Clean the order columns by ensuring the order value are continuous (ex: 1, 2, 3 and not 1, 5, 10)\n */\nconst cleanOrderColumns = async ({\n  id,\n  attribute,\n  db,\n  inverseRelIds = [],\n  transaction: trx,\n}: {\n  id?: ID;\n  attribute: Relation.Bidirectional;\n  db: Database;\n  inverseRelIds?: ID[];\n  transaction?: Knex.Transaction;\n}) => {\n  if (\n    !(hasOrderColumn(attribute) && id) &&\n    !(hasInverseOrderColumn(attribute) && !isEmpty(inverseRelIds))\n  ) {\n    return;\n  }\n\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;\n\n  /**\n  UPDATE :joinTable: as a,\n  (\n    SELECT\n      id,\n      ROW_NUMBER() OVER ( PARTITION BY :joinColumn: ORDER BY :orderColumn:) AS src_order,\n    FROM :joinTable:\n    WHERE :joinColumn: = :id\n  ) AS b\n  SET :orderColumn: = b.src_order\n  WHERE b.id = a.id;\n  */\n  const updateOrderColumn = async () => {\n    if (!hasOrderColumn(attribute) || !id) {\n      return;\n    }\n\n    const selectRowsToOrder = (joinTableName: string) =>\n      db\n        .connection(joinTableName)\n        .select('id')\n        .rowNumber('src_order', orderColumnName, joinColumn.name)\n        .where(joinColumn.name, id)\n        .toSQL();\n\n    switch (strapi.db.dialect.client) {\n      case 'mysql': {\n        // Here it's MariaDB and MySQL 8\n        const select = selectRowsToOrder(joinTable.name);\n\n        await db\n          .getConnection()\n          .raw(\n            `UPDATE ?? as a, ( ${select.sql} ) AS b\n            SET ?? = b.src_order\n            WHERE b.id = a.id`,\n            [joinTable.name, ...select.bindings, orderColumnName]\n          )\n          .transacting(trx);\n\n        break;\n      }\n      default: {\n        const joinTableName = addSchema(db, joinTable.name);\n        const select = selectRowsToOrder(joinTableName);\n\n        // raw query as knex doesn't allow updating from a subquery\n        await db.connection\n          .raw(\n            `UPDATE ?? as a\n            SET ?? = b.src_order\n            FROM ( ${select.sql} ) AS b\n            WHERE b.id = a.id`,\n            [joinTableName, orderColumnName, ...select.bindings]\n          )\n          .transacting(trx);\n      }\n    }\n  };\n\n  /**\n  UPDATE :joinTable: as a,\n  (\n    SELECT\n      id,\n      ROW_NUMBER() OVER ( PARTITION BY :inverseJoinColumn: ORDER BY :inverseOrderColumn:) AS inv_order\n    FROM :joinTable:\n    WHERE :inverseJoinColumn: IN (:inverseRelIds)\n  ) AS b\n  SET :inverseOrderColumn: = b.inv_order\n  WHERE b.id = a.id;\n  */\n  const updateInverseOrderColumn = async () => {\n    if (!hasInverseOrderColumn(attribute) || isEmpty(inverseRelIds)) return;\n\n    const selectRowsToOrder = (joinTableName: string) =>\n      db\n        .connection(joinTableName)\n        .select('id')\n        .rowNumber('inv_order', inverseOrderColumnName, inverseJoinColumn.name)\n        .where(inverseJoinColumn.name, 'in', inverseRelIds)\n        .toSQL();\n\n    switch (strapi.db.dialect.client) {\n      case 'mysql': {\n        // Here it's MariaDB and MySQL 8\n        const select = selectRowsToOrder(joinTable.name);\n\n        await db\n          .getConnection()\n          .raw(\n            `UPDATE ?? as a, ( ${select.sql} ) AS b\n            SET ?? = b.inv_order\n            WHERE b.id = a.id`,\n            [joinTable.name, ...select.bindings, inverseOrderColumnName]\n          )\n          .transacting(trx);\n        break;\n      }\n      default: {\n        const joinTableName = addSchema(db, joinTable.name);\n        const select = selectRowsToOrder(joinTableName);\n\n        // raw query as knex doesn't allow updating from a subquery\n        await db.connection\n          .raw(\n            `UPDATE ?? as a\n            SET ?? = b.inv_order\n            FROM ( ${select.sql} ) AS b\n            WHERE b.id = a.id`,\n            [joinTableName, inverseOrderColumnName, ...select.bindings]\n          )\n          .transacting(trx);\n      }\n    }\n  };\n\n  return Promise.all([updateOrderColumn(), updateInverseOrderColumn()]);\n};\n\nexport {\n  deletePreviousOneToAnyRelations,\n  deletePreviousAnyToOneRelations,\n  deleteRelations,\n  cleanOrderColumns,\n};\n"],"names":["getDocumentSiblingIdsQuery","tableName","id","models","Array","from","strapi","db","metadata","values","isContentType","find","model","attributes","documentId","query","select","whereIn","documentIDSubQuery","where","deletePreviousOneToAnyRelations","attribute","relIdsToadd","transaction","trx","isBidirectional","isOneToAny","Error","joinTable","joinColumn","inverseJoinColumn","con","getConnection","delete","name","whereNotIn","referencedTable","on","transacting","cleanOrderColumns","inverseRelIds","deletePreviousAnyToOneRelations","relIdToadd","isAnyToOne","isManyToAny","relsToDelete","relIdsToDelete","map","createQueryBuilder","$in","execute","deleteRelations","relIdsToNotDelete","all","hasOrderColumn","hasInverseOrderColumn","lastId","done","batchSize","batchToDelete","$gt","$notIn","orderBy","limit","length","batchIds","isEmpty","orderColumnName","inverseOrderColumnName","updateOrderColumn","selectRowsToOrder","joinTableName","connection","rowNumber","toSQL","dialect","client","raw","sql","bindings","addSchema","updateInverseOrderColumn","Promise"],"mappings":"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"}