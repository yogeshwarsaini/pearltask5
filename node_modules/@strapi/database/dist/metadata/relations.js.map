{"version":3,"file":"relations.js","sources":["../../src/metadata/relations.ts"],"sourcesContent":["import _, { snakeCase } from 'lodash/fp';\n\nimport { identifiers } from '../utils/identifiers';\nimport type { Meta, Metadata } from './metadata';\nimport type { RelationalAttribute, Relation, MorphJoinTable } from '../types';\n\ninterface JoinColumnOptions {\n  attribute: (Relation.OneToOne | Relation.ManyToOne) & Relation.Owner;\n  attributeName: string;\n  meta: Meta;\n}\n\ninterface JoinTableOptions {\n  attribute: RelationalAttribute & Relation.WithTarget & Relation.Bidirectional;\n  attributeName: string;\n  meta: Meta;\n}\n\nconst ID = identifiers.ID_COLUMN;\nconst ORDER = identifiers.ORDER_COLUMN;\nconst FIELD = identifiers.FIELD_COLUMN;\n\nconst hasInversedBy = (\n  attr: RelationalAttribute\n): attr is RelationalAttribute & { inversedBy: boolean } => 'inversedBy' in attr;\nconst hasMappedBy = (\n  attr: RelationalAttribute\n): attr is RelationalAttribute & { inversedBy: boolean } => 'mappedBy' in attr;\n\n// TODO: use strapi/utils relations for all of these\nexport const isPolymorphic = (attribute: RelationalAttribute): attribute is Relation.Morph =>\n  ['morphOne', 'morphMany', 'morphToOne', 'morphToMany'].includes(attribute.relation);\n\nexport const isOneToAny = (\n  attribute: RelationalAttribute\n): attribute is Relation.OneToOne | Relation.OneToMany =>\n  ['oneToOne', 'oneToMany'].includes(attribute.relation);\n\nexport const isManyToAny = (\n  attribute: RelationalAttribute\n): attribute is Relation.ManyToOne | Relation.ManyToMany =>\n  ['manyToMany', 'manyToOne'].includes(attribute.relation);\n\nexport const isAnyToOne = (\n  attribute: RelationalAttribute\n): attribute is Relation.OneToOne | Relation.ManyToOne =>\n  ['oneToOne', 'manyToOne'].includes(attribute.relation);\n\nexport const isAnyToMany = (\n  attribute: RelationalAttribute\n): attribute is Relation.OneToMany | Relation.ManyToMany =>\n  ['oneToMany', 'manyToMany'].includes(attribute.relation);\n\nexport const isBidirectional = (\n  attribute: RelationalAttribute\n): attribute is Relation.Bidirectional => hasInversedBy(attribute) || hasMappedBy(attribute);\n\nconst isOwner = (\n  attribute: RelationalAttribute\n): attribute is RelationalAttribute & Relation.Owner =>\n  !isBidirectional(attribute) || hasInversedBy(attribute);\n\nconst shouldUseJoinTable = (attribute: RelationalAttribute) =>\n  !('useJoinTable' in attribute) || attribute.useJoinTable !== false;\n\nexport const hasOrderColumn = (attribute: RelationalAttribute) => isAnyToMany(attribute);\nexport const hasInverseOrderColumn = (attribute: RelationalAttribute) =>\n  isBidirectional(attribute) && isManyToAny(attribute);\n\n/**\n * Creates a oneToOne relation metadata\n *\n * if owner then\n *   if with join table then\n *     create join table\n *   else\n *     create joinColumn\n *   if bidirectional then\n *     set inverse attribute joinCol or joinTable info correctly\n * else\n *   this property must be set by the owner side\n *   verify the owner side is valid // should be done before or at the same time ?\n */\nconst createOneToOne = (\n  attributeName: string,\n  attribute: Relation.OneToOne,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (isOwner(attribute)) {\n    if (shouldUseJoinTable(attribute)) {\n      createJoinTable(metadata, {\n        attribute,\n        attributeName,\n        meta,\n      });\n    } else {\n      createJoinColumn(metadata, {\n        attribute,\n        attributeName,\n        meta,\n      });\n    }\n  } else {\n    // TODO: verify other side is valid\n  }\n};\n\n/**\n * Creates a oneToMany relation metadata\n *\n * if unidirectional then\n *   create join table\n * if bidirectional then\n *   cannot be owning side\n *   do nothing\n */\nconst createOneToMany = (\n  attributeName: string,\n  attribute: Relation.OneToMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (shouldUseJoinTable(attribute) && !isBidirectional(attribute)) {\n    createJoinTable(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  } else if (isOwner(attribute)) {\n    throw new Error('one side of a oneToMany cannot be the owner side in a bidirectional relation');\n  }\n};\n\n/**\n * Creates a manyToOne relation metadata\n *\n * if unidirectional then\n *   if with join table then\n *     create join table\n *   else\n *     create join column\n * else\n *   must be the owner side\n *   if with join table then\n *     create join table\n *   else\n *     create join column\n *   set inverse attribute joinCol or joinTable info correctly\n */\nconst createManyToOne = (\n  attributeName: string,\n  attribute: Relation.ManyToOne,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (isBidirectional(attribute) && !isOwner(attribute)) {\n    throw new Error('The many side of a manyToOne must be the owning side');\n  }\n\n  if (shouldUseJoinTable(attribute)) {\n    createJoinTable(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  } else {\n    createJoinColumn(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  }\n};\n\n/**\n * Creates a manyToMany relation metadata\n *\n * if unidirectional\n *   create join table\n * else\n *   if owner then\n *     if with join table then\n *       create join table\n *   else\n *     do nothing\n */\nconst createManyToMany = (\n  attributeName: string,\n  attribute: Relation.ManyToMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (shouldUseJoinTable(attribute) && (!isBidirectional(attribute) || isOwner(attribute))) {\n    createJoinTable(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  }\n};\n\n/**\n * Creates a morphToOne relation metadata\n *\n * if with join table then\n *   create join table\n * else\n *  create join columnsa\n *\n * if bidirectionnal\n *  set info in the traget\n */\nconst createMorphToOne = (attributeName: string, attribute: Relation.MorphToOne) => {\n  const idColumnName = identifiers.getJoinColumnAttributeIdName('target');\n  const typeColumnName = identifiers.getMorphColumnTypeName('target');\n\n  Object.assign(attribute, {\n    owner: true,\n    morphColumn: attribute.morphColumn ?? {\n      typeColumn: {\n        name: typeColumnName,\n      },\n      idColumn: {\n        name: idColumnName,\n        referencedColumn: ID,\n      },\n    },\n  });\n};\n\n/**\n * Creates a morphToMany relation metadata\n */\nconst createMorphToMany = (\n  attributeName: string,\n  attribute: Relation.MorphToMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if ('joinTable' in attribute && attribute.joinTable && !attribute.joinTable.__internal__) {\n    return;\n  }\n\n  const joinTableName = identifiers.getMorphTableName(meta.tableName, attributeName);\n  const joinColumnName = identifiers.getMorphColumnJoinTableIdName(snakeCase(meta.singularName));\n  const idColumnName = identifiers.getMorphColumnAttributeIdName(attributeName);\n  const typeColumnName = identifiers.getMorphColumnTypeName(attributeName);\n\n  const fkIndexName = identifiers.getFkIndexName(joinTableName);\n\n  metadata.add({\n    singularName: joinTableName,\n    uid: joinTableName,\n    tableName: joinTableName,\n    attributes: {\n      [ID]: {\n        type: 'increments',\n      },\n      [joinColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n        // This must be set explicitly so that it is used instead of shortening the attribute name, which is already shortened\n        columnName: joinColumnName,\n      },\n      [idColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [typeColumnName]: {\n        type: 'string',\n      },\n      [FIELD]: {\n        type: 'string',\n      },\n      [ORDER]: {\n        type: 'float',\n        column: {\n          unsigned: true,\n        },\n      },\n    },\n    indexes: [\n      {\n        name: fkIndexName,\n        columns: [joinColumnName],\n      },\n      {\n        name: identifiers.getOrderIndexName(joinTableName),\n        columns: [ORDER],\n      },\n      {\n        name: identifiers.getIdColumnIndexName(joinTableName),\n        columns: [idColumnName],\n      },\n    ],\n    foreignKeys: [\n      {\n        name: fkIndexName,\n        columns: [joinColumnName],\n        referencedColumns: [ID],\n        referencedTable: meta.tableName,\n        onDelete: 'CASCADE',\n      },\n    ],\n    lifecycles: {},\n    columnToAttribute: {},\n  });\n\n  const joinTable: MorphJoinTable = {\n    __internal__: true,\n    name: joinTableName,\n    joinColumn: {\n      name: joinColumnName,\n      referencedColumn: ID,\n    },\n    morphColumn: {\n      typeColumn: {\n        name: typeColumnName,\n      },\n      idColumn: {\n        name: idColumnName,\n        referencedColumn: ID,\n      },\n    },\n    orderBy: {\n      order: 'asc' as const,\n    },\n    pivotColumns: [joinColumnName, typeColumnName, idColumnName],\n  };\n\n  attribute.joinTable = joinTable;\n};\n\n/**\n * Creates a morphOne relation metadata\n */\nconst createMorphOne = (\n  attributeName: string,\n  attribute: Relation.MorphOne,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Morph target not found. Looking for ${attribute.target}`);\n  }\n\n  if (attribute.morphBy && !_.has(attribute.morphBy, targetMeta.attributes)) {\n    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);\n  }\n};\n\n/**\n * Creates a morphMany relation metadata\n */\nconst createMorphMany = (\n  attributeName: string,\n  attribute: Relation.MorphMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Morph target not found. Looking for ${attribute.target}`);\n  }\n\n  if (attribute.morphBy && !_.has(attribute.morphBy, targetMeta.attributes)) {\n    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);\n  }\n};\n\n/**\n * Creates a join column info and add them to the attribute meta\n */\nconst createJoinColumn = (metadata: Metadata, { attribute, attributeName }: JoinColumnOptions) => {\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Unknown target ${attribute.target}`);\n  }\n\n  const joinColumnName = identifiers.getJoinColumnAttributeIdName(snakeCase(attributeName));\n  const joinColumn = {\n    name: joinColumnName,\n    referencedColumn: ID,\n    referencedTable: targetMeta.tableName,\n  };\n\n  if ('joinColumn' in attribute) {\n    Object.assign(joinColumn, attribute.joinColumn);\n  }\n\n  Object.assign(attribute, { owner: true, joinColumn });\n\n  if (isBidirectional(attribute)) {\n    const inverseAttribute = targetMeta.attributes[attribute.inversedBy];\n\n    Object.assign(inverseAttribute, {\n      joinColumn: {\n        name: joinColumn.referencedColumn,\n        referencedColumn: joinColumnName,\n      },\n    });\n  }\n};\n\n/**\n * Creates a join table and add it to the attribute meta\n */\nconst createJoinTable = (\n  metadata: Metadata,\n  { attributeName, attribute, meta }: JoinTableOptions\n) => {\n  if (!shouldUseJoinTable(attribute)) {\n    throw new Error('Attempted to create join table when useJoinTable is false');\n  }\n\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Unknown target ${attribute.target}`);\n  }\n\n  // TODO: implement overwrite logic instead\n  if ('joinTable' in attribute && attribute.joinTable && !attribute.joinTable.__internal__) {\n    return;\n  }\n\n  const joinTableName = identifiers.getJoinTableName(\n    snakeCase(meta.tableName),\n    snakeCase(attributeName)\n  );\n\n  const joinColumnName = identifiers.getJoinColumnAttributeIdName(snakeCase(meta.singularName));\n\n  let inverseJoinColumnName = identifiers.getJoinColumnAttributeIdName(\n    snakeCase(targetMeta.singularName)\n  );\n\n  // if relation is self referencing\n  if (joinColumnName === inverseJoinColumnName) {\n    inverseJoinColumnName = identifiers.getInverseJoinColumnAttributeIdName(\n      snakeCase(targetMeta.singularName)\n    );\n  }\n\n  const orderColumnName = identifiers.getOrderColumnName(snakeCase(targetMeta.singularName));\n  // TODO: should this plus the conditional below be rolled into one method?\n  let inverseOrderColumnName = identifiers.getOrderColumnName(snakeCase(meta.singularName));\n\n  // if relation is self referencing\n  if (attribute.relation === 'manyToMany' && orderColumnName === inverseOrderColumnName) {\n    inverseOrderColumnName = identifiers.getInverseOrderColumnName(snakeCase(meta.singularName));\n  }\n\n  const fkIndexName = identifiers.getFkIndexName(joinTableName);\n  const invFkIndexName = identifiers.getInverseFkIndexName(joinTableName);\n\n  const metadataSchema: Meta = {\n    singularName: joinTableName,\n    uid: joinTableName,\n    tableName: joinTableName,\n    attributes: {\n      [ID]: {\n        type: 'increments',\n      },\n      [joinColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n        // This must be set explicitly so that it is used instead of shortening the attribute name, which is already shortened\n        columnName: joinColumnName,\n      },\n      [inverseJoinColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n        // This must be set explicitly so that it is used instead of shortening the attribute name, which is already shortened\n        columnName: inverseJoinColumnName,\n      },\n      // TODO: add extra pivot attributes -> user should use an intermediate entity\n    },\n    indexes: [\n      {\n        name: fkIndexName,\n        columns: [joinColumnName],\n      },\n      {\n        name: invFkIndexName,\n        columns: [inverseJoinColumnName],\n      },\n      {\n        name: identifiers.getUniqueIndexName(joinTableName),\n        columns: [joinColumnName, inverseJoinColumnName],\n        type: 'unique',\n      },\n    ],\n    foreignKeys: [\n      {\n        name: fkIndexName,\n        columns: [joinColumnName],\n        referencedColumns: [ID],\n        referencedTable: meta.tableName,\n        onDelete: 'CASCADE',\n      },\n      {\n        name: invFkIndexName,\n        columns: [inverseJoinColumnName],\n        referencedColumns: [ID],\n        referencedTable: targetMeta.tableName,\n        onDelete: 'CASCADE',\n      },\n    ],\n    lifecycles: {},\n    columnToAttribute: {},\n  };\n\n  const joinTable = {\n    __internal__: true,\n    name: joinTableName,\n    joinColumn: {\n      name: joinColumnName,\n      referencedColumn: ID,\n      referencedTable: meta.tableName,\n    },\n    inverseJoinColumn: {\n      name: inverseJoinColumnName,\n      referencedColumn: ID,\n      referencedTable: targetMeta.tableName,\n    },\n    pivotColumns: [joinColumnName, inverseJoinColumnName],\n  } as any;\n\n  // order\n  if (isAnyToMany(attribute)) {\n    metadataSchema.attributes[orderColumnName] = {\n      type: 'float',\n      column: {\n        unsigned: true,\n        defaultTo: null,\n      },\n      columnName: orderColumnName,\n    };\n    metadataSchema.indexes.push({\n      name: identifiers.getOrderFkIndexName(joinTableName),\n      columns: [orderColumnName],\n    });\n    joinTable.orderColumnName = orderColumnName;\n    joinTable.orderBy = { [orderColumnName]: 'asc' };\n  }\n\n  // inv order\n  if (isBidirectional(attribute) && isManyToAny(attribute)) {\n    metadataSchema.attributes[inverseOrderColumnName] = {\n      type: 'float',\n      column: {\n        unsigned: true,\n        defaultTo: null,\n      },\n      columnName: inverseOrderColumnName,\n    };\n\n    metadataSchema.indexes.push({\n      name: identifiers.getOrderInverseFkIndexName(joinTableName),\n      columns: [inverseOrderColumnName],\n    });\n\n    joinTable.inverseOrderColumnName = inverseOrderColumnName;\n  }\n\n  metadata.add(metadataSchema);\n\n  attribute.joinTable = joinTable;\n\n  if (isBidirectional(attribute)) {\n    const inverseAttribute = attribute.inversedBy\n      ? (targetMeta.attributes[attribute.inversedBy] as Relation.Bidirectional)\n      : null;\n\n    if (!inverseAttribute) {\n      throw new Error(\n        `inversedBy attribute ${attribute.inversedBy} not found target ${targetMeta.uid}`\n      );\n    }\n\n    if (inverseAttribute.type !== 'relation') {\n      throw new Error(\n        `inversedBy attribute ${attribute.inversedBy} targets non relational attribute in ${targetMeta.uid}`\n      );\n    }\n\n    inverseAttribute.joinTable = {\n      __internal__: true,\n      name: joinTableName,\n      joinColumn: joinTable.inverseJoinColumn,\n      inverseJoinColumn: joinTable.joinColumn,\n      pivotColumns: joinTable.pivotColumns,\n    } as any;\n\n    if (isManyToAny(attribute)) {\n      inverseAttribute.joinTable.orderColumnName = inverseOrderColumnName;\n      inverseAttribute.joinTable.orderBy = { [inverseOrderColumnName]: 'asc' };\n    }\n    if (isAnyToMany(attribute)) {\n      inverseAttribute.joinTable.inverseOrderColumnName = orderColumnName;\n    }\n  }\n};\n\n/**\n * Creates a relation metadata\n */\nexport const createRelation = (\n  attributeName: string,\n  attribute: RelationalAttribute,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  switch (attribute.relation) {\n    case 'oneToOne':\n      return createOneToOne(attributeName, attribute, meta, metadata);\n    case 'oneToMany':\n      return createOneToMany(attributeName, attribute, meta, metadata);\n    case 'manyToOne':\n      return createManyToOne(attributeName, attribute, meta, metadata);\n    case 'manyToMany':\n      return createManyToMany(attributeName, attribute, meta, metadata);\n    case 'morphToOne':\n      return createMorphToOne(attributeName, attribute);\n    case 'morphToMany':\n      return createMorphToMany(attributeName, attribute, meta, metadata);\n    case 'morphOne':\n      return createMorphOne(attributeName, attribute, meta, metadata);\n    case 'morphMany':\n      return createMorphMany(attributeName, attribute, meta, metadata);\n    default: {\n      throw new Error(`Unknown relation`);\n    }\n  }\n};\n"],"names":["ID","identifiers","ID_COLUMN","ORDER","ORDER_COLUMN","FIELD","FIELD_COLUMN","hasInversedBy","attr","hasMappedBy","isOneToAny","attribute","includes","relation","isManyToAny","isAnyToOne","isAnyToMany","isBidirectional","isOwner","shouldUseJoinTable","useJoinTable","hasOrderColumn","hasInverseOrderColumn","createOneToOne","attributeName","meta","metadata","createJoinTable","createJoinColumn","createOneToMany","Error","createManyToOne","createManyToMany","createMorphToOne","idColumnName","getJoinColumnAttributeIdName","typeColumnName","getMorphColumnTypeName","Object","assign","owner","morphColumn","typeColumn","name","idColumn","referencedColumn","createMorphToMany","joinTable","__internal__","joinTableName","getMorphTableName","tableName","joinColumnName","getMorphColumnJoinTableIdName","snakeCase","singularName","getMorphColumnAttributeIdName","fkIndexName","getFkIndexName","add","uid","attributes","type","column","unsigned","columnName","indexes","columns","getOrderIndexName","getIdColumnIndexName","foreignKeys","referencedColumns","referencedTable","onDelete","lifecycles","columnToAttribute","joinColumn","orderBy","order","pivotColumns","createMorphOne","targetMeta","get","target","morphBy","_","has","createMorphMany","inverseAttribute","inversedBy","getJoinTableName","inverseJoinColumnName","getInverseJoinColumnAttributeIdName","orderColumnName","getOrderColumnName","inverseOrderColumnName","getInverseOrderColumnName","invFkIndexName","getInverseFkIndexName","metadataSchema","getUniqueIndexName","inverseJoinColumn","defaultTo","push","getOrderFkIndexName","getOrderInverseFkIndexName","createRelation"],"mappings":";;;;;AAkBA,MAAMA,EAAAA,GAAKC,kBAAYC,SAAS;AAChC,MAAMC,KAAAA,GAAQF,kBAAYG,YAAY;AACtC,MAAMC,KAAAA,GAAQJ,kBAAYK,YAAY;AAEtC,MAAMC,aAAAA,GAAgB,CACpBC,IAAAA,GAC0D,YAAgBA,IAAAA,IAAAA;AAC5E,MAAMC,WAAAA,GAAc,CAClBD,IAAAA,GAC0D,UAAcA,IAAAA,IAAAA;AAMnE,MAAME,UAAa,GAAA,CACxBC,SAEA,GAAA;AAAC,QAAA,UAAA;AAAY,QAAA;AAAY,KAAA,CAACC,QAAQ,CAACD,SAAUE,CAAAA,QAAQ;AAEhD,MAAMC,WAAc,GAAA,CACzBH,SAEA,GAAA;AAAC,QAAA,YAAA;AAAc,QAAA;AAAY,KAAA,CAACC,QAAQ,CAACD,SAAUE,CAAAA,QAAQ;AAElD,MAAME,UAAa,GAAA,CACxBJ,SAEA,GAAA;AAAC,QAAA,UAAA;AAAY,QAAA;AAAY,KAAA,CAACC,QAAQ,CAACD,SAAUE,CAAAA,QAAQ;AAEhD,MAAMG,WAAc,GAAA,CACzBL,SAEA,GAAA;AAAC,QAAA,WAAA;AAAa,QAAA;AAAa,KAAA,CAACC,QAAQ,CAACD,SAAUE,CAAAA,QAAQ;MAE5CI,eAAkB,GAAA,CAC7BN,YACwCJ,aAAcI,CAAAA,SAAAA,CAAAA,IAAcF,YAAYE,SAAW;AAE7F,MAAMO,UAAU,CACdP,SAAAA,GAEA,CAACM,eAAAA,CAAgBN,cAAcJ,aAAcI,CAAAA,SAAAA,CAAAA;AAE/C,MAAMQ,kBAAAA,GAAqB,CAACR,SAAAA,GAC1B,EAAE,kBAAkBA,SAAQ,CAAA,IAAMA,SAAUS,CAAAA,YAAY,KAAK,KAAA;AAElDC,MAAAA,cAAAA,GAAiB,CAACV,SAAAA,GAAmCK,YAAYL,SAAW;MAC5EW,qBAAwB,GAAA,CAACX,YACpCM,eAAgBN,CAAAA,SAAAA,CAAAA,IAAcG,YAAYH,SAAW;AAEvD;;;;;;;;;;;;;AAaC,IACD,MAAMY,cAAAA,GAAiB,CACrBC,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;AAEA,IAAA,IAAIR,QAAQP,SAAY,CAAA,EAAA;AACtB,QAAA,IAAIQ,mBAAmBR,SAAY,CAAA,EAAA;AACjCgB,YAAAA,eAAAA,CAAgBD,QAAU,EAAA;AACxBf,gBAAAA,SAAAA;AACAa,gBAAAA,aAAAA;AACAC,gBAAAA;AACF,aAAA,CAAA;SACK,MAAA;AACLG,YAAAA,gBAAAA,CAAiBF,QAAU,EAAA;AACzBf,gBAAAA,SAAAA;AACAa,gBAAAA,aAAAA;AACAC,gBAAAA;AACF,aAAA,CAAA;AACF;;AAIJ,CAAA;AAEA;;;;;;;;AAQC,IACD,MAAMI,eAAAA,GAAkB,CACtBL,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;AAEA,IAAA,IAAIP,kBAAmBR,CAAAA,SAAAA,CAAAA,IAAc,CAACM,eAAAA,CAAgBN,SAAY,CAAA,EAAA;AAChEgB,QAAAA,eAAAA,CAAgBD,QAAU,EAAA;AACxBf,YAAAA,SAAAA;AACAa,YAAAA,aAAAA;AACAC,YAAAA;AACF,SAAA,CAAA;KACK,MAAA,IAAIP,QAAQP,SAAY,CAAA,EAAA;AAC7B,QAAA,MAAM,IAAImB,KAAM,CAAA,8EAAA,CAAA;AAClB;AACF,CAAA;AAEA;;;;;;;;;;;;;;;AAeC,IACD,MAAMC,eAAAA,GAAkB,CACtBP,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;AAEA,IAAA,IAAIT,eAAgBN,CAAAA,SAAAA,CAAAA,IAAc,CAACO,OAAAA,CAAQP,SAAY,CAAA,EAAA;AACrD,QAAA,MAAM,IAAImB,KAAM,CAAA,sDAAA,CAAA;AAClB;AAEA,IAAA,IAAIX,mBAAmBR,SAAY,CAAA,EAAA;AACjCgB,QAAAA,eAAAA,CAAgBD,QAAU,EAAA;AACxBf,YAAAA,SAAAA;AACAa,YAAAA,aAAAA;AACAC,YAAAA;AACF,SAAA,CAAA;KACK,MAAA;AACLG,QAAAA,gBAAAA,CAAiBF,QAAU,EAAA;AACzBf,YAAAA,SAAAA;AACAa,YAAAA,aAAAA;AACAC,YAAAA;AACF,SAAA,CAAA;AACF;AACF,CAAA;AAEA;;;;;;;;;;;AAWC,IACD,MAAMO,gBAAAA,GAAmB,CACvBR,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;IAEA,IAAIP,kBAAAA,CAAmBR,eAAe,CAACM,gBAAgBN,SAAcO,CAAAA,IAAAA,OAAAA,CAAQP,UAAS,CAAI,EAAA;AACxFgB,QAAAA,eAAAA,CAAgBD,QAAU,EAAA;AACxBf,YAAAA,SAAAA;AACAa,YAAAA,aAAAA;AACAC,YAAAA;AACF,SAAA,CAAA;AACF;AACF,CAAA;AAEA;;;;;;;;;;IAWA,MAAMQ,gBAAmB,GAAA,CAACT,aAAuBb,EAAAA,SAAAA,GAAAA;IAC/C,MAAMuB,YAAAA,GAAejC,iBAAYkC,CAAAA,4BAA4B,CAAC,QAAA,CAAA;IAC9D,MAAMC,cAAAA,GAAiBnC,iBAAYoC,CAAAA,sBAAsB,CAAC,QAAA,CAAA;IAE1DC,MAAOC,CAAAA,MAAM,CAAC5B,SAAW,EAAA;QACvB6B,KAAO,EAAA,IAAA;QACPC,WAAa9B,EAAAA,SAAAA,CAAU8B,WAAW,IAAI;YACpCC,UAAY,EAAA;gBACVC,IAAMP,EAAAA;AACR,aAAA;YACAQ,QAAU,EAAA;gBACRD,IAAMT,EAAAA,YAAAA;gBACNW,gBAAkB7C,EAAAA;AACpB;AACF;AACF,KAAA,CAAA;AACF,CAAA;AAEA;;AAEC,IACD,MAAM8C,iBAAAA,GAAoB,CACxBtB,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;IAEA,IAAI,WAAA,IAAef,SAAaA,IAAAA,SAAAA,CAAUoC,SAAS,IAAI,CAACpC,SAAUoC,CAAAA,SAAS,CAACC,YAAY,EAAE;AACxF,QAAA;AACF;AAEA,IAAA,MAAMC,gBAAgBhD,iBAAYiD,CAAAA,iBAAiB,CAACzB,IAAAA,CAAK0B,SAAS,EAAE3B,aAAAA,CAAAA;AACpE,IAAA,MAAM4B,iBAAiBnD,iBAAYoD,CAAAA,6BAA6B,CAACC,WAAAA,CAAU7B,KAAK8B,YAAY,CAAA,CAAA;IAC5F,MAAMrB,YAAAA,GAAejC,iBAAYuD,CAAAA,6BAA6B,CAAChC,aAAAA,CAAAA;IAC/D,MAAMY,cAAAA,GAAiBnC,iBAAYoC,CAAAA,sBAAsB,CAACb,aAAAA,CAAAA;IAE1D,MAAMiC,WAAAA,GAAcxD,iBAAYyD,CAAAA,cAAc,CAACT,aAAAA,CAAAA;AAE/CvB,IAAAA,QAAAA,CAASiC,GAAG,CAAC;QACXJ,YAAcN,EAAAA,aAAAA;QACdW,GAAKX,EAAAA,aAAAA;QACLE,SAAWF,EAAAA,aAAAA;QACXY,UAAY,EAAA;AACV,YAAA,CAAC7D,KAAK;gBACJ8D,IAAM,EAAA;AACR,aAAA;AACA,YAAA,CAACV,iBAAiB;gBAChBU,IAAM,EAAA,SAAA;gBACNC,MAAQ,EAAA;oBACNC,QAAU,EAAA;AACZ,iBAAA;;gBAEAC,UAAYb,EAAAA;AACd,aAAA;AACA,YAAA,CAAClB,eAAe;gBACd4B,IAAM,EAAA,SAAA;gBACNC,MAAQ,EAAA;oBACNC,QAAU,EAAA;AACZ;AACF,aAAA;AACA,YAAA,CAAC5B,iBAAiB;gBAChB0B,IAAM,EAAA;AACR,aAAA;AACA,YAAA,CAACzD,QAAQ;gBACPyD,IAAM,EAAA;AACR,aAAA;AACA,YAAA,CAAC3D,QAAQ;gBACP2D,IAAM,EAAA,OAAA;gBACNC,MAAQ,EAAA;oBACNC,QAAU,EAAA;AACZ;AACF;AACF,SAAA;QACAE,OAAS,EAAA;AACP,YAAA;gBACEvB,IAAMc,EAAAA,WAAAA;gBACNU,OAAS,EAAA;AAACf,oBAAAA;AAAe;AAC3B,aAAA;AACA,YAAA;gBACET,IAAM1C,EAAAA,iBAAAA,CAAYmE,iBAAiB,CAACnB,aAAAA,CAAAA;gBACpCkB,OAAS,EAAA;AAAChE,oBAAAA;AAAM;AAClB,aAAA;AACA,YAAA;gBACEwC,IAAM1C,EAAAA,iBAAAA,CAAYoE,oBAAoB,CAACpB,aAAAA,CAAAA;gBACvCkB,OAAS,EAAA;AAACjC,oBAAAA;AAAa;AACzB;AACD,SAAA;QACDoC,WAAa,EAAA;AACX,YAAA;gBACE3B,IAAMc,EAAAA,WAAAA;gBACNU,OAAS,EAAA;AAACf,oBAAAA;AAAe,iBAAA;gBACzBmB,iBAAmB,EAAA;AAACvE,oBAAAA;AAAG,iBAAA;AACvBwE,gBAAAA,eAAAA,EAAiB/C,KAAK0B,SAAS;gBAC/BsB,QAAU,EAAA;AACZ;AACD,SAAA;AACDC,QAAAA,UAAAA,EAAY,EAAC;AACbC,QAAAA,iBAAAA,EAAmB;AACrB,KAAA,CAAA;AAEA,IAAA,MAAM5B,SAA4B,GAAA;QAChCC,YAAc,EAAA,IAAA;QACdL,IAAMM,EAAAA,aAAAA;QACN2B,UAAY,EAAA;YACVjC,IAAMS,EAAAA,cAAAA;YACNP,gBAAkB7C,EAAAA;AACpB,SAAA;QACAyC,WAAa,EAAA;YACXC,UAAY,EAAA;gBACVC,IAAMP,EAAAA;AACR,aAAA;YACAQ,QAAU,EAAA;gBACRD,IAAMT,EAAAA,YAAAA;gBACNW,gBAAkB7C,EAAAA;AACpB;AACF,SAAA;QACA6E,OAAS,EAAA;YACPC,KAAO,EAAA;AACT,SAAA;QACAC,YAAc,EAAA;AAAC3B,YAAAA,cAAAA;AAAgBhB,YAAAA,cAAAA;AAAgBF,YAAAA;AAAa;AAC9D,KAAA;AAEAvB,IAAAA,SAAAA,CAAUoC,SAAS,GAAGA,SAAAA;AACxB,CAAA;AAEA;;AAEC,IACD,MAAMiC,cAAAA,GAAiB,CACrBxD,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;AAEA,IAAA,MAAMuD,UAAavD,GAAAA,QAAAA,CAASwD,GAAG,CAACvE,UAAUwE,MAAM,CAAA;AAEhD,IAAA,IAAI,CAACF,UAAY,EAAA;QACf,MAAM,IAAInD,MAAM,CAAC,oCAAoC,EAAEnB,SAAUwE,CAAAA,MAAM,CAAC,CAAC,CAAA;AAC3E;AAEA,IAAA,IAAIxE,SAAUyE,CAAAA,OAAO,IAAI,CAACC,CAAEC,CAAAA,GAAG,CAAC3E,SAAAA,CAAUyE,OAAO,EAAEH,UAAWpB,CAAAA,UAAU,CAAG,EAAA;QACzE,MAAM,IAAI/B,MAAM,CAAC,8CAA8C,EAAEnB,SAAUyE,CAAAA,OAAO,CAAC,CAAC,CAAA;AACtF;AACF,CAAA;AAEA;;AAEC,IACD,MAAMG,eAAAA,GAAkB,CACtB/D,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;AAEA,IAAA,MAAMuD,UAAavD,GAAAA,QAAAA,CAASwD,GAAG,CAACvE,UAAUwE,MAAM,CAAA;AAEhD,IAAA,IAAI,CAACF,UAAY,EAAA;QACf,MAAM,IAAInD,MAAM,CAAC,oCAAoC,EAAEnB,SAAUwE,CAAAA,MAAM,CAAC,CAAC,CAAA;AAC3E;AAEA,IAAA,IAAIxE,SAAUyE,CAAAA,OAAO,IAAI,CAACC,CAAEC,CAAAA,GAAG,CAAC3E,SAAAA,CAAUyE,OAAO,EAAEH,UAAWpB,CAAAA,UAAU,CAAG,EAAA;QACzE,MAAM,IAAI/B,MAAM,CAAC,8CAA8C,EAAEnB,SAAUyE,CAAAA,OAAO,CAAC,CAAC,CAAA;AACtF;AACF,CAAA;AAEA;;IAGA,MAAMxD,mBAAmB,CAACF,QAAAA,EAAoB,EAAEf,SAAS,EAAEa,aAAa,EAAqB,GAAA;AAC3F,IAAA,MAAMyD,UAAavD,GAAAA,QAAAA,CAASwD,GAAG,CAACvE,UAAUwE,MAAM,CAAA;AAEhD,IAAA,IAAI,CAACF,UAAY,EAAA;QACf,MAAM,IAAInD,MAAM,CAAC,eAAe,EAAEnB,SAAUwE,CAAAA,MAAM,CAAC,CAAC,CAAA;AACtD;AAEA,IAAA,MAAM/B,cAAiBnD,GAAAA,iBAAAA,CAAYkC,4BAA4B,CAACmB,WAAU9B,CAAAA,aAAAA,CAAAA,CAAAA;AAC1E,IAAA,MAAMoD,UAAa,GAAA;QACjBjC,IAAMS,EAAAA,cAAAA;QACNP,gBAAkB7C,EAAAA,EAAAA;AAClBwE,QAAAA,eAAAA,EAAiBS,WAAW9B;AAC9B,KAAA;AAEA,IAAA,IAAI,gBAAgBxC,SAAW,EAAA;AAC7B2B,QAAAA,MAAAA,CAAOC,MAAM,CAACqC,UAAYjE,EAAAA,SAAAA,CAAUiE,UAAU,CAAA;AAChD;IAEAtC,MAAOC,CAAAA,MAAM,CAAC5B,SAAW,EAAA;QAAE6B,KAAO,EAAA,IAAA;AAAMoC,QAAAA;AAAW,KAAA,CAAA;AAEnD,IAAA,IAAI3D,gBAAgBN,SAAY,CAAA,EAAA;AAC9B,QAAA,MAAM6E,mBAAmBP,UAAWpB,CAAAA,UAAU,CAAClD,SAAAA,CAAU8E,UAAU,CAAC;QAEpEnD,MAAOC,CAAAA,MAAM,CAACiD,gBAAkB,EAAA;YAC9BZ,UAAY,EAAA;AACVjC,gBAAAA,IAAAA,EAAMiC,WAAW/B,gBAAgB;gBACjCA,gBAAkBO,EAAAA;AACpB;AACF,SAAA,CAAA;AACF;AACF,CAAA;AAEA;;IAGA,MAAMzB,eAAkB,GAAA,CACtBD,QACA,EAAA,EAAEF,aAAa,EAAEb,SAAS,EAAEc,IAAI,EAAoB,GAAA;IAEpD,IAAI,CAACN,mBAAmBR,SAAY,CAAA,EAAA;AAClC,QAAA,MAAM,IAAImB,KAAM,CAAA,2DAAA,CAAA;AAClB;AAEA,IAAA,MAAMmD,UAAavD,GAAAA,QAAAA,CAASwD,GAAG,CAACvE,UAAUwE,MAAM,CAAA;AAEhD,IAAA,IAAI,CAACF,UAAY,EAAA;QACf,MAAM,IAAInD,MAAM,CAAC,eAAe,EAAEnB,SAAUwE,CAAAA,MAAM,CAAC,CAAC,CAAA;AACtD;;IAGA,IAAI,WAAA,IAAexE,SAAaA,IAAAA,SAAAA,CAAUoC,SAAS,IAAI,CAACpC,SAAUoC,CAAAA,SAAS,CAACC,YAAY,EAAE;AACxF,QAAA;AACF;IAEA,MAAMC,aAAAA,GAAgBhD,kBAAYyF,gBAAgB,CAChDpC,YAAU7B,IAAK0B,CAAAA,SAAS,GACxBG,WAAU9B,CAAAA,aAAAA,CAAAA,CAAAA;AAGZ,IAAA,MAAM4B,iBAAiBnD,iBAAYkC,CAAAA,4BAA4B,CAACmB,WAAAA,CAAU7B,KAAK8B,YAAY,CAAA,CAAA;AAE3F,IAAA,IAAIoC,wBAAwB1F,iBAAYkC,CAAAA,4BAA4B,CAClEmB,WAAAA,CAAU2B,WAAW1B,YAAY,CAAA,CAAA;;AAInC,IAAA,IAAIH,mBAAmBuC,qBAAuB,EAAA;AAC5CA,QAAAA,qBAAAA,GAAwB1F,iBAAY2F,CAAAA,mCAAmC,CACrEtC,WAAAA,CAAU2B,WAAW1B,YAAY,CAAA,CAAA;AAErC;AAEA,IAAA,MAAMsC,kBAAkB5F,iBAAY6F,CAAAA,kBAAkB,CAACxC,WAAAA,CAAU2B,WAAW1B,YAAY,CAAA,CAAA;;AAExF,IAAA,IAAIwC,yBAAyB9F,iBAAY6F,CAAAA,kBAAkB,CAACxC,WAAAA,CAAU7B,KAAK8B,YAAY,CAAA,CAAA;;AAGvF,IAAA,IAAI5C,SAAUE,CAAAA,QAAQ,KAAK,YAAA,IAAgBgF,oBAAoBE,sBAAwB,EAAA;AACrFA,QAAAA,sBAAAA,GAAyB9F,iBAAY+F,CAAAA,yBAAyB,CAAC1C,WAAAA,CAAU7B,KAAK8B,YAAY,CAAA,CAAA;AAC5F;IAEA,MAAME,WAAAA,GAAcxD,iBAAYyD,CAAAA,cAAc,CAACT,aAAAA,CAAAA;IAC/C,MAAMgD,cAAAA,GAAiBhG,iBAAYiG,CAAAA,qBAAqB,CAACjD,aAAAA,CAAAA;AAEzD,IAAA,MAAMkD,cAAuB,GAAA;QAC3B5C,YAAcN,EAAAA,aAAAA;QACdW,GAAKX,EAAAA,aAAAA;QACLE,SAAWF,EAAAA,aAAAA;QACXY,UAAY,EAAA;AACV,YAAA,CAAC7D,KAAK;gBACJ8D,IAAM,EAAA;AACR,aAAA;AACA,YAAA,CAACV,iBAAiB;gBAChBU,IAAM,EAAA,SAAA;gBACNC,MAAQ,EAAA;oBACNC,QAAU,EAAA;AACZ,iBAAA;;gBAEAC,UAAYb,EAAAA;AACd,aAAA;AACA,YAAA,CAACuC,wBAAwB;gBACvB7B,IAAM,EAAA,SAAA;gBACNC,MAAQ,EAAA;oBACNC,QAAU,EAAA;AACZ,iBAAA;;gBAEAC,UAAY0B,EAAAA;AACd;AAEF,SAAA;QACAzB,OAAS,EAAA;AACP,YAAA;gBACEvB,IAAMc,EAAAA,WAAAA;gBACNU,OAAS,EAAA;AAACf,oBAAAA;AAAe;AAC3B,aAAA;AACA,YAAA;gBACET,IAAMsD,EAAAA,cAAAA;gBACN9B,OAAS,EAAA;AAACwB,oBAAAA;AAAsB;AAClC,aAAA;AACA,YAAA;gBACEhD,IAAM1C,EAAAA,iBAAAA,CAAYmG,kBAAkB,CAACnD,aAAAA,CAAAA;gBACrCkB,OAAS,EAAA;AAACf,oBAAAA,cAAAA;AAAgBuC,oBAAAA;AAAsB,iBAAA;gBAChD7B,IAAM,EAAA;AACR;AACD,SAAA;QACDQ,WAAa,EAAA;AACX,YAAA;gBACE3B,IAAMc,EAAAA,WAAAA;gBACNU,OAAS,EAAA;AAACf,oBAAAA;AAAe,iBAAA;gBACzBmB,iBAAmB,EAAA;AAACvE,oBAAAA;AAAG,iBAAA;AACvBwE,gBAAAA,eAAAA,EAAiB/C,KAAK0B,SAAS;gBAC/BsB,QAAU,EAAA;AACZ,aAAA;AACA,YAAA;gBACE9B,IAAMsD,EAAAA,cAAAA;gBACN9B,OAAS,EAAA;AAACwB,oBAAAA;AAAsB,iBAAA;gBAChCpB,iBAAmB,EAAA;AAACvE,oBAAAA;AAAG,iBAAA;AACvBwE,gBAAAA,eAAAA,EAAiBS,WAAW9B,SAAS;gBACrCsB,QAAU,EAAA;AACZ;AACD,SAAA;AACDC,QAAAA,UAAAA,EAAY,EAAC;AACbC,QAAAA,iBAAAA,EAAmB;AACrB,KAAA;AAEA,IAAA,MAAM5B,SAAY,GAAA;QAChBC,YAAc,EAAA,IAAA;QACdL,IAAMM,EAAAA,aAAAA;QACN2B,UAAY,EAAA;YACVjC,IAAMS,EAAAA,cAAAA;YACNP,gBAAkB7C,EAAAA,EAAAA;AAClBwE,YAAAA,eAAAA,EAAiB/C,KAAK0B;AACxB,SAAA;QACAkD,iBAAmB,EAAA;YACjB1D,IAAMgD,EAAAA,qBAAAA;YACN9C,gBAAkB7C,EAAAA,EAAAA;AAClBwE,YAAAA,eAAAA,EAAiBS,WAAW9B;AAC9B,SAAA;QACA4B,YAAc,EAAA;AAAC3B,YAAAA,cAAAA;AAAgBuC,YAAAA;AAAsB;AACvD,KAAA;;AAGA,IAAA,IAAI3E,YAAYL,SAAY,CAAA,EAAA;QAC1BwF,cAAetC,CAAAA,UAAU,CAACgC,eAAAA,CAAgB,GAAG;YAC3C/B,IAAM,EAAA,OAAA;YACNC,MAAQ,EAAA;gBACNC,QAAU,EAAA,IAAA;gBACVsC,SAAW,EAAA;AACb,aAAA;YACArC,UAAY4B,EAAAA;AACd,SAAA;QACAM,cAAejC,CAAAA,OAAO,CAACqC,IAAI,CAAC;YAC1B5D,IAAM1C,EAAAA,iBAAAA,CAAYuG,mBAAmB,CAACvD,aAAAA,CAAAA;YACtCkB,OAAS,EAAA;AAAC0B,gBAAAA;AAAgB;AAC5B,SAAA,CAAA;AACA9C,QAAAA,SAAAA,CAAU8C,eAAe,GAAGA,eAAAA;AAC5B9C,QAAAA,SAAAA,CAAU8B,OAAO,GAAG;AAAE,YAAA,CAACgB,kBAAkB;AAAM,SAAA;AACjD;;IAGA,IAAI5E,eAAAA,CAAgBN,SAAcG,CAAAA,IAAAA,WAAAA,CAAYH,SAAY,CAAA,EAAA;QACxDwF,cAAetC,CAAAA,UAAU,CAACkC,sBAAAA,CAAuB,GAAG;YAClDjC,IAAM,EAAA,OAAA;YACNC,MAAQ,EAAA;gBACNC,QAAU,EAAA,IAAA;gBACVsC,SAAW,EAAA;AACb,aAAA;YACArC,UAAY8B,EAAAA;AACd,SAAA;QAEAI,cAAejC,CAAAA,OAAO,CAACqC,IAAI,CAAC;YAC1B5D,IAAM1C,EAAAA,iBAAAA,CAAYwG,0BAA0B,CAACxD,aAAAA,CAAAA;YAC7CkB,OAAS,EAAA;AAAC4B,gBAAAA;AAAuB;AACnC,SAAA,CAAA;AAEAhD,QAAAA,SAAAA,CAAUgD,sBAAsB,GAAGA,sBAAAA;AACrC;AAEArE,IAAAA,QAAAA,CAASiC,GAAG,CAACwC,cAAAA,CAAAA;AAEbxF,IAAAA,SAAAA,CAAUoC,SAAS,GAAGA,SAAAA;AAEtB,IAAA,IAAI9B,gBAAgBN,SAAY,CAAA,EAAA;QAC9B,MAAM6E,gBAAAA,GAAmB7E,SAAU8E,CAAAA,UAAU,GACxCR,UAAAA,CAAWpB,UAAU,CAAClD,SAAAA,CAAU8E,UAAU,CAAC,GAC5C,IAAA;AAEJ,QAAA,IAAI,CAACD,gBAAkB,EAAA;AACrB,YAAA,MAAM,IAAI1D,KAAAA,CACR,CAAC,qBAAqB,EAAEnB,SAAAA,CAAU8E,UAAU,CAAC,kBAAkB,EAAER,UAAWrB,CAAAA,GAAG,CAAC,CAAC,CAAA;AAErF;QAEA,IAAI4B,gBAAAA,CAAiB1B,IAAI,KAAK,UAAY,EAAA;AACxC,YAAA,MAAM,IAAIhC,KAAAA,CACR,CAAC,qBAAqB,EAAEnB,SAAAA,CAAU8E,UAAU,CAAC,qCAAqC,EAAER,UAAWrB,CAAAA,GAAG,CAAC,CAAC,CAAA;AAExG;AAEA4B,QAAAA,gBAAAA,CAAiBzC,SAAS,GAAG;YAC3BC,YAAc,EAAA,IAAA;YACdL,IAAMM,EAAAA,aAAAA;AACN2B,YAAAA,UAAAA,EAAY7B,UAAUsD,iBAAiB;AACvCA,YAAAA,iBAAAA,EAAmBtD,UAAU6B,UAAU;AACvCG,YAAAA,YAAAA,EAAchC,UAAUgC;AAC1B,SAAA;AAEA,QAAA,IAAIjE,YAAYH,SAAY,CAAA,EAAA;YAC1B6E,gBAAiBzC,CAAAA,SAAS,CAAC8C,eAAe,GAAGE,sBAAAA;YAC7CP,gBAAiBzC,CAAAA,SAAS,CAAC8B,OAAO,GAAG;AAAE,gBAAA,CAACkB,yBAAyB;AAAM,aAAA;AACzE;AACA,QAAA,IAAI/E,YAAYL,SAAY,CAAA,EAAA;YAC1B6E,gBAAiBzC,CAAAA,SAAS,CAACgD,sBAAsB,GAAGF,eAAAA;AACtD;AACF;AACF,CAAA;AAEA;;AAEC,IACYa,MAAAA,cAAAA,GAAiB,CAC5BlF,aAAAA,EACAb,WACAc,IACAC,EAAAA,QAAAA,GAAAA;AAEA,IAAA,OAAQf,UAAUE,QAAQ;QACxB,KAAK,UAAA;YACH,OAAOU,cAAAA,CAAeC,aAAeb,EAAAA,SAAAA,EAAWc,IAAMC,EAAAA,QAAAA,CAAAA;QACxD,KAAK,WAAA;YACH,OAAOG,eAAAA,CAAgBL,aAAeb,EAAAA,SAAAA,EAAWc,IAAMC,EAAAA,QAAAA,CAAAA;QACzD,KAAK,WAAA;YACH,OAAOK,eAAAA,CAAgBP,aAAeb,EAAAA,SAAAA,EAAWc,IAAMC,EAAAA,QAAAA,CAAAA;QACzD,KAAK,YAAA;YACH,OAAOM,gBAAAA,CAAiBR,aAAeb,EAAAA,SAAAA,EAAWc,IAAMC,EAAAA,QAAAA,CAAAA;QAC1D,KAAK,YAAA;AACH,YAAA,OAAOO,iBAAiBT,aAAeb,EAAAA,SAAAA,CAAAA;QACzC,KAAK,aAAA;YACH,OAAOmC,iBAAAA,CAAkBtB,aAAeb,EAAAA,SAAAA,EAAWc,IAAMC,EAAAA,QAAAA,CAAAA;QAC3D,KAAK,UAAA;YACH,OAAOsD,cAAAA,CAAexD,aAAeb,EAAAA,SAAAA,EAAWc,IAAMC,EAAAA,QAAAA,CAAAA;QACxD,KAAK,WAAA;YACH,OAAO6D,eAAAA,CAAgB/D,aAAeb,EAAAA,SAAAA,EAAWc,IAAMC,EAAAA,QAAAA,CAAAA;AACzD,QAAA;AAAS,YAAA;AACP,gBAAA,MAAM,IAAII,KAAAA,CAAM,CAAC,gBAAgB,CAAC,CAAA;AACpC;AACF;AACF;;;;;;;;;;;"}