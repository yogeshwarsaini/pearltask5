{"version":3,"file":"apply.mjs","sources":["../../../../src/query/helpers/populate/apply.ts"],"sourcesContent":["import _ from 'lodash/fp';\n\nimport { fromRow } from '../transform';\nimport type { QueryBuilder } from '../../query-builder';\nimport type { Database } from '../../..';\nimport type { Meta } from '../../../metadata';\nimport { ID, RelationalAttribute, Relation } from '../../../types';\n\n// We must select the join column id, however whatever it is named will overwrite an attribute of the same name\n// Therefore, we will prefix with something unlikely to conflict with a user attribute\n// TODO: ...and completely restrict the strapi_ prefix for an attribute name in the future\nconst joinColPrefix = '__strapi' as const;\n\ntype Context = {\n  db: Database;\n  qb: QueryBuilder;\n  uid: string;\n};\n\ntype Input<TRelationAttribute extends RelationalAttribute = RelationalAttribute> = {\n  attribute: TRelationAttribute;\n  attributeName: string;\n  results: Row[];\n  populateValue: {\n    on?: Record<string, Record<string, unknown>>;\n  } & Record<string, unknown>;\n\n  isCount: boolean;\n};\n\ntype InputWithTarget<TRelationAttribute extends RelationalAttribute = RelationalAttribute> =\n  Input<TRelationAttribute> & {\n    targetMeta: Meta;\n  };\n\ntype MorphIdMap = Record<string, Record<ID, Row[]>>;\n\ntype Row = Record<string, unknown>;\n\n/**\n * Populate oneToOne and manyToOne relation\n * @param {*} input\n * @param {*} ctx\n * @returns\n */\nconst XtoOne = async (\n  input: InputWithTarget<Relation.OneToOne | Relation.ManyToOne>,\n  ctx: Context\n) => {\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\n  const { db, qb } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  if ('joinColumn' in attribute && attribute.joinColumn) {\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = attribute.joinColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[joinColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n\n      return;\n    }\n\n    const rows = await db.entityManager\n      .createQueryBuilder(targetMeta.uid)\n      .init(populateValue)\n      .addSelect(`${qb.alias}.${referencedColumnName}`)\n      .where({ [referencedColumnName]: referencedValues })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row[]>(referencedColumnName)(rows);\n\n    results.forEach((result) => {\n      result[attributeName] = fromTargetRow(_.first(map[result[joinColumnName] as string]));\n    });\n\n    return;\n  }\n\n  if ('joinTable' in attribute && attribute.joinTable) {\n    const { joinTable } = attribute;\n\n    const qb = db.entityManager.createQueryBuilder(targetMeta.uid);\n\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\n\n    const alias = qb.getAlias();\n    const joinColAlias = `${alias}.${joinColumnName}`;\n    const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;\n    const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (isCount) {\n      if (_.isEmpty(referencedValues)) {\n        results.forEach((result) => {\n          result[attributeName] = { count: 0 };\n        });\n        return;\n      }\n\n      const rows = await qb\n        .init(populateValue)\n        .join({\n          alias,\n          referencedTable: joinTable.name,\n          referencedColumn: joinTable.inverseJoinColumn.name,\n          rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n          rootTable: qb.alias,\n          on: joinTable.on,\n        })\n        .select([joinColAlias, qb.raw('count(*) AS count')])\n        .where({ [joinColAlias]: referencedValues })\n        .groupBy(joinColAlias)\n        .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\n\n      const map = rows.reduce(\n        (map, row) => {\n          map[row[joinColumnName]] = { count: Number(row.count) };\n          return map;\n        },\n        {} as Record<string, { count: number }>\n      );\n\n      results.forEach((result) => {\n        result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\n      });\n\n      return;\n    }\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n\n      return;\n    }\n\n    const rows = await qb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinTable.inverseJoinColumn.name,\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n        rootTable: qb.alias,\n        on: joinTable.on,\n        orderBy: joinTable.orderBy,\n      })\n      .addSelect(joinColSelect)\n      .where({ [joinColAlias]: referencedValues })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(joinColRenameAs)(rows);\n\n    results.forEach((result) => {\n      result[attributeName] = fromTargetRow(_.first(map[result[referencedColumnName] as string]));\n    });\n  }\n};\n\nconst oneToMany = async (input: InputWithTarget<Relation.OneToMany>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\n  const { db, qb } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  if ('joinColumn' in attribute && attribute.joinColumn) {\n    const {\n      name: joinColumnName,\n      referencedColumn: referencedColumnName,\n      on,\n    } = attribute.joinColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[joinColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n      return;\n    }\n\n    const rows = await db.entityManager\n      .createQueryBuilder(targetMeta.uid)\n      .init(populateValue)\n      .addSelect(`${qb.alias}.${referencedColumnName}`)\n      .where({\n        [referencedColumnName]: referencedValues,\n        ...(on && typeof on === 'function' ? on({ populateValue, results }) : {}),\n      })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(referencedColumnName)(rows);\n\n    results.forEach((result) => {\n      result[attributeName] = fromTargetRow(map[result[joinColumnName] as string] || []);\n    });\n\n    return;\n  }\n\n  if ('joinTable' in attribute && attribute.joinTable) {\n    const { joinTable } = attribute;\n\n    const qb = db.entityManager.createQueryBuilder(targetMeta.uid);\n\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\n\n    const alias = qb.getAlias();\n    const joinColAlias = `${alias}.${joinColumnName}`;\n    const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;\n    const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (isCount) {\n      if (_.isEmpty(referencedValues)) {\n        results.forEach((result) => {\n          result[attributeName] = { count: 0 };\n        });\n        return;\n      }\n\n      const rows = await qb\n        .init(populateValue)\n        .join({\n          alias,\n          referencedTable: joinTable.name,\n          referencedColumn: joinTable.inverseJoinColumn.name,\n          rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n          rootTable: qb.alias,\n          on: joinTable.on,\n        })\n        .select([joinColSelect, qb.raw('count(*) AS count')])\n        .where({ [joinColAlias]: referencedValues })\n        .groupBy(joinColAlias)\n        .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\n\n      const map = rows.reduce(\n        (map, row) => {\n          map[row[joinColRenameAs]] = { count: Number(row.count) };\n          return map;\n        },\n        {} as Record<string, { count: number }>\n      );\n\n      results.forEach((result) => {\n        result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\n      });\n\n      return;\n    }\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = [];\n      });\n      return;\n    }\n\n    const rows = await qb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinTable.inverseJoinColumn.name,\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n        rootTable: qb.alias,\n        on: joinTable.on,\n        orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\n      })\n      .addSelect(joinColSelect)\n      .where({ [joinColAlias]: referencedValues })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(joinColRenameAs)(rows);\n\n    results.forEach((r) => {\n      r[attributeName] = fromTargetRow(map[r[referencedColumnName] as string] || []);\n    });\n  }\n};\n\nconst manyToMany = async (input: InputWithTarget<Relation.ManyToMany>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\n  const { db } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  const { joinTable } = attribute;\n\n  const populateQb = db.entityManager.createQueryBuilder(targetMeta.uid);\n\n  const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\n\n  const alias = populateQb.getAlias();\n  const joinColAlias = `${alias}.${joinColumnName}`;\n  const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;\n  const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;\n\n  const referencedValues = _.uniq(\n    results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\n  );\n\n  if (isCount) {\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = { count: 0 };\n      });\n      return;\n    }\n\n    const rows = await populateQb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinTable.inverseJoinColumn.name,\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n        rootTable: populateQb.alias,\n        on: joinTable.on,\n      })\n      .select([joinColAlias, populateQb.raw('count(*) AS count')])\n      .where({ [joinColAlias]: referencedValues })\n      .groupBy(joinColAlias)\n      .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\n\n    const map = rows.reduce(\n      (map, row) => {\n        map[row[joinColumnName]] = { count: Number(row.count) };\n        return map;\n      },\n      {} as Record<string, { count: number }>\n    );\n\n    results.forEach((result) => {\n      result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\n    });\n\n    return;\n  }\n\n  if (_.isEmpty(referencedValues)) {\n    results.forEach((result) => {\n      result[attributeName] = [];\n    });\n    return;\n  }\n\n  const rows = await populateQb\n    .init(populateValue)\n    .join({\n      alias,\n      referencedTable: joinTable.name,\n      referencedColumn: joinTable.inverseJoinColumn.name,\n      rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n      rootTable: populateQb.alias,\n      on: joinTable.on,\n      orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\n    })\n    .addSelect(joinColSelect)\n    .where({ [joinColAlias]: referencedValues })\n    .execute<Row[]>({ mapResults: false });\n\n  const map = _.groupBy<Row>(joinColRenameAs)(rows);\n\n  results.forEach((result) => {\n    result[attributeName] = fromTargetRow(map[result[referencedColumnName] as string] || []);\n  });\n};\n\nconst morphX = async (\n  input: InputWithTarget<Relation.MorphMany | Relation.MorphOne>,\n  ctx: Context\n) => {\n  const { attribute, attributeName, results, populateValue, targetMeta } = input;\n  const { db, uid } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  const { target, morphBy } = attribute;\n\n  const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n  if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n    const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n\n      return;\n    }\n\n    const rows = await db.entityManager\n      .createQueryBuilder(target)\n      .init(populateValue)\n      // .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\n      .where({ [idColumn.name]: referencedValues, [typeColumn.name]: uid })\n      .execute<Row>({ mapResults: false });\n\n    const map = _.groupBy<Row>(idColumn.name)(rows);\n\n    results.forEach((result) => {\n      const matchingRows = map[result[idColumn.referencedColumn] as string];\n\n      const matchingValue =\n        attribute.relation === 'morphOne' ? _.first(matchingRows) : matchingRows;\n\n      result[attributeName] = fromTargetRow(matchingValue);\n    });\n  } else if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToMany') {\n    const { joinTable } = targetAttribute;\n\n    const { joinColumn, morphColumn } = joinTable;\n\n    const { idColumn, typeColumn } = morphColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = attribute.relation === 'morphOne' ? null : [];\n      });\n\n      return;\n    }\n\n    // find with join table\n    const qb = db.entityManager.createQueryBuilder(target);\n\n    const alias = qb.getAlias();\n\n    const rows = await qb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinColumn.name,\n        rootColumn: joinColumn.referencedColumn,\n        rootTable: qb.alias,\n        on: {\n          ...(joinTable.on || {}),\n          field: attributeName,\n        },\n        orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\n      })\n      .addSelect([`${alias}.${idColumn.name}`, `${alias}.${typeColumn.name}`])\n      .where({\n        [`${alias}.${idColumn.name}`]: referencedValues,\n        [`${alias}.${typeColumn.name}`]: uid,\n      })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(idColumn.name)(rows);\n\n    results.forEach((result) => {\n      const matchingRows = map[result[idColumn.referencedColumn] as string];\n\n      const matchingValue =\n        attribute.relation === 'morphOne' ? _.first(matchingRows) : matchingRows;\n\n      result[attributeName] = fromTargetRow(matchingValue);\n    });\n  }\n};\n\nconst morphToMany = async (input: Input<Relation.MorphToMany>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue } = input;\n  const { db } = ctx;\n\n  // find with join table\n  const { joinTable } = attribute;\n\n  const { joinColumn, morphColumn } = joinTable;\n  const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n  // fetch join table to create the ids map then do the same as morphToOne without the first\n\n  const referencedValues = _.uniq(\n    results.map((r) => r[joinColumn.referencedColumn]).filter((value) => !_.isNil(value))\n  );\n\n  const qb = db.entityManager.createQueryBuilder(joinTable.name);\n\n  const joinRows = await qb\n    .where({\n      [joinColumn.name]: referencedValues,\n      ...(joinTable.on || {}),\n      // If the populateValue contains an \"on\" property,\n      // only populate the types defined in it\n      ...('on' in populateValue\n        ? { [morphColumn.typeColumn.name]: Object.keys(populateValue.on ?? {}) }\n        : {}),\n    })\n    .orderBy([joinColumn.name, 'order'])\n    .execute<Row[]>({ mapResults: false });\n\n  const joinMap = _.groupBy(joinColumn.name, joinRows);\n\n  const idsByType = joinRows.reduce<Record<string, ID[]>>((acc, result) => {\n    const idValue = result[morphColumn.idColumn.name] as ID;\n    const typeValue = result[morphColumn.typeColumn.name] as string;\n\n    if (!idValue || !typeValue) {\n      return acc;\n    }\n\n    if (!_.has(typeValue, acc)) {\n      acc[typeValue] = [];\n    }\n\n    acc[typeValue].push(idValue);\n\n    return acc;\n  }, {});\n\n  const map: MorphIdMap = {};\n  const { on, ...typePopulate } = populateValue;\n\n  for (const type of Object.keys(idsByType)) {\n    const ids = idsByType[type];\n\n    // type was removed but still in morph relation\n    if (!db.metadata.get(type)) {\n      map[type] = {};\n\n      continue;\n    }\n\n    const qb = db.entityManager.createQueryBuilder(type);\n\n    const rows = await qb\n      .init(on?.[type] ?? typePopulate)\n      .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\n      .where({ [idColumn.referencedColumn]: ids })\n      .execute<Row[]>({ mapResults: false });\n\n    map[type] = _.groupBy<Row>(idColumn.referencedColumn)(rows);\n  }\n\n  results.forEach((result) => {\n    const joinResults = joinMap[result[joinColumn.referencedColumn] as string] || [];\n\n    const matchingRows = joinResults.flatMap((joinResult) => {\n      const id = joinResult[idColumn.name] as ID;\n      const type = joinResult[typeColumn.name] as string;\n\n      const targetMeta = db.metadata.get(type);\n\n      const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n      return (map[type][id] || []).map((row) => {\n        return {\n          [typeField]: type,\n          ...fromTargetRow(row),\n        };\n      });\n    });\n\n    result[attributeName] = matchingRows;\n  });\n};\n\nconst morphToOne = async (input: Input<Relation.MorphToOne>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue } = input;\n  const { db } = ctx;\n\n  const { morphColumn } = attribute;\n  const { idColumn, typeColumn } = morphColumn;\n\n  // make a map for each type what ids to return\n  // make a nested map per id\n\n  const idsByType = results.reduce<Record<string, ID[]>>((acc, result) => {\n    const idValue = result[morphColumn.idColumn.name] as ID;\n    const typeValue = result[morphColumn.typeColumn.name] as string;\n\n    if (!idValue || !typeValue) {\n      return acc;\n    }\n\n    if (!(typeValue in acc)) {\n      acc[typeValue] = [];\n    }\n\n    acc[typeValue].push(idValue);\n\n    return acc;\n  }, {});\n\n  const map: MorphIdMap = {};\n  const { on, ...typePopulate } = populateValue;\n\n  for (const type of Object.keys(idsByType)) {\n    const ids = idsByType[type];\n\n    // type was removed but still in morph relation\n    if (!db.metadata.get(type)) {\n      map[type] = {};\n      return;\n    }\n\n    const qb = db.entityManager.createQueryBuilder(type);\n\n    const rows = await qb\n      .init(on?.[type] ?? typePopulate)\n      .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\n      .where({ [idColumn.referencedColumn]: ids })\n      .execute<Row[]>({ mapResults: false });\n\n    map[type] = _.groupBy<Row>(idColumn.referencedColumn)(rows);\n  }\n\n  results.forEach((result) => {\n    const id = result[idColumn.name] as ID;\n    const type = result[typeColumn.name] as string;\n\n    if (!type || !id) {\n      result[attributeName] = null;\n      return;\n    }\n\n    const matchingRows = map[type][id];\n\n    const fromTargetRow = (rowOrRows: Row | Row[] | undefined) =>\n      fromRow(db.metadata.get(type), rowOrRows);\n\n    result[attributeName] = fromTargetRow(_.first(matchingRows));\n  });\n};\n\n//  TODO: Omit limit & offset to avoid needing a query per result to avoid making too many queries\nconst pickPopulateParams = (populate: Record<string, unknown>) => {\n  const fieldsToPick = [\n    'select',\n    'count',\n    'where',\n    'populate',\n    'orderBy',\n    'filters',\n    'ordering',\n    'on',\n  ];\n\n  if (populate.count !== true) {\n    fieldsToPick.push('limit', 'offset');\n  }\n\n  return _.pick(fieldsToPick, populate);\n};\n\nconst getPopulateValue = (populate: Record<string, any>, filters: Record<string, any>) => {\n  const populateValue = {\n    filters,\n    ...pickPopulateParams(populate),\n  };\n\n  if ('on' in populateValue) {\n    populateValue.on = _.mapValues(\n      (value) => {\n        if (_.isPlainObject(value)) {\n          value.filters = filters;\n        }\n\n        return value;\n      },\n      populateValue.on as Record<string, any>\n    );\n  }\n\n  return populateValue;\n};\n\nconst applyPopulate = async (results: Row[], populate: Record<string, any>, ctx: Context) => {\n  const { db, uid, qb } = ctx;\n  const meta = db.metadata.get(uid);\n\n  if (_.isEmpty(results)) {\n    return results;\n  }\n\n  for (const attributeName of Object.keys(populate)) {\n    const attribute = meta.attributes[attributeName];\n\n    if (attribute.type !== 'relation') {\n      throw new Error(`Invalid populate attribute ${attributeName}`);\n    }\n\n    const populateValue = getPopulateValue(populate[attributeName], qb.state.filters);\n\n    const isCount = 'count' in populateValue && populateValue.count === true;\n\n    switch (attribute.relation) {\n      case 'oneToOne':\n      case 'manyToOne': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await XtoOne(input, ctx);\n        break;\n      }\n      case 'oneToMany': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await oneToMany(input, ctx);\n        break;\n      }\n      case 'manyToMany': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await manyToMany(input, ctx);\n        break;\n      }\n      case 'morphOne':\n      case 'morphMany': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await morphX(input, ctx);\n        break;\n      }\n      case 'morphToMany': {\n        const input = { attribute, attributeName, results, populateValue, isCount };\n        await morphToMany(input, ctx);\n        break;\n      }\n      case 'morphToOne': {\n        const input = { attribute, attributeName, results, populateValue, isCount };\n        await morphToOne(input, ctx);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n};\n\nexport default applyPopulate;\n"],"names":["joinColPrefix","XtoOne","input","ctx","attribute","attributeName","results","populateValue","targetMeta","isCount","db","qb","fromTargetRow","rowOrRows","fromRow","joinColumn","name","joinColumnName","referencedColumn","referencedColumnName","referencedValues","_","uniq","map","r","filter","value","isNil","isEmpty","forEach","result","rows","entityManager","createQueryBuilder","uid","init","addSelect","alias","where","execute","mapResults","groupBy","first","joinTable","getAlias","joinColAlias","joinColRenameAs","joinColSelect","count","join","referencedTable","inverseJoinColumn","rootColumn","rootTable","on","select","raw","reduce","row","Number","orderBy","oneToMany","mapValues","v","ordering","manyToMany","populateQb","morphX","target","morphBy","targetAttribute","metadata","get","attributes","type","relation","idColumn","typeColumn","morphColumn","matchingRows","matchingValue","field","morphToMany","typeField","joinRows","Object","keys","joinMap","idsByType","acc","idValue","typeValue","has","push","typePopulate","ids","joinResults","flatMap","joinResult","id","morphToOne","pickPopulateParams","populate","fieldsToPick","pick","getPopulateValue","filters","isPlainObject","applyPopulate","meta","Error","state"],"mappings":"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"}