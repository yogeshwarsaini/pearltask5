{"version":3,"file":"where.js","sources":["../../../src/query/helpers/where.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { isArray, castArray, isPlainObject } from 'lodash/fp';\nimport type { Knex } from 'knex';\n\nimport { isOperator, isOperatorOfType } from '@strapi/utils';\nimport * as types from '../../utils/types';\nimport { createField } from '../../fields';\nimport { createJoin } from './join';\nimport { toColumnName } from './transform';\nimport { isKnexQuery } from '../../utils/knex';\n\nimport type { Ctx } from '../types';\nimport type { Attribute } from '../../types';\n\ntype WhereCtx = Ctx & { alias?: string; isGroupRoot?: boolean };\n\nconst isRecord = (value: unknown): value is Record<string, unknown> => isPlainObject(value);\n\nconst castValue = (value: unknown, attribute: Attribute | null) => {\n  if (!attribute) {\n    return value;\n  }\n\n  if (types.isScalar(attribute.type) && !isKnexQuery(value)) {\n    const field = createField(attribute);\n\n    return value === null ? null : field.toDB(value);\n  }\n\n  return value;\n};\n\nconst processSingleAttributeWhere = (\n  attribute: Attribute | null,\n  where: unknown,\n  operator = '$eq'\n) => {\n  if (!isRecord(where)) {\n    if (isOperatorOfType('cast', operator)) {\n      return castValue(where, attribute);\n    }\n\n    return where;\n  }\n\n  const filters: Record<string, unknown> = {};\n\n  for (const key of Object.keys(where)) {\n    const value = where[key];\n\n    if (!isOperatorOfType('where', key)) {\n      throw new Error(`Undefined attribute level operator ${key}`);\n    }\n\n    filters[key] = processAttributeWhere(attribute, value, key);\n  }\n\n  return filters;\n};\n\nconst processAttributeWhere = (attribute: Attribute | null, where: unknown, operator = '$eq') => {\n  if (isArray(where)) {\n    return where.map((sub) => processSingleAttributeWhere(attribute, sub, operator));\n  }\n\n  return processSingleAttributeWhere(attribute, where, operator);\n};\n\nconst processNested = (where: unknown, ctx: WhereCtx) => {\n  if (!isRecord(where)) {\n    return where;\n  }\n\n  return processWhere(where, ctx);\n};\n\nconst processRelationWhere = (where: unknown, ctx: WhereCtx) => {\n  const { qb, alias } = ctx;\n\n  const idAlias = qb.aliasColumn('id', alias);\n  if (!isRecord(where)) {\n    return { [idAlias]: where };\n  }\n\n  const keys = Object.keys(where);\n  const operatorKeys = keys.filter((key) => isOperator(key));\n\n  if (operatorKeys.length > 0 && operatorKeys.length !== keys.length) {\n    throw new Error(`Operator and non-operator keys cannot be mixed in a relation where clause`);\n  }\n\n  if (operatorKeys.length > 1) {\n    throw new Error(\n      `Only one operator key is allowed in a relation where clause, but found: ${operatorKeys}`\n    );\n  }\n\n  if (operatorKeys.length === 1) {\n    const operator = operatorKeys[0];\n\n    if (isOperatorOfType('group', operator)) {\n      return processWhere(where, ctx);\n    }\n\n    return { [idAlias]: { [operator]: processNested(where[operator], ctx) } };\n  }\n\n  return processWhere(where, ctx);\n};\n\n/**\n * Process where parameter\n */\nfunction processWhere(where: Record<string, unknown>, ctx: WhereCtx): Record<string, unknown>;\nfunction processWhere(where: Record<string, unknown>[], ctx: WhereCtx): Record<string, unknown>[];\nfunction processWhere(\n  where: Record<string, unknown> | Record<string, unknown>[],\n  ctx: WhereCtx\n): Record<string, unknown> | Record<string, unknown>[] {\n  if (!isArray(where) && !isRecord(where)) {\n    throw new Error('Where must be an array or an object');\n  }\n\n  if (isArray(where)) {\n    return where.map((sub) => processWhere(sub, ctx));\n  }\n\n  const { db, uid, qb, alias } = ctx;\n  const meta = db.metadata.get(uid);\n\n  const filters: Record<string, unknown> = {};\n\n  // for each key in where\n  for (const key of Object.keys(where)) {\n    const value = where[key];\n\n    // if operator $and $or -> process recursively\n    if (isOperatorOfType('group', key)) {\n      if (!Array.isArray(value)) {\n        throw new Error(`Operator ${key} must be an array`);\n      }\n\n      filters[key] = value.map((sub) => processNested(sub, ctx));\n      continue;\n    }\n\n    if (key === '$not') {\n      filters[key] = processNested(value, ctx);\n      continue;\n    }\n\n    if (isOperatorOfType('where', key)) {\n      throw new Error(\n        `Only $and, $or and $not can only be used as root level operators. Found ${key}.`\n      );\n    }\n\n    const attribute = meta.attributes[key];\n\n    if (!attribute) {\n      filters[qb.aliasColumn(key, alias)] = processAttributeWhere(null, value);\n      continue;\n    }\n\n    if (types.isRelation(attribute.type) && 'target' in attribute) {\n      // attribute\n      const subAlias = createJoin(ctx, {\n        alias: alias || qb.alias,\n        attributeName: key,\n        attribute,\n      });\n\n      const nestedWhere = processRelationWhere(value, {\n        db,\n        qb,\n        alias: subAlias,\n        uid: attribute.target,\n      });\n\n      // TODO: use a better merge logic (push to $and when collisions)\n      Object.assign(filters, nestedWhere);\n\n      continue;\n    }\n\n    if (types.isScalar(attribute.type)) {\n      const columnName = toColumnName(meta, key);\n      const aliasedColumnName = qb.aliasColumn(columnName, alias);\n\n      filters[aliasedColumnName] = processAttributeWhere(attribute, value);\n\n      continue;\n    }\n\n    throw new Error(`You cannot filter on ${attribute.type} types`);\n  }\n\n  return filters;\n}\n\ntype Operator =\n  | '$eq'\n  | '$ne'\n  | '$nei'\n  | '$in'\n  | '$notIn'\n  | '$lt'\n  | '$lte'\n  | '$gt'\n  | '$gte'\n  | '$between'\n  | '$contains'\n  | '$notContains'\n  | '$containsi'\n  | '$notContainsi'\n  | '$startsWith'\n  | '$endsWith'\n  | '$null'\n  | '$notNull'\n  | '$not'\n  | '$eqi'\n  | '$startsWithi'\n  | '$endsWithi'\n  | '$jsonSupersetOf';\n\n// TODO: add type casting per operator at some point\nconst applyOperator = (qb: Knex.QueryBuilder, column: any, operator: Operator, value: any) => {\n  if (Array.isArray(value) && !isOperatorOfType('array', operator)) {\n    return qb.where((subQB) => {\n      value.forEach((subValue) =>\n        subQB.orWhere((innerQB) => {\n          applyOperator(innerQB, column, operator, subValue);\n        })\n      );\n    });\n  }\n\n  switch (operator) {\n    case '$not': {\n      qb.whereNot((qb) => applyWhereToColumn(qb, column, value));\n      break;\n    }\n\n    case '$in': {\n      // @ts-ignore\n      // TODO: fix in v5\n      qb.whereIn(column, isKnexQuery(value) ? value : castArray(value));\n      break;\n    }\n\n    case '$notIn': {\n      // @ts-ignore\n      // TODO: fix in v5\n      qb.whereNotIn(column, isKnexQuery(value) ? value : castArray(value));\n      break;\n    }\n\n    case '$eq': {\n      if (value === null) {\n        qb.whereNull(column);\n        break;\n      }\n\n      qb.where(column, value);\n      break;\n    }\n\n    case '$eqi': {\n      if (value === null) {\n        qb.whereNull(column);\n        break;\n      }\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `${value}`]);\n      break;\n    }\n    case '$ne': {\n      if (value === null) {\n        qb.whereNotNull(column);\n        break;\n      }\n\n      qb.where(column, '<>', value);\n      break;\n    }\n    case '$nei': {\n      if (value === null) {\n        qb.whereNotNull(column);\n        break;\n      }\n      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `${value}`]);\n      break;\n    }\n    case '$gt': {\n      qb.where(column, '>', value);\n      break;\n    }\n    case '$gte': {\n      qb.where(column, '>=', value);\n      break;\n    }\n    case '$lt': {\n      qb.where(column, '<', value);\n      break;\n    }\n    case '$lte': {\n      qb.where(column, '<=', value);\n      break;\n    }\n    case '$null': {\n      if (value) {\n        qb.whereNull(column);\n      } else {\n        qb.whereNotNull(column);\n      }\n      break;\n    }\n    case '$notNull': {\n      if (value) {\n        qb.whereNotNull(column);\n      } else {\n        qb.whereNull(column);\n      }\n      break;\n    }\n    case '$between': {\n      qb.whereBetween(column, value);\n      break;\n    }\n    case '$startsWith': {\n      qb.where(column, 'like', `${value}%`);\n      break;\n    }\n    case '$startsWithi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `${value}%`]);\n      break;\n    }\n    case '$endsWith': {\n      qb.where(column, 'like', `%${value}`);\n      break;\n    }\n    case '$endsWithi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `%${value}`]);\n      break;\n    }\n    case '$contains': {\n      qb.where(column, 'like', `%${value}%`);\n      break;\n    }\n\n    case '$notContains': {\n      qb.whereNot(column, 'like', `%${value}%`);\n      break;\n    }\n\n    case '$containsi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `%${value}%`]);\n      break;\n    }\n\n    case '$notContainsi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `%${value}%`]);\n      break;\n    }\n\n    // Experimental, only for internal use\n    // Only on MySQL, PostgreSQL and CockroachDB.\n    // https://knexjs.org/guide/query-builder.html#wherejsonsupersetof\n    case '$jsonSupersetOf': {\n      qb.whereJsonSupersetOf(column, value);\n      break;\n    }\n\n    // TODO: Add more JSON operators: whereJsonObject, whereJsonPath, whereJsonSubsetOf\n\n    // TODO: relational operators every/some/exists/size ...\n\n    default: {\n      throw new Error(`Undefined attribute level operator ${operator}`);\n    }\n  }\n};\n\nconst applyWhereToColumn = (\n  qb: Knex.QueryBuilder,\n  column: string,\n  columnWhere: Record<Operator, unknown> | Array<Record<Operator, unknown>>\n) => {\n  if (!isRecord(columnWhere)) {\n    if (Array.isArray(columnWhere)) {\n      return qb.whereIn(column, columnWhere);\n    }\n\n    return qb.where(column, columnWhere);\n  }\n\n  const keys = Object.keys(columnWhere) as Operator[];\n\n  keys.forEach((operator) => {\n    const value = columnWhere[operator];\n\n    applyOperator(qb, column, operator, value);\n  });\n};\n\ntype Where =\n  | {\n      $and?: Where[];\n      $or?: Where[];\n      $not?: Where;\n      [key: string]: any;\n    }\n  | Array<Where>;\n\nconst applyWhere = (qb: Knex.QueryBuilder, where: Where) => {\n  if (!isArray(where) && !isRecord(where)) {\n    throw new Error('Where must be an array or an object');\n  }\n\n  if (isArray(where)) {\n    return qb.where((subQB: Knex.QueryBuilder) =>\n      where.forEach((subWhere) => applyWhere(subQB, subWhere))\n    );\n  }\n\n  Object.keys(where).forEach((key) => {\n    if (key === '$and') {\n      const value = where[key] ?? [];\n\n      return qb.where((subQB: Knex.QueryBuilder) => {\n        value.forEach((v) => applyWhere(subQB, v));\n      });\n    }\n\n    if (key === '$or') {\n      const value = where[key] ?? [];\n\n      return qb.where((subQB: Knex.QueryBuilder) => {\n        value.forEach((v) => subQB.orWhere((inner) => applyWhere(inner, v)));\n      });\n    }\n\n    if (key === '$not') {\n      const value = where[key] ?? {};\n\n      return qb.whereNot((qb) => applyWhere(qb, value));\n    }\n\n    applyWhereToColumn(qb, key, where[key]);\n  });\n};\n\nconst fieldLowerFn = (qb: Knex.QueryBuilder) => {\n  // Postgres requires string to be passed\n  if (qb.client.dialect === 'postgresql') {\n    return 'LOWER(CAST(?? AS VARCHAR))';\n  }\n\n  return 'LOWER(??)';\n};\n\nexport { applyWhere, processWhere };\n"],"names":["isRecord","value","isPlainObject","castValue","attribute","types","type","isKnexQuery","field","createField","toDB","processSingleAttributeWhere","where","operator","isOperatorOfType","filters","key","Object","keys","Error","processAttributeWhere","isArray","map","sub","processNested","ctx","processWhere","processRelationWhere","qb","alias","idAlias","aliasColumn","operatorKeys","filter","isOperator","length","db","uid","meta","metadata","get","Array","attributes","subAlias","createJoin","attributeName","nestedWhere","target","assign","columnName","toColumnName","aliasedColumnName","applyOperator","column","subQB","forEach","subValue","orWhere","innerQB","whereNot","applyWhereToColumn","whereIn","castArray","whereNotIn","whereNull","whereRaw","fieldLowerFn","whereNotNull","whereBetween","whereJsonSupersetOf","columnWhere","applyWhere","subWhere","v","inner","client","dialect"],"mappings":"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"}