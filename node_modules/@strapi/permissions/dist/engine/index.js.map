{"version":3,"file":"index.js","sources":["../../src/engine/index.ts"],"sourcesContent":["import _ from 'lodash/fp';\nimport qs from 'qs';\nimport { Ability } from '@casl/ability';\nimport { providerFactory } from '@strapi/utils';\n\nimport {\n  createEngineHooks,\n  createWillRegisterContext,\n  createBeforeEvaluateContext,\n  createValidateContext,\n} from './hooks';\nimport type { PermissionEngineHooks, HookName } from './hooks';\n\nimport * as abilities from './abilities';\nimport { Permission } from '../domain/permission';\nimport type { PermissionRule } from '../types';\n\nexport { abilities };\n\ntype Provider = Omit<ReturnType<typeof providerFactory>, 'register'> & {\n  register(...args: unknown[]): Promise<Provider> | Provider;\n};\n\ntype ActionProvider = Provider;\ntype ConditionProvider = Provider;\n\nexport interface Engine {\n  hooks: PermissionEngineHooks;\n  on(hook: HookName, handler: (...args: any[]) => any): Engine;\n  generateAbility(permissions: Permission[], options?: object): Promise<Ability>;\n  createRegisterFunction(\n    can: (permission: PermissionRule) => unknown,\n    options: Record<string, unknown>\n  ): (permission: PermissionRule) => Promise<unknown>;\n}\n\nexport interface EngineParams {\n  providers: { action: ActionProvider; condition: ConditionProvider };\n  abilityBuilderFactory?(): abilities.CustomAbilityBuilder;\n}\n\ninterface EvaluateParams {\n  options: Record<string, unknown>;\n  register: (permission: PermissionRule) => Promise<unknown>;\n  permission: Permission;\n}\n\ninterface Condition {\n  name: string;\n  handler(...params: unknown[]): boolean | object;\n}\n\n/**\n * Create a default state object for the engine\n */\nconst createEngineState = () => {\n  const hooks = createEngineHooks();\n\n  return { hooks };\n};\n\nconst newEngine = (params: EngineParams): Engine => {\n  const { providers, abilityBuilderFactory = abilities.caslAbilityBuilder } = params;\n\n  const state = createEngineState();\n\n  const runValidationHook = async (hook: HookName, context: unknown) =>\n    state.hooks[hook].call(context);\n\n  /**\n   * Evaluate a permission using local and registered behaviors (using hooks).\n   * Validate, format (add condition, etc...), evaluate (evaluate conditions) and register a permission\n   */\n  const evaluate = async (params: EvaluateParams) => {\n    const { options, register } = params;\n\n    const preFormatValidation = await runValidationHook(\n      'before-format::validate.permission',\n      createBeforeEvaluateContext(params.permission)\n    );\n\n    if (preFormatValidation === false) {\n      return;\n    }\n\n    const permission = (await state.hooks['format.permission'].call(\n      params.permission\n    )) as Permission;\n\n    const afterFormatValidation = await runValidationHook(\n      'after-format::validate.permission',\n      createValidateContext(permission)\n    );\n\n    if (afterFormatValidation === false) {\n      return;\n    }\n\n    await state.hooks['before-evaluate.permission'].call(createBeforeEvaluateContext(permission));\n\n    const {\n      action: actionName,\n      subject,\n      properties,\n      conditions = [],\n      actionParameters = {},\n    } = permission;\n\n    let action = actionName;\n\n    if (actionParameters && Object.keys(actionParameters).length > 0) {\n      action = `${actionName}?${qs.stringify(actionParameters)}`;\n    }\n\n    if (conditions.length === 0) {\n      return register({ action, subject, properties });\n    }\n\n    const resolveConditions = _.map(providers.condition.get);\n\n    const removeInvalidConditions = _.filter((condition: Condition) =>\n      _.isFunction(condition.handler)\n    );\n\n    const evaluateConditions = (conditions: Condition[]) => {\n      return Promise.all(\n        conditions.map(async (condition) => ({\n          condition,\n          result: await condition.handler(\n            _.merge(options, { permission: _.cloneDeep(permission) })\n          ),\n        }))\n      );\n    };\n\n    const removeInvalidResults = _.filter(\n      ({ result }) => _.isBoolean(result) || _.isObject(result)\n    );\n\n    const evaluatedConditions = await Promise.resolve(conditions)\n      .then(resolveConditions)\n      .then(removeInvalidConditions)\n      .then(evaluateConditions)\n      .then(removeInvalidResults);\n\n    const resultPropEq = _.propEq('result');\n    const pickResults = _.map(_.prop('result'));\n\n    if (evaluatedConditions.every(resultPropEq(false))) {\n      return;\n    }\n\n    if (_.isEmpty(evaluatedConditions) || evaluatedConditions.some(resultPropEq(true))) {\n      return register({ action, subject, properties });\n    }\n\n    const results = pickResults(evaluatedConditions).filter(_.isObject);\n\n    if (_.isEmpty(results)) {\n      return register({ action, subject, properties });\n    }\n\n    return register({\n      action,\n      subject,\n      properties,\n      condition: { $and: [{ $or: results }] },\n    });\n  };\n\n  return {\n    get hooks() {\n      return state.hooks;\n    },\n\n    /**\n     * Create a register function that wraps a `can` function\n     * used to register a permission in the ability builder\n     */\n    createRegisterFunction(can, options: Record<string, unknown>) {\n      return async (permission: PermissionRule) => {\n        const hookContext = createWillRegisterContext({ options, permission });\n\n        await state.hooks['before-register.permission'].call(hookContext);\n\n        return can(permission);\n      };\n    },\n\n    /**\n     * Register a new handler for a given hook\n     */\n    on(hook, handler) {\n      const validHooks = Object.keys(state.hooks);\n      const isValidHook = validHooks.includes(hook);\n\n      if (!isValidHook) {\n        throw new Error(\n          `Invalid hook supplied when trying to register an handler to the permission engine. Got \"${hook}\" but expected one of ${validHooks.join(\n            ', '\n          )}`\n        );\n      }\n\n      state.hooks[hook].register(handler);\n\n      return this;\n    },\n\n    /**\n     * Generate an ability based on the instance's\n     * ability builder and the given permissions\n     */\n    async generateAbility(permissions, options: Record<string, unknown> = {}) {\n      const { can, build } = abilityBuilderFactory();\n\n      for (const permission of permissions) {\n        const register = this.createRegisterFunction(can, options);\n\n        await evaluate({ permission, options, register });\n      }\n\n      return build();\n    },\n  };\n};\n\nexport { newEngine as new };\n"],"names":["createEngineState","hooks","createEngineHooks","newEngine","params","providers","abilityBuilderFactory","abilities","state","runValidationHook","hook","context","call","evaluate","options","register","preFormatValidation","createBeforeEvaluateContext","permission","afterFormatValidation","createValidateContext","action","actionName","subject","properties","conditions","actionParameters","Object","keys","length","qs","stringify","resolveConditions","_","map","condition","get","removeInvalidConditions","filter","isFunction","handler","evaluateConditions","Promise","all","result","merge","cloneDeep","removeInvalidResults","isBoolean","isObject","evaluatedConditions","resolve","then","resultPropEq","propEq","pickResults","prop","every","isEmpty","some","results","$and","$or","createRegisterFunction","can","hookContext","createWillRegisterContext","on","validHooks","isValidHook","includes","Error","join","generateAbility","permissions","build"],"mappings":"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"}