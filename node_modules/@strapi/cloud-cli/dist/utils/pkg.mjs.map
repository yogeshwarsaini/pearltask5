{"version":3,"file":"pkg.mjs","sources":["../../src/utils/pkg.ts"],"sourcesContent":["import * as fse from 'fs-extra';\nimport os from 'os';\nimport pkgUp from 'pkg-up';\nimport * as yup from 'yup';\nimport chalk from 'chalk';\nimport { Logger } from '../services/logger';\n\ninterface Export {\n  types?: string;\n  source: string;\n  module?: string;\n  import?: string;\n  require?: string;\n  default: string;\n}\n\nconst packageJsonSchema = yup.object({\n  name: yup.string().required(),\n  exports: yup.lazy((value) =>\n    yup\n      .object(\n        typeof value === 'object'\n          ? Object.entries(value).reduce(\n              (acc, [key, value]) => {\n                if (typeof value === 'object') {\n                  acc[key] = yup\n                    .object({\n                      types: yup.string().optional(),\n                      source: yup.string().required(),\n                      module: yup.string().optional(),\n                      import: yup.string().required(),\n                      require: yup.string().required(),\n                      default: yup.string().required(),\n                    })\n                    .noUnknown(true);\n                } else {\n                  acc[key] = yup\n                    .string()\n                    .matches(/^\\.\\/.*\\.json$/)\n                    .required();\n                }\n\n                return acc;\n              },\n              {} as Record<string, yup.SchemaOf<string> | yup.SchemaOf<Export>>\n            )\n          : undefined\n      )\n      .optional()\n  ),\n});\n\ntype PackageJson = yup.Asserts<typeof packageJsonSchema>;\n\n/**\n * @description being a task to load the package.json starting from the current working directory\n * using a shallow find for the package.json  and `fs` to read the file. If no package.json is found,\n * the process will throw with an appropriate error message.\n */\nconst loadPkg = async ({ cwd, logger }: { cwd: string; logger: Logger }): Promise<PackageJson> => {\n  const pkgPath = await pkgUp({ cwd });\n\n  if (!pkgPath) {\n    throw new Error('Could not find a package.json in the current directory');\n  }\n\n  const buffer = await fse.readFile(pkgPath);\n\n  const pkg = JSON.parse(buffer.toString());\n\n  logger.debug('Loaded package.json:', os.EOL, pkg);\n\n  return pkg;\n};\n\n/**\n * @description validate the package.json against a standardised schema using `yup`.\n * If the validation fails, the process will throw with an appropriate error message.\n */\nconst validatePkg = async ({ pkg }: { pkg: object }): Promise<PackageJson> => {\n  try {\n    return await packageJsonSchema.validate(pkg, {\n      strict: true,\n    });\n  } catch (err) {\n    if (err instanceof yup.ValidationError) {\n      switch (err.type) {\n        case 'required':\n          if (err.path) {\n            throw new Error(\n              `'${err.path}' in 'package.json' is required as type '${chalk.magenta(\n                yup.reach(packageJsonSchema, err.path).type\n              )}'`\n            );\n          }\n          break;\n        /**\n         * This will only be thrown if there are keys in the export map\n         * that we don't expect so we can therefore make some assumptions\n         */\n        case 'noUnknown':\n          if (err.path && err.params && 'unknown' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' contains the unknown key ${chalk.magenta(\n                err.params.unknown\n              )}, for compatability only the following keys are allowed: ${chalk.magenta(\n                \"['types', 'source', 'import', 'require', 'default']\"\n              )}`\n            );\n          }\n          break;\n        default:\n          if (err.path && err.params && 'type' in err.params && 'value' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' must be of type '${chalk.magenta(\n                err.params.type\n              )}' (recieved '${chalk.magenta(typeof err.params.value)}')`\n            );\n          }\n      }\n    }\n\n    throw err;\n  }\n};\n\nexport type { PackageJson, Export };\nexport { loadPkg, validatePkg };\n"],"names":["yup","object","name","string","required","exports","lazy","value","Object","entries","reduce","acc","key","types","optional","source","module","import","require","default","noUnknown","matches","undefined","loadPkg","cwd","logger","pkgPath","pkgUp","Error","buffer","fse","readFile","pkg","JSON","parse","toString","debug","os","EOL"],"mappings":";;;;;;AAgB0BA,GAAIC,CAAAA,MAAM,CAAC;IACnCC,IAAMF,EAAAA,GAAAA,CAAIG,MAAM,EAAA,CAAGC,QAAQ,EAAA;IAC3BC,OAASL,EAAAA,GAAAA,CAAIM,IAAI,CAAC,CAACC,QACjBP,GACGC,CAAAA,MAAM,CACL,OAAOM,KAAAA,KAAU,WACbC,MAAOC,CAAAA,OAAO,CAACF,KAAOG,CAAAA,CAAAA,MAAM,CAC1B,CAACC,GAAAA,EAAK,CAACC,GAAAA,EAAKL,KAAM,CAAA,GAAA;YAChB,IAAI,OAAOA,UAAU,QAAU,EAAA;AAC7BI,gBAAAA,GAAG,CAACC,GAAAA,CAAI,GAAGZ,GAAAA,CACRC,MAAM,CAAC;oBACNY,KAAOb,EAAAA,GAAAA,CAAIG,MAAM,EAAA,CAAGW,QAAQ,EAAA;oBAC5BC,MAAQf,EAAAA,GAAAA,CAAIG,MAAM,EAAA,CAAGC,QAAQ,EAAA;oBAC7BY,MAAQhB,EAAAA,GAAAA,CAAIG,MAAM,EAAA,CAAGW,QAAQ,EAAA;oBAC7BG,MAAQjB,EAAAA,GAAAA,CAAIG,MAAM,EAAA,CAAGC,QAAQ,EAAA;oBAC7Bc,OAASlB,EAAAA,GAAAA,CAAIG,MAAM,EAAA,CAAGC,QAAQ,EAAA;oBAC9Be,OAASnB,EAAAA,GAAAA,CAAIG,MAAM,EAAA,CAAGC,QAAQ;AAChC,iBAAA,CAAA,CACCgB,SAAS,CAAC,IAAA,CAAA;aACR,MAAA;gBACLT,GAAG,CAACC,IAAI,GAAGZ,GAAAA,CACRG,MAAM,EACNkB,CAAAA,OAAO,CAAC,gBAAA,CAAA,CACRjB,QAAQ,EAAA;AACb;YAEA,OAAOO,GAAAA;SAET,EAAA,EAEFW,CAAAA,GAAAA,SAAAA,CAAAA,CAELR,QAAQ,EAAA;AAEf,CAAA;AAIA;;;;AAIC,UACKS,OAAU,GAAA,OAAO,EAAEC,GAAG,EAAEC,MAAM,EAAmC,GAAA;IACrE,MAAMC,OAAAA,GAAU,MAAMC,KAAM,CAAA;AAAEH,QAAAA;AAAI,KAAA,CAAA;AAElC,IAAA,IAAI,CAACE,OAAS,EAAA;AACZ,QAAA,MAAM,IAAIE,KAAM,CAAA,wDAAA,CAAA;AAClB;AAEA,IAAA,MAAMC,MAAS,GAAA,MAAMC,GAAIC,CAAAA,QAAQ,CAACL,OAAAA,CAAAA;AAElC,IAAA,MAAMM,GAAMC,GAAAA,IAAAA,CAAKC,KAAK,CAACL,OAAOM,QAAQ,EAAA,CAAA;AAEtCV,IAAAA,MAAAA,CAAOW,KAAK,CAAC,sBAAwBC,EAAAA,EAAAA,CAAGC,GAAG,EAAEN,GAAAA,CAAAA;IAE7C,OAAOA,GAAAA;AACT;;;;"}