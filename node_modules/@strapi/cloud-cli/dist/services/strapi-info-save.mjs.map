{"version":3,"file":"strapi-info-save.mjs","sources":["../../src/services/strapi-info-save.ts"],"sourcesContent":["import fse from 'fs-extra';\nimport path from 'path';\nimport { merge } from 'lodash';\nimport type { ProjectInfo } from './cli-api';\n\nexport const LOCAL_SAVE_FILENAME = '.strapi-cloud.json';\n\nexport type LocalSave = {\n  project?: Omit<ProjectInfo, 'id'>;\n};\n\n// Utility type for making all properties optional recursively\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\nexport type LocalPatch = {\n  project?: DeepPartial<Omit<ProjectInfo, 'id'>>;\n};\n\nconst getFilePath = (directoryPath?: string): string =>\n  path.join(directoryPath || process.cwd(), LOCAL_SAVE_FILENAME);\n\nexport async function save(data: LocalSave, { directoryPath }: { directoryPath?: string } = {}) {\n  const pathToFile = getFilePath(directoryPath);\n  // Ensure the directory exists and creates it if not\n  await fse.ensureDir(path.dirname(pathToFile));\n  await fse.writeJson(pathToFile, data, { encoding: 'utf8' });\n}\n\nexport async function retrieve({\n  directoryPath,\n}: { directoryPath?: string } = {}): Promise<LocalSave> {\n  const pathToFile = getFilePath(directoryPath);\n  const pathExists = await fse.pathExists(pathToFile);\n  if (!pathExists) {\n    return {};\n  }\n  return fse.readJSON(pathToFile, { encoding: 'utf8' });\n}\n\nexport async function patch(\n  patchData: LocalPatch,\n  { directoryPath }: { directoryPath?: string } = {}\n) {\n  const pathToFile = getFilePath(directoryPath);\n  const existingData = await retrieve({ directoryPath });\n  if (!existingData) {\n    throw new Error('No configuration data found to patch.');\n  }\n  const newData = merge(existingData, patchData);\n  await fse.writeJson(pathToFile, newData, { encoding: 'utf8' });\n}\n\nexport async function deleteConfig({ directoryPath }: { directoryPath?: string } = {}) {\n  const pathToFile = getFilePath(directoryPath);\n  const pathExists = await fse.pathExists(pathToFile);\n  if (pathExists) {\n    await fse.remove(pathToFile);\n  }\n}\n"],"names":["LOCAL_SAVE_FILENAME","getFilePath","directoryPath","path","join","process","cwd","save","data","pathToFile","fse","ensureDir","dirname","writeJson","encoding","retrieve","pathExists","readJSON","patch","patchData","existingData","Error","newData","merge","deleteConfig","remove"],"mappings":";;;;AAKO,MAAMA,sBAAsB;AAenC,MAAMC,WAAAA,GAAc,CAACC,aACnBC,GAAAA,aAAAA,CAAKC,IAAI,CAACF,aAAAA,IAAiBG,OAAQC,CAAAA,GAAG,EAAIN,EAAAA,mBAAAA,CAAAA;AAErC,eAAeO,KAAKC,IAAe,EAAE,EAAEN,aAAa,EAA8B,GAAG,EAAE,EAAA;AAC5F,IAAA,MAAMO,aAAaR,WAAYC,CAAAA,aAAAA,CAAAA;;AAE/B,IAAA,MAAMQ,YAAIC,CAAAA,SAAS,CAACR,aAAAA,CAAKS,OAAO,CAACH,UAAAA,CAAAA,CAAAA;AACjC,IAAA,MAAMC,YAAIG,CAAAA,SAAS,CAACJ,UAAAA,EAAYD,IAAM,EAAA;QAAEM,QAAU,EAAA;AAAO,KAAA,CAAA;AAC3D;AAEO,eAAeC,QAAS,CAAA,EAC7Bb,aAAa,EACc,GAAG,EAAE,EAAA;AAChC,IAAA,MAAMO,aAAaR,WAAYC,CAAAA,aAAAA,CAAAA;AAC/B,IAAA,MAAMc,UAAa,GAAA,MAAMN,YAAIM,CAAAA,UAAU,CAACP,UAAAA,CAAAA;AACxC,IAAA,IAAI,CAACO,UAAY,EAAA;AACf,QAAA,OAAO,EAAC;AACV;IACA,OAAON,YAAAA,CAAIO,QAAQ,CAACR,UAAY,EAAA;QAAEK,QAAU,EAAA;AAAO,KAAA,CAAA;AACrD;AAEO,eAAeI,MACpBC,SAAqB,EACrB,EAAEjB,aAAa,EAA8B,GAAG,EAAE,EAAA;AAElD,IAAA,MAAMO,aAAaR,WAAYC,CAAAA,aAAAA,CAAAA;IAC/B,MAAMkB,YAAAA,GAAe,MAAML,QAAS,CAAA;AAAEb,QAAAA;AAAc,KAAA,CAAA;AACpD,IAAA,IAAI,CAACkB,YAAc,EAAA;AACjB,QAAA,MAAM,IAAIC,KAAM,CAAA,uCAAA,CAAA;AAClB;IACA,MAAMC,OAAAA,GAAUC,MAAMH,YAAcD,EAAAA,SAAAA,CAAAA;AACpC,IAAA,MAAMT,YAAIG,CAAAA,SAAS,CAACJ,UAAAA,EAAYa,OAAS,EAAA;QAAER,QAAU,EAAA;AAAO,KAAA,CAAA;AAC9D;AAEO,eAAeU,YAAa,CAAA,EAAEtB,aAAa,EAA8B,GAAG,EAAE,EAAA;AACnF,IAAA,MAAMO,aAAaR,WAAYC,CAAAA,aAAAA,CAAAA;AAC/B,IAAA,MAAMc,UAAa,GAAA,MAAMN,YAAIM,CAAAA,UAAU,CAACP,UAAAA,CAAAA;AACxC,IAAA,IAAIO,UAAY,EAAA;QACd,MAAMN,YAAAA,CAAIe,MAAM,CAAChB,UAAAA,CAAAA;AACnB;AACF;;;;"}