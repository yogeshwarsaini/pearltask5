{"version":3,"file":"useContentTypeSchema.js","sources":["../../../admin/src/hooks/useContentTypeSchema.ts"],"sourcesContent":["import * as React from 'react';\n\nimport { useNotification, useAPIErrorHandler } from '@strapi/admin/strapi-admin';\n\nimport { useGetInitialDataQuery } from '../services/init';\n\nimport type { Component } from '../../../shared/contracts/components';\nimport type { ContentType } from '../../../shared/contracts/content-types';\nimport type { Schema } from '@strapi/types';\n\n/* -------------------------------------------------------------------------------------------------\n * useContentTypeSchema\n * -----------------------------------------------------------------------------------------------*/\ntype ComponentsDictionary = Record<string, Component>;\n\n/**\n * @internal\n * @description Given a model UID, return the schema and the schemas\n * of the associated components within said model's schema. A wrapper\n * implementation around the `useGetInitialDataQuery` with a unique\n * `selectFromResult` function to memoize the calculation.\n *\n * If no model is provided, the hook will return all the schemas.\n */\nconst useContentTypeSchema = (model?: string) => {\n  const { toggleNotification } = useNotification();\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\n\n  const { data, error, isLoading, isFetching } = useGetInitialDataQuery(undefined);\n\n  const { components, contentType, contentTypes } = React.useMemo(() => {\n    const contentType = data?.contentTypes.find((ct) => ct.uid === model);\n\n    const componentsByKey = data?.components.reduce<ComponentsDictionary>((acc, component) => {\n      acc[component.uid] = component;\n\n      return acc;\n    }, {});\n\n    const components = extractContentTypeComponents(contentType?.attributes, componentsByKey);\n\n    return {\n      components: Object.keys(components).length === 0 ? undefined : components,\n      contentType,\n      contentTypes: data?.contentTypes ?? [],\n    };\n  }, [model, data]);\n\n  React.useEffect(() => {\n    if (error) {\n      toggleNotification({\n        type: 'danger',\n        message: formatAPIError(error),\n      });\n    }\n  }, [toggleNotification, error, formatAPIError]);\n\n  return {\n    // This must be memoized to avoid inifiinite re-renders where the empty object is different everytime.\n    components: React.useMemo(() => components ?? {}, [components]),\n    schema: contentType,\n    schemas: contentTypes,\n    isLoading: isLoading || isFetching,\n  };\n};\n\n/* -------------------------------------------------------------------------------------------------\n * extractContentTypeComponents\n * -----------------------------------------------------------------------------------------------*/\n/**\n * @internal\n * @description Extracts the components used in a content type's attributes recursively.\n */\nconst extractContentTypeComponents = (\n  attributes: ContentType['attributes'] = {},\n  allComponents: ComponentsDictionary = {}\n): ComponentsDictionary => {\n  const getComponents = (attributes: Schema.Attribute.AnyAttribute[]) => {\n    return attributes.reduce<string[]>((acc, attribute) => {\n      /**\n       * If the attribute is a component or dynamiczone, we need to recursively\n       * extract the component UIDs from its attributes.\n       */\n      if (attribute.type === 'component') {\n        const componentAttributes = Object.values(\n          allComponents[attribute.component]?.attributes ?? {}\n        );\n\n        acc.push(attribute.component, ...getComponents(componentAttributes));\n      } else if (attribute.type === 'dynamiczone') {\n        acc.push(\n          ...attribute.components,\n          /**\n           * Dynamic zones have an array of components, so we flatMap over them\n           * performing the same search as above.\n           */\n          ...attribute.components.flatMap((componentUid) => {\n            const componentAttributes = Object.values(\n              allComponents[componentUid]?.attributes ?? {}\n            );\n\n            return getComponents(componentAttributes);\n          })\n        );\n      }\n\n      return acc;\n    }, []);\n  };\n\n  const componentUids = getComponents(Object.values(attributes));\n\n  const uniqueComponentUids = [...new Set(componentUids)];\n\n  const componentsByKey = uniqueComponentUids.reduce<ComponentsDictionary>((acc, uid) => {\n    acc[uid] = allComponents[uid];\n\n    return acc;\n  }, {});\n\n  return componentsByKey;\n};\n\nexport { useContentTypeSchema, extractContentTypeComponents };\nexport type { ComponentsDictionary };\n"],"names":["useContentTypeSchema","model","toggleNotification","useNotification","_unstableFormatAPIError","formatAPIError","useAPIErrorHandler","data","error","isLoading","isFetching","useGetInitialDataQuery","undefined","components","contentType","contentTypes","React","useMemo","find","ct","uid","componentsByKey","reduce","acc","component","extractContentTypeComponents","attributes","Object","keys","length","useEffect","type","message","schema","schemas","allComponents","getComponents","attribute","componentAttributes","values","push","flatMap","componentUid","componentUids","uniqueComponentUids","Set"],"mappings":"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"}