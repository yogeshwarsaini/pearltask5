{"version":3,"file":"Paragraph.mjs","sources":["../../../../../../../../admin/src/pages/EditView/components/FormInputs/BlocksInput/Blocks/Paragraph.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport { Typography } from '@strapi/design-system';\nimport { Paragraph } from '@strapi/icons';\nimport { type Text, Editor, Transforms } from 'slate';\n\nimport { type BlocksStore } from '../BlocksEditor';\nimport { baseHandleConvert } from '../utils/conversions';\nimport { type Block } from '../utils/types';\n\nconst paragraphBlocks: Pick<BlocksStore, 'paragraph'> = {\n  paragraph: {\n    renderElement: (props) => (\n      <Typography tag=\"p\" variant=\"omega\" {...props.attributes}>\n        {props.children}\n      </Typography>\n    ),\n    icon: Paragraph,\n    label: {\n      id: 'components.Blocks.blocks.text',\n      defaultMessage: 'Text',\n    },\n    matchNode: (node) => node.type === 'paragraph',\n    isInBlocksSelector: true,\n    dragHandleTopMargin: '-2px',\n    handleConvert(editor) {\n      baseHandleConvert<Block<'paragraph'>>(editor, { type: 'paragraph' });\n    },\n    handleEnterKey(editor) {\n      if (!editor.selection) {\n        return;\n      }\n\n      // We need to keep track of the initial position of the cursor\n      const anchorPathInitialPosition = editor.selection.anchor.path;\n      /**\n       * Split the nodes where the cursor is. This will create a new paragraph with the content\n       * after the cursor, while retaining all the children, modifiers etc.\n       */\n      Transforms.splitNodes(editor, {\n        // Makes sure we always create a new node,\n        // even if there's nothing to the right of the cursor in the node.\n        always: true,\n      });\n\n      // Check if the created node is empty (if there was no text after the cursor in the node)\n      // This lets us know if we need to carry over the modifiers from the previous node\n      const parentBlockEntry = Editor.above(editor, {\n        match: (node) => !Editor.isEditor(node) && node.type !== 'text',\n      });\n      if (!parentBlockEntry) {\n        return;\n      }\n      const [, parentBlockPath] = parentBlockEntry;\n      const isNodeEnd = Editor.isEnd(editor, editor.selection.anchor, parentBlockPath);\n\n      /**\n       * Delete and recreate the node that was created at the right of the cursor.\n       * This is to avoid node pollution\n       * (e.g. keeping the level attribute when converting a heading to a paragraph).\n       * Select the parent of the selection because we want the full block, not the leaf.\n       * And copy its children to make sure we keep the modifiers.\n       */\n      const [fragmentedNode] = Editor.parent(editor, editor.selection.anchor.path);\n      Transforms.removeNodes(editor);\n\n      // Check if after the current position there is another node\n      const hasNextNode = editor.children.length - anchorPathInitialPosition[0] > 1;\n\n      // Insert the new node at the right position.\n      // The next line after the editor selection if present or otherwise at the end of the editor.\n      Transforms.insertNodes(\n        editor,\n        {\n          type: 'paragraph',\n          // Don't carry over the modifiers from the previous node if there was no text after the cursor\n          children: (isNodeEnd ? [{ type: 'text', text: '' }] : fragmentedNode.children) as Text[],\n        },\n        {\n          at: hasNextNode ? [anchorPathInitialPosition[0] + 1] : [editor.children.length],\n        }\n      );\n\n      /**\n       * The new selection will by default be at the end of the created node.\n       * Instead we manually move it to the start of the created node.\n       * Make sure to we go to the start of the node and not the start of the leaf.\n       */\n      Transforms.select(editor, editor.start([anchorPathInitialPosition[0] + 1]));\n    },\n  },\n};\n\nexport { paragraphBlocks };\n"],"names":["paragraphBlocks","paragraph","renderElement","props","_jsx","Typography","tag","variant","attributes","children","icon","Paragraph","label","id","defaultMessage","matchNode","node","type","isInBlocksSelector","dragHandleTopMargin","handleConvert","editor","baseHandleConvert","handleEnterKey","selection","anchorPathInitialPosition","anchor","path","Transforms","splitNodes","always","parentBlockEntry","Editor","above","match","isEditor","parentBlockPath","isNodeEnd","isEnd","fragmentedNode","parent","removeNodes","hasNextNode","length","insertNodes","text","at","select","start"],"mappings":";;;;;;;AAUA,MAAMA,eAAkD,GAAA;IACtDC,SAAW,EAAA;QACTC,aAAe,EAAA,CAACC,sBACdC,GAACC,CAAAA,UAAAA,EAAAA;gBAAWC,GAAI,EAAA,GAAA;gBAAIC,OAAQ,EAAA,OAAA;AAAS,gBAAA,GAAGJ,MAAMK,UAAU;AACrDL,gBAAAA,QAAAA,EAAAA,KAAAA,CAAMM;;QAGXC,IAAMC,EAAAA,SAAAA;QACNC,KAAO,EAAA;YACLC,EAAI,EAAA,+BAAA;YACJC,cAAgB,EAAA;AAClB,SAAA;AACAC,QAAAA,SAAAA,EAAW,CAACC,IAAAA,GAASA,IAAKC,CAAAA,IAAI,KAAK,WAAA;QACnCC,kBAAoB,EAAA,IAAA;QACpBC,mBAAqB,EAAA,MAAA;AACrBC,QAAAA,aAAAA,CAAAA,CAAcC,MAAM,EAAA;AAClBC,YAAAA,iBAAAA,CAAsCD,MAAQ,EAAA;gBAAEJ,IAAM,EAAA;AAAY,aAAA,CAAA;AACpE,SAAA;AACAM,QAAAA,cAAAA,CAAAA,CAAeF,MAAM,EAAA;YACnB,IAAI,CAACA,MAAOG,CAAAA,SAAS,EAAE;AACrB,gBAAA;AACF;;AAGA,YAAA,MAAMC,4BAA4BJ,MAAOG,CAAAA,SAAS,CAACE,MAAM,CAACC,IAAI;AAC9D;;;UAIAC,UAAAA,CAAWC,UAAU,CAACR,MAAQ,EAAA;;;gBAG5BS,MAAQ,EAAA;AACV,aAAA,CAAA;;;AAIA,YAAA,MAAMC,gBAAmBC,GAAAA,MAAAA,CAAOC,KAAK,CAACZ,MAAQ,EAAA;gBAC5Ca,KAAO,EAAA,CAAClB,OAAS,CAACgB,MAAAA,CAAOG,QAAQ,CAACnB,IAAAA,CAAAA,IAASA,IAAKC,CAAAA,IAAI,KAAK;AAC3D,aAAA,CAAA;AACA,YAAA,IAAI,CAACc,gBAAkB,EAAA;AACrB,gBAAA;AACF;YACA,MAAM,GAAGK,gBAAgB,GAAGL,gBAAAA;YAC5B,MAAMM,SAAAA,GAAYL,OAAOM,KAAK,CAACjB,QAAQA,MAAOG,CAAAA,SAAS,CAACE,MAAM,EAAEU,eAAAA,CAAAA;AAEhE;;;;;;AAMC,UACD,MAAM,CAACG,cAAe,CAAA,GAAGP,MAAOQ,CAAAA,MAAM,CAACnB,MAAAA,EAAQA,MAAOG,CAAAA,SAAS,CAACE,MAAM,CAACC,IAAI,CAAA;AAC3EC,YAAAA,UAAAA,CAAWa,WAAW,CAACpB,MAAAA,CAAAA;;YAGvB,MAAMqB,WAAAA,GAAcrB,OAAOZ,QAAQ,CAACkC,MAAM,GAAGlB,yBAAyB,CAAC,CAAA,CAAE,GAAG,CAAA;;;YAI5EG,UAAWgB,CAAAA,WAAW,CACpBvB,MACA,EAAA;gBACEJ,IAAM,EAAA,WAAA;;AAENR,gBAAAA,QAAAA,EAAW4B,SAAY,GAAA;AAAC,oBAAA;wBAAEpB,IAAM,EAAA,MAAA;wBAAQ4B,IAAM,EAAA;AAAG;AAAE,iBAAA,GAAGN,eAAe9B;aAEvE,EAAA;AACEqC,gBAAAA,EAAAA,EAAIJ,WAAc,GAAA;oBAACjB,yBAAyB,CAAC,EAAE,GAAG;iBAAE,GAAG;oBAACJ,MAAOZ,CAAAA,QAAQ,CAACkC;AAAO;AACjF,aAAA,CAAA;AAGF;;;;AAIC,UACDf,WAAWmB,MAAM,CAAC1B,MAAQA,EAAAA,MAAAA,CAAO2B,KAAK,CAAC;gBAACvB,yBAAyB,CAAC,EAAE,GAAG;AAAE,aAAA,CAAA,CAAA;AAC3E;AACF;AACF;;;;"}