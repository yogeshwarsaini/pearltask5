{"version":3,"file":"List.mjs","sources":["../../../../../../../../admin/src/pages/EditView/components/FormInputs/BlocksInput/Blocks/List.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport { Typography } from '@strapi/design-system';\nimport { BulletList, NumberList } from '@strapi/icons';\nimport { type Text, Editor, Node, Transforms, Path } from 'slate';\nimport { type RenderElementProps, ReactEditor } from 'slate-react';\nimport { styled, type CSSProperties, css } from 'styled-components';\n\nimport { type BlocksStore } from '../BlocksEditor';\nimport { baseHandleConvert } from '../utils/conversions';\nimport { isListNode, type Block } from '../utils/types';\n\nconst listStyle = css`\n  display: flex;\n  flex-direction: column;\n  gap: ${({ theme }) => theme.spaces[2]};\n  margin-inline-start: ${({ theme }) => theme.spaces[0]};\n  margin-inline-end: ${({ theme }) => theme.spaces[0]};\n  padding-inline-start: ${({ theme }) => theme.spaces[2]};\n\n  ol,\n  ul {\n    margin-block-start: ${({ theme }) => theme.spaces[0]};\n    margin-block-end: ${({ theme }) => theme.spaces[0]};\n  }\n\n  li {\n    margin-inline-start: ${({ theme }) => theme.spaces[3]};\n  }\n`;\n\nconst Orderedlist = styled.ol<{ $listStyleType: CSSProperties['listStyleType'] }>`\n  list-style-type: ${(props) => props.$listStyleType};\n  ${listStyle}\n`;\n\nconst Unorderedlist = styled.ul<{ $listStyleType: CSSProperties['listStyleType'] }>`\n  list-style-type: ${(props) => props.$listStyleType};\n  ${listStyle}\n`;\n\nconst orderedStyles = ['decimal', 'lower-alpha', 'upper-roman'];\nconst unorderedStyles = ['disc', 'circle', 'square'];\n\nconst List = ({ attributes, children, element }: RenderElementProps) => {\n  if (!isListNode(element)) {\n    return null;\n  }\n\n  // Decide the subsequent style by referencing the given styles according to the format,\n  // allowing for infinite nested lists\n  const listStyles = element.format === 'ordered' ? orderedStyles : unorderedStyles;\n  const nextIndex = (element.indentLevel || 0) % listStyles!.length;\n  const listStyleType = listStyles![nextIndex];\n\n  if (element.format === 'ordered') {\n    return (\n      <Orderedlist $listStyleType={listStyleType} {...attributes}>\n        {children}\n      </Orderedlist>\n    );\n  }\n\n  return (\n    <Unorderedlist $listStyleType={listStyleType} {...attributes}>\n      {children}\n    </Unorderedlist>\n  );\n};\n\nconst replaceListWithEmptyBlock = (editor: Editor, currentListPath: Path) => {\n  // Delete the empty list\n  Transforms.removeNodes(editor, { at: currentListPath });\n\n  if (currentListPath[0] === 0) {\n    // If the list was the only (or first) block element then insert empty paragraph as editor needs default value\n    Transforms.insertNodes(\n      editor,\n      {\n        type: 'paragraph',\n        children: [{ type: 'text', text: '' }],\n      },\n      { at: currentListPath }\n    );\n    Transforms.select(editor, currentListPath);\n  }\n};\n\nconst isText = (node: unknown): node is Text => {\n  return Node.isNode(node) && !Editor.isEditor(node) && node.type === 'text';\n};\n\n/**\n * Common handler for the backspace event on ordered and unordered lists\n */\nconst handleBackspaceKeyOnList = (editor: Editor, event: React.KeyboardEvent<HTMLElement>) => {\n  if (!editor.selection) return;\n\n  const [currentListItem, currentListItemPath] = Editor.parent(editor, editor.selection.anchor);\n  const [currentList, currentListPath] = Editor.parent(editor, currentListItemPath);\n  const isListEmpty =\n    currentList.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isListItemEmpty =\n    currentListItem.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isFocusAtTheBeginningOfAChild =\n    editor.selection.focus.offset === 0 && editor.selection.focus.path.at(-2) === 0;\n\n  if (isListEmpty) {\n    const parentListEntry = Editor.above(editor, {\n      at: currentListPath,\n      match: (node) => !Editor.isEditor(node) && node.type === 'list',\n    });\n    if (!parentListEntry) {\n      event.preventDefault();\n      replaceListWithEmptyBlock(editor, currentListPath);\n    }\n  } else if (isFocusAtTheBeginningOfAChild) {\n    // If the focus is at the beginning of a child node we need to replace it with a paragraph\n    Transforms.liftNodes(editor, {\n      match: (node) => !Editor.isEditor(node) && node.type === 'list-item',\n    });\n    Transforms.setNodes(editor, { type: 'paragraph' });\n  } else if (isListItemEmpty) {\n    const previousEntry = Editor.previous(editor, {\n      at: currentListItemPath,\n    });\n    const nextEntry = Editor.next(editor, {\n      at: currentListItemPath,\n    });\n\n    if (previousEntry && nextEntry) {\n      // If previous and next nodes are lists or list-items, delete empty list item\n      event.preventDefault();\n      Transforms.removeNodes(editor, {\n        at: currentListItemPath,\n      });\n\n      // If previous and next nodes are lists with same format and indent Levels, then merge the nodes\n      const [previousList] = previousEntry;\n      const [nextList] = nextEntry;\n      if (\n        !Editor.isEditor(previousList) &&\n        !isText(previousList) &&\n        isListNode(previousList) &&\n        !Editor.isEditor(nextList) &&\n        !isText(nextList) &&\n        isListNode(nextList)\n      ) {\n        if (\n          previousList.type === 'list' &&\n          nextList.type === 'list' &&\n          previousList.format === nextList.format &&\n          previousList.indentLevel === nextList.indentLevel\n        ) {\n          Transforms.mergeNodes(editor, {\n            at: currentListItemPath,\n          });\n        }\n      }\n    }\n  }\n};\n\n/**\n * Common handler for the enter key on ordered and unordered lists\n */\nconst handleEnterKeyOnList = (editor: Editor) => {\n  const currentListItemEntry = Editor.above(editor, {\n    match: (node) => !Editor.isEditor(node) && node.type === 'list-item',\n  });\n\n  if (!currentListItemEntry || !editor.selection) {\n    return;\n  }\n\n  const [currentListItem, currentListItemPath] = currentListItemEntry;\n  const [currentList, currentListPath] = Editor.parent(editor, currentListItemPath);\n  const isListEmpty =\n    currentList.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isListItemEmpty =\n    currentListItem.children.length === 1 &&\n    isText(currentListItem.children[0]) &&\n    currentListItem.children[0].text === '';\n  const isFocusAtTheBeginningOfAChild =\n    editor.selection.focus.offset === 0 && editor.selection.focus.path.at(-1) === 0;\n\n  if (isListEmpty) {\n    replaceListWithEmptyBlock(editor, currentListPath);\n  } else if (isFocusAtTheBeginningOfAChild && !isListItemEmpty) {\n    // If the focus is at the beginning of a child node, shift below the list item and create a new list-item\n    const currentNode = Editor.above(editor, { at: editor.selection.anchor });\n    Transforms.insertNodes(editor, { type: 'list-item', children: [{ type: 'text', text: '' }] });\n    if (currentNode) {\n      const path = currentNode[1];\n      const updatedPath = [...path.slice(0, -1), path[path.length - 1] + 1];\n      Transforms.select(editor, {\n        anchor: { path: updatedPath.concat(0), offset: 0 },\n        focus: { path: updatedPath.concat(0), offset: 0 },\n      });\n    }\n  } else if (isListItemEmpty) {\n    // Check if there is a list above the current list and shift list-item under it\n    if (\n      !Editor.isEditor(currentList) &&\n      isListNode(currentList) &&\n      currentList?.indentLevel &&\n      currentList.indentLevel > 0\n    ) {\n      const previousIndentLevel = currentList.indentLevel - 1;\n\n      const parentListNodeEntry = Editor.above(editor, {\n        match: (node) =>\n          !Editor.isEditor(node) &&\n          node.type === 'list' &&\n          (node.indentLevel || 0) === previousIndentLevel,\n      });\n\n      if (parentListNodeEntry) {\n        // Get the parent list path and add 1 to it to exit from the current list\n        const modifiedPath = currentListItemPath.slice(0, -1);\n        if (modifiedPath.length > 0) {\n          modifiedPath[modifiedPath.length - 1] += 1;\n        }\n\n        // Shift list-item under parent list\n        Transforms.moveNodes(editor, {\n          at: currentListItemPath,\n          to: modifiedPath,\n        });\n        return;\n      }\n    }\n\n    // Otherwise delete the empty list item and create a new paragraph below the parent list\n    Transforms.removeNodes(editor, { at: currentListItemPath });\n\n    const createdParagraphPath = Path.next(currentListPath);\n    Transforms.insertNodes(\n      editor,\n      {\n        type: 'paragraph',\n        children: [{ type: 'text', text: '' }],\n      },\n      { at: createdParagraphPath }\n    );\n\n    // Move the selection to the newly created paragraph\n    Transforms.select(editor, createdParagraphPath);\n  } else {\n    // Check if the cursor is at the end of the list item\n    const isNodeEnd = Editor.isEnd(editor, editor.selection.anchor, currentListItemPath);\n\n    if (isNodeEnd) {\n      // If there was nothing after the cursor, create a fresh new list item,\n      // in order to avoid carrying over the modifiers from the previous list item\n      Transforms.insertNodes(editor, { type: 'list-item', children: [{ type: 'text', text: '' }] });\n    } else {\n      // If there is something after the cursor, split the current list item,\n      // so that we keep the content and the modifiers\n      Transforms.splitNodes(editor);\n    }\n  }\n};\n\n/**\n * Common handler for converting a node to a list\n */\nconst handleConvertToList = (editor: Editor, format: Block<'list'>['format']) => {\n  const convertedPath = baseHandleConvert<Block<'list-item'>>(editor, { type: 'list-item' });\n\n  if (!convertedPath) return;\n\n  Transforms.wrapNodes(editor, { type: 'list', format, children: [] }, { at: convertedPath });\n};\n\n/**\n * Common handler for the tab key on ordered and unordered lists\n */\nconst handleTabOnList = (editor: Editor) => {\n  const currentListItemEntry = Editor.above(editor, {\n    match: (node) => !Editor.isEditor(node) && node.type === 'list-item',\n  });\n\n  if (!currentListItemEntry || !editor.selection) {\n    return;\n  }\n\n  const [currentListItem, currentListItemPath] = currentListItemEntry;\n  const [currentList] = Editor.parent(editor, currentListItemPath);\n\n  // Skip tabbing if list-item is the first item in the list\n  if (currentListItem === currentList.children[0]) return;\n\n  const currentListItemIndex = currentList.children.findIndex((item) => item === currentListItem);\n  const previousNode = currentList.children[currentListItemIndex - 1];\n\n  // If previous node is a list block then move the list-item under it\n  if (previousNode.type === 'list') {\n    const nodePath = ReactEditor.findPath(editor, previousNode);\n    const insertAtPath = previousNode.children.length;\n\n    Transforms.moveNodes(editor, {\n      at: currentListItemPath,\n      to: nodePath.concat(insertAtPath),\n    });\n    return;\n  }\n\n  if (!Editor.isEditor(currentList) && isListNode(currentList)) {\n    // Wrap list-item with list block on tab\n    Transforms.wrapNodes(editor, {\n      type: 'list',\n      format: currentList.format,\n      indentLevel: (currentList.indentLevel || 0) + 1,\n      children: [],\n    });\n  }\n};\n\nconst listBlocks: Pick<BlocksStore, 'list-ordered' | 'list-unordered' | 'list-item'> = {\n  'list-ordered': {\n    renderElement: (props) => <List {...props} />,\n    label: {\n      id: 'components.Blocks.blocks.orderedList',\n      defaultMessage: 'Numbered list',\n    },\n    icon: NumberList,\n    matchNode: (node) => node.type === 'list' && node.format === 'ordered',\n    isInBlocksSelector: true,\n    handleConvert: (editor) => handleConvertToList(editor, 'ordered'),\n    handleEnterKey: handleEnterKeyOnList,\n    handleBackspaceKey: handleBackspaceKeyOnList,\n    handleTab: handleTabOnList,\n    snippets: ['1.'],\n  },\n  'list-unordered': {\n    renderElement: (props) => <List {...props} />,\n    label: {\n      id: 'components.Blocks.blocks.unorderedList',\n      defaultMessage: 'Bulleted list',\n    },\n    icon: BulletList,\n    matchNode: (node) => node.type === 'list' && node.format === 'unordered',\n    isInBlocksSelector: true,\n    handleConvert: (editor) => handleConvertToList(editor, 'unordered'),\n    handleEnterKey: handleEnterKeyOnList,\n    handleBackspaceKey: handleBackspaceKeyOnList,\n    handleTab: handleTabOnList,\n    snippets: ['-', '*', '+'],\n  },\n  'list-item': {\n    renderElement: (props) => (\n      <Typography tag=\"li\" {...props.attributes}>\n        {props.children}\n      </Typography>\n    ),\n    // No handleConvert, list items are created when converting to the parent list\n    matchNode: (node) => node.type === 'list-item',\n    isInBlocksSelector: false,\n    dragHandleTopMargin: '-2px',\n  },\n};\n\nexport { listBlocks };\n"],"names":["listStyle","css","theme","spaces","Orderedlist","styled","ol","props","$listStyleType","Unorderedlist","ul","orderedStyles","unorderedStyles","List","attributes","children","element","isListNode","listStyles","format","nextIndex","indentLevel","length","listStyleType","_jsx","replaceListWithEmptyBlock","editor","currentListPath","Transforms","removeNodes","at","insertNodes","type","text","select","isText","node","Node","isNode","Editor","isEditor","handleBackspaceKeyOnList","event","selection","currentListItem","currentListItemPath","parent","anchor","currentList","isListEmpty","isListItemEmpty","isFocusAtTheBeginningOfAChild","focus","offset","path","parentListEntry","above","match","preventDefault","liftNodes","setNodes","previousEntry","previous","nextEntry","next","previousList","nextList","mergeNodes","handleEnterKeyOnList","currentListItemEntry","currentNode","updatedPath","slice","concat","previousIndentLevel","parentListNodeEntry","modifiedPath","moveNodes","to","createdParagraphPath","Path","isNodeEnd","isEnd","splitNodes","handleConvertToList","convertedPath","baseHandleConvert","wrapNodes","handleTabOnList","currentListItemIndex","findIndex","item","previousNode","nodePath","ReactEditor","findPath","insertAtPath","listBlocks","renderElement","label","id","defaultMessage","icon","NumberList","matchNode","isInBlocksSelector","handleConvert","handleEnterKey","handleBackspaceKey","handleTab","snippets","BulletList","Typography","tag","dragHandleTopMargin"],"mappings":"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"}