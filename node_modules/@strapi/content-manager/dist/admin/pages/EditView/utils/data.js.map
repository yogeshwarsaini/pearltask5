{"version":3,"file":"data.js","sources":["../../../../../admin/src/pages/EditView/utils/data.ts"],"sourcesContent":["import { createRulesEngine } from '@strapi/admin/strapi-admin';\nimport { generateNKeysBetween } from 'fractional-indexing';\nimport pipe from 'lodash/fp/pipe';\n\nimport { DOCUMENT_META_FIELDS } from '../../../constants/attributes';\n\nimport type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\nimport type { Schema, UID } from '@strapi/types';\n\n/* -------------------------------------------------------------------------------------------------\n * traverseData\n * -----------------------------------------------------------------------------------------------*/\n\n// Make only attributes required since it's the only one Content History has\ntype PartialSchema = Partial<Schema.Schema> & Pick<Schema.Schema, 'attributes'>;\n\ntype Predicate = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  attribute: TAttribute,\n  value: Schema.Attribute.Value<TAttribute>\n) => boolean;\ntype Transform = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  value: any,\n  attribute: TAttribute\n) => any;\ntype AnyData = Omit<Document, 'id'>;\n\nconst BLOCK_LIST_ATTRIBUTE_KEYS = ['__component', '__temp_key__'];\n\n/**\n * @internal This function is used to traverse the data and transform the values.\n * Given a predicate function, it will transform the value (using the given transform function)\n * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,\n * it will recursively traverse those data structures as well.\n *\n * It is possible to break the ContentManager by using this function incorrectly, for example,\n * if you transform a number into a string but the attribute type is a number, the ContentManager\n * will not be able to save the data and the Form will likely crash because the component it's\n * passing the data too won't succesfully be able to handle the value.\n */\nconst traverseData =\n  (predicate: Predicate, transform: Transform) =>\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (data: AnyData = {}) => {\n    const traverse = (datum: AnyData, attributes: Schema.Schema['attributes']) => {\n      return Object.entries(datum).reduce<AnyData>((acc, [key, value]) => {\n        const attribute = attributes[key];\n\n        /**\n         * If the attribute is a block list attribute, we don't want to transform it.\n         * We also don't want to transform null or undefined values.\n         */\n        if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {\n          acc[key] = value;\n          return acc;\n        }\n\n        if (attribute.type === 'component') {\n          if (attribute.repeatable) {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n            acc[key] = componentValue.map((componentData) =>\n              traverse(componentData, components[attribute.component]?.attributes ?? {})\n            );\n          } else {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, false>>;\n\n            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});\n          }\n        } else if (attribute.type === 'dynamiczone') {\n          const dynamicZoneValue = (\n            predicate(attribute, value) ? transform(value, attribute) : value\n          ) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n          acc[key] = dynamicZoneValue.map((componentData) =>\n            traverse(componentData, components[componentData.__component]?.attributes ?? {})\n          );\n        } else if (predicate(attribute, value)) {\n          acc[key] = transform(value, attribute);\n        } else {\n          acc[key] = value;\n        }\n\n        return acc;\n      }, {});\n    };\n\n    return traverse(data, schema.attributes);\n  };\n\n/* -------------------------------------------------------------------------------------------------\n * removeProhibitedFields\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal Removes all the fields that are not allowed.\n */\nconst removeProhibitedFields = (prohibitedFields: Schema.Attribute.Kind[]) =>\n  traverseData(\n    (attribute) => prohibitedFields.includes(attribute.type),\n    () => ''\n  );\n\n/* -------------------------------------------------------------------------------------------------\n * prepareRelations\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Sets all relation values to an empty array.\n */\nconst prepareRelations = traverseData(\n  (attribute) => attribute.type === 'relation',\n  () => ({\n    connect: [],\n    disconnect: [],\n  })\n);\n\n/* -------------------------------------------------------------------------------------------------\n * prepareTempKeys\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us\n * a stable identifier regardless of its ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = traverseData(\n  (attribute) =>\n    (attribute.type === 'component' && attribute.repeatable) || attribute.type === 'dynamiczone',\n  (data) => {\n    if (Array.isArray(data) && data.length > 0) {\n      const keys = generateNKeysBetween(undefined, undefined, data.length);\n\n      return data.map((datum, index) => ({\n        ...datum,\n        __temp_key__: keys[index],\n      }));\n    }\n\n    return data;\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * removeFieldsThatDontExistOnSchema\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),\n * as such we don't need to traverse the components to remove them.\n */\nconst removeFieldsThatDontExistOnSchema = (schema: PartialSchema) => (data: AnyData) => {\n  const schemaKeys = Object.keys(schema.attributes);\n  const dataKeys = Object.keys(data);\n\n  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));\n\n  const revisedData = [...keysToRemove, ...DOCUMENT_META_FIELDS].reduce((acc, key) => {\n    delete acc[key];\n\n    return acc;\n  }, structuredClone(data));\n\n  return revisedData;\n};\n\n/**\n * @internal\n * @description We need to remove null fields from the data-structure because it will pass it\n * to the specific inputs breaking them as most would prefer empty strings or `undefined` if\n * they're controlled / uncontrolled.\n */\nconst removeNullValues = (data: AnyData) => {\n  return Object.entries(data).reduce<AnyData>((acc, [key, value]) => {\n    if (value === null) {\n      return acc;\n    }\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n};\n\n/* -------------------------------------------------------------------------------------------------\n * transformDocuments\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Takes a document data structure (this could be from the API or a default form structure)\n * and applies consistent data transformations to it. This is also used when we add new components to the\n * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.\n */\nconst transformDocument =\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (document: AnyData) => {\n    const transformations = pipe(\n      removeFieldsThatDontExistOnSchema(schema),\n      removeProhibitedFields(['password'])(schema, components),\n      removeNullValues,\n      prepareRelations(schema, components),\n      prepareTempKeys(schema, components)\n    );\n\n    return transformations(document);\n  };\n\ntype HandleOptions = {\n  schema?: Schema.ContentType | Schema.Component;\n  initialValues?: AnyData;\n  components?: Record<string, Schema.Component>;\n};\n\ntype RemovedFieldPath = string;\n\n/**\n * Removes values from the data object if their corresponding attribute has a\n * visibility condition that evaluates to false.\n *\n * @param {object} schema - The content type schema (with attributes).\n * @param {object} data - The data object to filter based on visibility.\n * @returns {object} A new data object with only visible fields retained.\n */\nconst handleInvisibleAttributes = (\n  data: AnyData,\n  { schema, initialValues = {}, components = {} }: HandleOptions,\n  path: string[] = [],\n  removedAttributes: RemovedFieldPath[] = []\n): {\n  data: AnyData;\n  removedAttributes: RemovedFieldPath[];\n} => {\n  if (!schema?.attributes) return { data, removedAttributes };\n\n  const rulesEngine = createRulesEngine();\n  const result: AnyData = {};\n\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\n    const fullPath = [...path, attrName].join('.');\n    const condition = attrDef?.conditions?.visible;\n    const isVisible = condition ? rulesEngine.evaluate(condition, { ...data, ...result }) : true;\n\n    if (!isVisible) {\n      removedAttributes.push(fullPath);\n      continue;\n    }\n\n    const userProvided = Object.prototype.hasOwnProperty.call(data, attrName);\n    const currentValue = userProvided ? data[attrName] : undefined;\n    const initialValue = initialValues?.[attrName];\n\n    // ðŸ”¹ Handle components\n    if (attrDef.type === 'component') {\n      const compSchema = components[attrDef.component];\n      const value = currentValue ?? initialValue;\n\n      if (!value) {\n        result[attrName] = attrDef.repeatable ? [] : null;\n        continue;\n      }\n\n      if (attrDef.repeatable && Array.isArray(value)) {\n        result[attrName] = value.map(\n          (item, index) =>\n            handleInvisibleAttributes(\n              item,\n              {\n                schema: compSchema,\n                initialValues: initialValue?.[index] ?? {},\n                components,\n              },\n              [...path, `${attrName}[${index}]`],\n              removedAttributes\n            ).data\n        );\n      } else {\n        result[attrName] = handleInvisibleAttributes(\n          value,\n          {\n            schema: compSchema,\n            initialValues: initialValue ?? {},\n            components,\n          },\n          [...path, attrName],\n          removedAttributes\n        ).data;\n      }\n\n      continue;\n    }\n\n    // ðŸ”¸ Handle dynamic zones\n    if (attrDef.type === 'dynamiczone') {\n      if (!Array.isArray(currentValue)) {\n        result[attrName] = [];\n        continue;\n      }\n\n      result[attrName] = currentValue.map((dzItem, index) => {\n        const compUID = dzItem?.__component;\n        const compSchema = components[compUID];\n\n        const cleaned = handleInvisibleAttributes(\n          dzItem,\n          {\n            schema: compSchema,\n            initialValues: initialValue?.[index] ?? {},\n            components,\n          },\n          [...path, `${attrName}[${index}]`],\n          removedAttributes\n        ).data;\n\n        return {\n          __component: compUID,\n          ...cleaned,\n        };\n      });\n\n      continue;\n    }\n\n    // ðŸŸ¡ Handle scalar/primitive\n    if (currentValue !== undefined) {\n      result[attrName] = currentValue;\n    } else if (initialValue !== undefined) {\n      result[attrName] = initialValue;\n    } else {\n      if (attrName === 'id' || attrName === 'documentId') {\n        // If the attribute is 'id', we don't want to set it to null, as it should not be removed.\n        continue;\n      }\n      result[attrName] = null;\n    }\n  }\n\n  return {\n    data: result,\n    removedAttributes,\n  };\n};\n\nexport {\n  removeProhibitedFields,\n  prepareRelations,\n  prepareTempKeys,\n  removeFieldsThatDontExistOnSchema,\n  transformDocument,\n  handleInvisibleAttributes,\n};\nexport type { AnyData };\n"],"names":["BLOCK_LIST_ATTRIBUTE_KEYS","traverseData","predicate","transform","schema","components","data","traverse","datum","attributes","Object","entries","reduce","acc","key","value","attribute","includes","undefined","type","repeatable","componentValue","map","componentData","component","dynamicZoneValue","__component","removeProhibitedFields","prohibitedFields","prepareRelations","connect","disconnect","prepareTempKeys","Array","isArray","length","keys","generateNKeysBetween","index","__temp_key__","removeFieldsThatDontExistOnSchema","schemaKeys","dataKeys","keysToRemove","filter","revisedData","DOCUMENT_META_FIELDS","structuredClone","removeNullValues","transformDocument","document","transformations","pipe","handleInvisibleAttributes","initialValues","path","removedAttributes","rulesEngine","createRulesEngine","result","attrName","attrDef","fullPath","join","condition","conditions","visible","isVisible","evaluate","push","userProvided","prototype","hasOwnProperty","call","currentValue","initialValue","compSchema","item","dzItem","compUID","cleaned"],"mappings":";;;;;;;AA0BA,MAAMA,yBAA4B,GAAA;AAAC,IAAA,aAAA;AAAe,IAAA;AAAe,CAAA;AAEjE;;;;;;;;;;AAUC,IACD,MAAMC,YAAAA,GACJ,CAACC,SAAAA,EAAsBC,YACvB,CAACC,MAAAA,EAAuBC,UAAmC,GAAA,EAAE,GAC7D,CAACC,IAAAA,GAAgB,EAAE,GAAA;YACjB,MAAMC,QAAAA,GAAW,CAACC,KAAgBC,EAAAA,UAAAA,GAAAA;gBAChC,OAAOC,MAAAA,CAAOC,OAAO,CAACH,KAAOI,CAAAA,CAAAA,MAAM,CAAU,CAACC,GAAAA,EAAK,CAACC,GAAAA,EAAKC,KAAM,CAAA,GAAA;oBAC7D,MAAMC,SAAAA,GAAYP,UAAU,CAACK,GAAI,CAAA;AAEjC;;;YAIA,IAAId,0BAA0BiB,QAAQ,CAACH,QAAQC,KAAU,KAAA,IAAA,IAAQA,UAAUG,SAAW,EAAA;wBACpFL,GAAG,CAACC,IAAI,GAAGC,KAAAA;wBACX,OAAOF,GAAAA;AACT;oBAEA,IAAIG,SAAAA,CAAUG,IAAI,KAAK,WAAa,EAAA;wBAClC,IAAIH,SAAAA,CAAUI,UAAU,EAAE;AACxB,4BAAA,MAAMC,iBACJnB,SAAUc,CAAAA,SAAAA,EAAWD,KAASZ,CAAAA,GAAAA,SAAAA,CAAUY,OAAOC,SAAaD,CAAAA,GAAAA,KAAAA;AAE9DF,4BAAAA,GAAG,CAACC,GAAI,CAAA,GAAGO,cAAeC,CAAAA,GAAG,CAAC,CAACC,aAAAA,GAC7BhB,QAASgB,CAAAA,aAAAA,EAAelB,UAAU,CAACW,SAAAA,CAAUQ,SAAS,CAAC,EAAEf,cAAc,EAAC,CAAA,CAAA;yBAErE,MAAA;AACL,4BAAA,MAAMY,iBACJnB,SAAUc,CAAAA,SAAAA,EAAWD,KAASZ,CAAAA,GAAAA,SAAAA,CAAUY,OAAOC,SAAaD,CAAAA,GAAAA,KAAAA;AAG9DF,4BAAAA,GAAG,CAACC,GAAAA,CAAI,GAAGP,QAAAA,CAASc,cAAgBhB,EAAAA,UAAU,CAACW,SAAAA,CAAUQ,SAAS,CAAC,EAAEf,UAAAA,IAAc,EAAC,CAAA;AACtF;AACF,qBAAA,MAAO,IAAIO,SAAAA,CAAUG,IAAI,KAAK,aAAe,EAAA;AAC3C,wBAAA,MAAMM,mBACJvB,SAAUc,CAAAA,SAAAA,EAAWD,KAASZ,CAAAA,GAAAA,SAAAA,CAAUY,OAAOC,SAAaD,CAAAA,GAAAA,KAAAA;AAG9DF,wBAAAA,GAAG,CAACC,GAAI,CAAA,GAAGW,gBAAiBH,CAAAA,GAAG,CAAC,CAACC,aAAAA,GAC/BhB,QAASgB,CAAAA,aAAAA,EAAelB,UAAU,CAACkB,aAAAA,CAAcG,WAAW,CAAC,EAAEjB,cAAc,EAAC,CAAA,CAAA;qBAE3E,MAAA,IAAIP,SAAUc,CAAAA,SAAAA,EAAWD,KAAQ,CAAA,EAAA;AACtCF,wBAAAA,GAAG,CAACC,GAAAA,CAAI,GAAGX,SAAAA,CAAUY,KAAOC,EAAAA,SAAAA,CAAAA;qBACvB,MAAA;wBACLH,GAAG,CAACC,IAAI,GAAGC,KAAAA;AACb;oBAEA,OAAOF,GAAAA;AACT,iBAAA,EAAG,EAAC,CAAA;AACN,aAAA;YAEA,OAAON,QAAAA,CAASD,IAAMF,EAAAA,MAAAA,CAAOK,UAAU,CAAA;AACzC,SAAA;AAEF;;;;AAMC,IACKkB,MAAAA,sBAAAA,GAAyB,CAACC,gBAAAA,GAC9B3B,YACE,CAAA,CAACe,SAAcY,GAAAA,gBAAAA,CAAiBX,QAAQ,CAACD,SAAUG,CAAAA,IAAI,GACvD,IAAM,EAAA;AAGV;;;;;IAQA,MAAMU,gBAAmB5B,GAAAA,YAAAA,CACvB,CAACe,SAAAA,GAAcA,UAAUG,IAAI,KAAK,UAClC,EAAA,KAAO;AACLW,QAAAA,OAAAA,EAAS,EAAE;AACXC,QAAAA,UAAAA,EAAY;KACd,CAAA;AAGF;;;;;;AAQC,UACKC,eAAkB/B,GAAAA,YAAAA,CACtB,CAACe,SAAAA,GACC,SAAWG,CAAAA,IAAI,KAAK,WAAA,IAAeH,UAAUI,UAAU,IAAKJ,UAAUG,IAAI,KAAK,eACjF,CAACb,IAAAA,GAAAA;AACC,IAAA,IAAI2B,MAAMC,OAAO,CAAC5B,SAASA,IAAK6B,CAAAA,MAAM,GAAG,CAAG,EAAA;AAC1C,QAAA,MAAMC,IAAOC,GAAAA,uCAAAA,CAAqBnB,SAAWA,EAAAA,SAAAA,EAAWZ,KAAK6B,MAAM,CAAA;AAEnE,QAAA,OAAO7B,KAAKgB,GAAG,CAAC,CAACd,KAAAA,EAAO8B,SAAW;AACjC,gBAAA,GAAG9B,KAAK;gBACR+B,YAAcH,EAAAA,IAAI,CAACE,KAAM;aAC3B,CAAA,CAAA;AACF;IAEA,OAAOhC,IAAAA;AACT,CAAA;AAGF;;;;;;AAQC,IACKkC,MAAAA,iCAAAA,GAAoC,CAACpC,MAAAA,GAA0B,CAACE,IAAAA,GAAAA;AACpE,QAAA,MAAMmC,UAAa/B,GAAAA,MAAAA,CAAO0B,IAAI,CAAChC,OAAOK,UAAU,CAAA;QAChD,MAAMiC,QAAAA,GAAWhC,MAAO0B,CAAAA,IAAI,CAAC9B,IAAAA,CAAAA;QAE7B,MAAMqC,YAAAA,GAAeD,SAASE,MAAM,CAAC,CAAC9B,GAAQ,GAAA,CAAC2B,UAAWxB,CAAAA,QAAQ,CAACH,GAAAA,CAAAA,CAAAA;AAEnE,QAAA,MAAM+B,WAAc,GAAA;AAAIF,YAAAA,GAAAA,YAAAA;AAAiBG,YAAAA,GAAAA;SAAqB,CAAClC,MAAM,CAAC,CAACC,GAAKC,EAAAA,GAAAA,GAAAA;YAC1E,OAAOD,GAAG,CAACC,GAAI,CAAA;YAEf,OAAOD,GAAAA;AACT,SAAA,EAAGkC,eAAgBzC,CAAAA,IAAAA,CAAAA,CAAAA;QAEnB,OAAOuC,WAAAA;AACT;AAEA;;;;;IAMA,MAAMG,mBAAmB,CAAC1C,IAAAA,GAAAA;IACxB,OAAOI,MAAAA,CAAOC,OAAO,CAACL,IAAMM,CAAAA,CAAAA,MAAM,CAAU,CAACC,GAAAA,EAAK,CAACC,GAAAA,EAAKC,KAAM,CAAA,GAAA;AAC5D,QAAA,IAAIA,UAAU,IAAM,EAAA;YAClB,OAAOF,GAAAA;AACT;QAEAA,GAAG,CAACC,IAAI,GAAGC,KAAAA;QAEX,OAAOF,GAAAA;AACT,KAAA,EAAG,EAAC,CAAA;AACN,CAAA;AAEA;;;;;;;IAUA,MAAMoC,oBACJ,CAAC7C,MAAAA,EAAuBC,aAAmC,EAAE,GAC7D,CAAC6C,QAAAA,GAAAA;AACC,QAAA,MAAMC,eAAkBC,GAAAA,IAAAA,CACtBZ,iCAAkCpC,CAAAA,MAAAA,CAAAA,EAClCuB,sBAAuB,CAAA;AAAC,YAAA;AAAW,SAAA,CAAA,CAAEvB,QAAQC,UAC7C2C,CAAAA,EAAAA,gBAAAA,EACAnB,iBAAiBzB,MAAQC,EAAAA,UAAAA,CAAAA,EACzB2B,gBAAgB5B,MAAQC,EAAAA,UAAAA,CAAAA,CAAAA;AAG1B,QAAA,OAAO8C,eAAgBD,CAAAA,QAAAA,CAAAA;AACzB;AAUF;;;;;;;IAQA,MAAMG,4BAA4B,CAChC/C,IAAAA,EACA,EAAEF,MAAM,EAAEkD,gBAAgB,EAAE,EAAEjD,UAAa,GAAA,EAAE,EAAiB,EAC9DkD,OAAiB,EAAE,EACnBC,oBAAwC,EAAE,GAAA;IAK1C,IAAI,CAACpD,MAAQK,EAAAA,UAAAA,EAAY,OAAO;AAAEH,QAAAA,IAAAA;AAAMkD,QAAAA;AAAkB,KAAA;AAE1D,IAAA,MAAMC,WAAcC,GAAAA,6BAAAA,EAAAA;AACpB,IAAA,MAAMC,SAAkB,EAAC;IAEzB,KAAK,MAAM,CAACC,QAAAA,EAAUC,OAAQ,CAAA,IAAInD,OAAOC,OAAO,CAACP,MAAOK,CAAAA,UAAU,CAAG,CAAA;AACnE,QAAA,MAAMqD,QAAW,GAAA;AAAIP,YAAAA,GAAAA,IAAAA;AAAMK,YAAAA;AAAS,SAAA,CAACG,IAAI,CAAC,GAAA,CAAA;QAC1C,MAAMC,SAAAA,GAAYH,SAASI,UAAYC,EAAAA,OAAAA;AACvC,QAAA,MAAMC,SAAYH,GAAAA,SAAAA,GAAYP,WAAYW,CAAAA,QAAQ,CAACJ,SAAW,EAAA;AAAE,YAAA,GAAG1D,IAAI;AAAE,YAAA,GAAGqD;SAAY,CAAA,GAAA,IAAA;AAExF,QAAA,IAAI,CAACQ,SAAW,EAAA;AACdX,YAAAA,iBAAAA,CAAkBa,IAAI,CAACP,QAAAA,CAAAA;AACvB,YAAA;AACF;QAEA,MAAMQ,YAAAA,GAAe5D,OAAO6D,SAAS,CAACC,cAAc,CAACC,IAAI,CAACnE,IAAMsD,EAAAA,QAAAA,CAAAA;AAChE,QAAA,MAAMc,YAAeJ,GAAAA,YAAAA,GAAehE,IAAI,CAACsD,SAAS,GAAG1C,SAAAA;QACrD,MAAMyD,YAAAA,GAAerB,aAAe,GAACM,QAAS,CAAA;;QAG9C,IAAIC,OAAAA,CAAQ1C,IAAI,KAAK,WAAa,EAAA;AAChC,YAAA,MAAMyD,UAAavE,GAAAA,UAAU,CAACwD,OAAAA,CAAQrC,SAAS,CAAC;AAChD,YAAA,MAAMT,QAAQ2D,YAAgBC,IAAAA,YAAAA;AAE9B,YAAA,IAAI,CAAC5D,KAAO,EAAA;AACV4C,gBAAAA,MAAM,CAACC,QAAS,CAAA,GAAGC,QAAQzC,UAAU,GAAG,EAAE,GAAG,IAAA;AAC7C,gBAAA;AACF;AAEA,YAAA,IAAIyC,QAAQzC,UAAU,IAAIa,KAAMC,CAAAA,OAAO,CAACnB,KAAQ,CAAA,EAAA;gBAC9C4C,MAAM,CAACC,QAAS,CAAA,GAAG7C,KAAMO,CAAAA,GAAG,CAC1B,CAACuD,IAAAA,EAAMvC,KACLe,GAAAA,yBAAAA,CACEwB,IACA,EAAA;wBACEzE,MAAQwE,EAAAA,UAAAA;AACRtB,wBAAAA,aAAAA,EAAeqB,YAAc,GAACrC,KAAM,CAAA,IAAI,EAAC;AACzCjC,wBAAAA;qBAEF,EAAA;AAAIkD,wBAAAA,GAAAA,IAAAA;AAAM,wBAAA,CAAC,EAAEK,QAAS,CAAA,CAAC,EAAEtB,KAAAA,CAAM,CAAC;AAAE,qBAAA,EAClCkB,mBACAlD,IAAI,CAAA;aAEL,MAAA;AACLqD,gBAAAA,MAAM,CAACC,QAAAA,CAAS,GAAGP,yBAAAA,CACjBtC,KACA,EAAA;oBACEX,MAAQwE,EAAAA,UAAAA;AACRtB,oBAAAA,aAAAA,EAAeqB,gBAAgB,EAAC;AAChCtE,oBAAAA;iBAEF,EAAA;AAAIkD,oBAAAA,GAAAA,IAAAA;AAAMK,oBAAAA;AAAS,iBAAA,EACnBJ,mBACAlD,IAAI;AACR;AAEA,YAAA;AACF;;QAGA,IAAIuD,OAAAA,CAAQ1C,IAAI,KAAK,aAAe,EAAA;AAClC,YAAA,IAAI,CAACc,KAAAA,CAAMC,OAAO,CAACwC,YAAe,CAAA,EAAA;gBAChCf,MAAM,CAACC,QAAS,CAAA,GAAG,EAAE;AACrB,gBAAA;AACF;AAEAD,YAAAA,MAAM,CAACC,QAAS,CAAA,GAAGc,aAAapD,GAAG,CAAC,CAACwD,MAAQxC,EAAAA,KAAAA,GAAAA;AAC3C,gBAAA,MAAMyC,UAAUD,MAAQpD,EAAAA,WAAAA;gBACxB,MAAMkD,UAAAA,GAAavE,UAAU,CAAC0E,OAAQ,CAAA;gBAEtC,MAAMC,OAAAA,GAAU3B,0BACdyB,MACA,EAAA;oBACE1E,MAAQwE,EAAAA,UAAAA;AACRtB,oBAAAA,aAAAA,EAAeqB,YAAc,GAACrC,KAAM,CAAA,IAAI,EAAC;AACzCjC,oBAAAA;iBAEF,EAAA;AAAIkD,oBAAAA,GAAAA,IAAAA;AAAM,oBAAA,CAAC,EAAEK,QAAS,CAAA,CAAC,EAAEtB,KAAAA,CAAM,CAAC;AAAE,iBAAA,EAClCkB,mBACAlD,IAAI;gBAEN,OAAO;oBACLoB,WAAaqD,EAAAA,OAAAA;AACb,oBAAA,GAAGC;AACL,iBAAA;AACF,aAAA,CAAA;AAEA,YAAA;AACF;;AAGA,QAAA,IAAIN,iBAAiBxD,SAAW,EAAA;YAC9ByC,MAAM,CAACC,SAAS,GAAGc,YAAAA;SACd,MAAA,IAAIC,iBAAiBzD,SAAW,EAAA;YACrCyC,MAAM,CAACC,SAAS,GAAGe,YAAAA;SACd,MAAA;YACL,IAAIf,QAAAA,KAAa,IAAQA,IAAAA,QAAAA,KAAa,YAAc,EAAA;AAElD,gBAAA;AACF;YACAD,MAAM,CAACC,SAAS,GAAG,IAAA;AACrB;AACF;IAEA,OAAO;QACLtD,IAAMqD,EAAAA,MAAAA;AACNH,QAAAA;AACF,KAAA;AACF;;;;;;;;;"}