{"version":3,"file":"validation.js","sources":["../../../admin/src/utils/validation.ts"],"sourcesContent":["import { translatedErrors } from '@strapi/admin/strapi-admin';\nimport pipe from 'lodash/fp/pipe';\nimport * as yup from 'yup';\n\nimport { DOCUMENT_META_FIELDS } from '../constants/attributes';\n\nimport type { ComponentsDictionary, Schema } from '../hooks/useDocument';\nimport type { Schema as SchemaUtils } from '@strapi/types';\nimport type { ObjectShape } from 'yup/lib/object';\n\ntype AnySchema =\n  | yup.StringSchema\n  | yup.NumberSchema\n  | yup.BooleanSchema\n  | yup.DateSchema\n  | yup.ArraySchema<any>\n  | yup.ObjectSchema<any>;\n\n/* -------------------------------------------------------------------------------------------------\n * createYupSchema\n * -----------------------------------------------------------------------------------------------*/\n\ninterface ValidationOptions {\n  status: 'draft' | 'published' | null;\n  removedAttributes?: string[];\n}\n\nconst arrayValidator = (attribute: Schema['attributes'][string], options: ValidationOptions) => ({\n  message: translatedErrors.required,\n  test(value: unknown) {\n    if (options.status === 'draft') {\n      return true;\n    }\n\n    if (!attribute.required) {\n      return true;\n    }\n\n    if (!value) {\n      return false;\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false;\n    }\n\n    return true;\n  },\n});\nconst escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n/**\n * TODO: should we create a Map to store these based on the hash of the schema?\n */\nconst createYupSchema = (\n  attributes: Schema['attributes'] = {},\n  components: ComponentsDictionary = {},\n  options: ValidationOptions = { status: null }\n): yup.ObjectSchema<any> => {\n  const createModelSchema = (\n    attributes: Schema['attributes'],\n    removedAttributes: string[] = []\n  ): yup.ObjectSchema<any> =>\n    yup\n      .object()\n      .shape(\n        Object.entries(attributes).reduce<ObjectShape>((acc, [name, attribute]) => {\n          const getNestedPathsForAttribute = (removed: string[], attrName: string): string[] => {\n            const prefix = `${attrName}.`;\n            const bracketRegex = new RegExp(`^${escapeRegex(attrName)}\\\\[\\\\d+\\\\]\\\\.`);\n\n            return removed\n              .filter((p) => p.startsWith(prefix) || bracketRegex.test(p))\n              .map((p) =>\n                p.startsWith(prefix) ? p.slice(prefix.length) : p.replace(bracketRegex, '')\n              );\n          };\n\n          if (DOCUMENT_META_FIELDS.includes(name)) {\n            return acc;\n          }\n\n          if (removedAttributes?.includes(name)) {\n            // If the attribute is not visible, we don't want to validate it\n            return acc;\n          }\n\n          const nestedRemoved = getNestedPathsForAttribute(removedAttributes, name);\n\n          /**\n           * These validations won't apply to every attribute\n           * and that's okay, in that case we just return the\n           * schema as it was passed.\n           */\n          const validations = [\n            addNullableValidation,\n            addRequiredValidation,\n            addMinLengthValidation,\n            addMaxLengthValidation,\n            addMinValidation,\n            addMaxValidation,\n            addRegexValidation,\n          ].map((fn) => fn(attribute, options));\n\n          const transformSchema = pipe(...validations);\n\n          switch (attribute.type) {\n            case 'component': {\n              const { attributes } = components[attribute.component];\n\n              if (attribute.repeatable) {\n                return {\n                  ...acc,\n                  [name]: transformSchema(\n                    yup.array().of(createModelSchema(attributes, nestedRemoved).nullable(false))\n                  ).test(arrayValidator(attribute, options)),\n                };\n              } else {\n                return {\n                  ...acc,\n                  [name]: transformSchema(createModelSchema(attributes, nestedRemoved).nullable()),\n                };\n              }\n            }\n            case 'dynamiczone':\n              return {\n                ...acc,\n                [name]: transformSchema(\n                  yup.array().of(\n                    yup.lazy(\n                      (\n                        data: SchemaUtils.Attribute.Value<SchemaUtils.Attribute.DynamicZone>[number]\n                      ) => {\n                        const attributes = components?.[data?.__component]?.attributes;\n\n                        const validation = yup\n                          .object()\n                          .shape({\n                            __component: yup.string().required().oneOf(Object.keys(components)),\n                          })\n                          .nullable(false);\n                        if (!attributes) {\n                          return validation;\n                        }\n\n                        return validation.concat(createModelSchema(attributes, nestedRemoved));\n                      }\n                    ) as unknown as yup.ObjectSchema<any>\n                  )\n                ).test(arrayValidator(attribute, options)),\n              };\n            case 'relation':\n              return {\n                ...acc,\n                [name]: transformSchema(\n                  yup.lazy((value) => {\n                    if (!value) {\n                      return yup.mixed().nullable(true);\n                    } else if (Array.isArray(value)) {\n                      // If a relation value is an array, we expect\n                      // an array of objects with {id} properties, representing the related entities.\n                      return yup.array().of(\n                        yup.object().shape({\n                          id: yup.number().required(),\n                        })\n                      );\n                    } else if (typeof value === 'object') {\n                      // A realtion value can also be an object. Some API\n                      // repsonses return the number of entities in the relation\n                      // as { count: x }\n                      return yup.object();\n                    } else {\n                      return yup\n                        .mixed()\n                        .test(\n                          'type-error',\n                          'Relation values must be either null, an array of objects with {id} or an object.',\n                          () => false\n                        );\n                    }\n                  })\n                ),\n              };\n            default:\n              return {\n                ...acc,\n                [name]: transformSchema(createAttributeSchema(attribute)),\n              };\n          }\n        }, {})\n      )\n      /**\n       * TODO: investigate why an undefined object fails a check of `nullable`.\n       */\n      .default(null);\n\n  return createModelSchema(attributes, options.removedAttributes);\n};\n\nconst createAttributeSchema = (\n  attribute: Exclude<\n    SchemaUtils.Attribute.AnyAttribute,\n    { type: 'dynamiczone' } | { type: 'component' } | { type: 'relation' }\n  >\n) => {\n  switch (attribute.type) {\n    case 'biginteger':\n      return yup.string().matches(/^-?\\d*$/);\n    case 'boolean':\n      return yup.boolean();\n    case 'blocks':\n      return yup.mixed().test('isBlocks', translatedErrors.json, (value) => {\n        if (!value || Array.isArray(value)) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n    case 'decimal':\n    case 'float':\n    case 'integer':\n      return yup.number();\n    case 'email':\n      return yup.string().email(translatedErrors.email);\n    case 'enumeration':\n      return yup.string().oneOf([...attribute.enum, null]);\n    case 'json':\n      return yup.mixed().test('isJSON', translatedErrors.json, (value) => {\n        /**\n         * We don't want to validate the JSON field if it's empty.\n         */\n        if (!value || (typeof value === 'string' && value.length === 0)) {\n          return true;\n        }\n\n        // If the value was created via content API and wasn't changed, then it's still an object\n        if (typeof value === 'object') {\n          try {\n            JSON.stringify(value);\n            return true;\n          } catch (err) {\n            return false;\n          }\n        }\n\n        try {\n          JSON.parse(value);\n\n          return true;\n        } catch (err) {\n          return false;\n        }\n      });\n    case 'password':\n    case 'richtext':\n    case 'string':\n    case 'text':\n      return yup.string();\n    case 'uid':\n      return yup\n        .string()\n        .matches(attribute.regex ? new RegExp(attribute.regex) : /^[A-Za-z0-9-_.~]*$/);\n    default:\n      /**\n       * This allows any value.\n       */\n      return yup.mixed();\n  }\n};\n\n// Helper function to return schema.nullable() if it exists, otherwise return schema\nconst nullableSchema = <TSchema extends AnySchema>(schema: TSchema) => {\n  return schema?.nullable\n    ? schema.nullable()\n    : // In some cases '.nullable' will not be available on the schema.\n      // e.g. when the schema has been built using yup.lazy (e.g. for relations).\n      // In these cases we should just return the schema as it is.\n      schema;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Validators\n * -----------------------------------------------------------------------------------------------*/\n/**\n * Our validator functions can be preped with the\n * attribute and then have the schema piped through them.\n */\ntype ValidationFn = (\n  attribute: Schema['attributes'][string],\n  options: ValidationOptions\n) => <TSchema extends AnySchema>(schema: TSchema) => TSchema;\n\nconst addNullableValidation: ValidationFn = () => (schema) => {\n  return nullableSchema(schema);\n};\n\nconst addRequiredValidation: ValidationFn = (attribute, options) => (schema) => {\n  if (options.status === 'draft' || !attribute.required) {\n    return schema;\n  }\n\n  if (attribute.required && 'required' in schema) {\n    return schema.required(translatedErrors.required);\n  }\n\n  return schema;\n};\n\nconst addMinLengthValidation: ValidationFn =\n  (attribute, options) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    // Skip minLength validation for draft\n    if (options.status === 'draft') {\n      return schema;\n    }\n\n    if (\n      'minLength' in attribute &&\n      attribute.minLength &&\n      Number.isInteger(attribute.minLength) &&\n      'min' in schema\n    ) {\n      return schema.min(attribute.minLength, {\n        ...translatedErrors.minLength,\n        values: {\n          min: attribute.minLength,\n        },\n      }) as TSchema;\n    }\n\n    return schema;\n  };\n\nconst addMaxLengthValidation: ValidationFn =\n  (attribute) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    if (\n      'maxLength' in attribute &&\n      attribute.maxLength &&\n      Number.isInteger(attribute.maxLength) &&\n      'max' in schema\n    ) {\n      return schema.max(attribute.maxLength, {\n        ...translatedErrors.maxLength,\n        values: {\n          max: attribute.maxLength,\n        },\n      }) as TSchema;\n    }\n\n    return schema;\n  };\n\nconst addMinValidation: ValidationFn =\n  (attribute, options) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    // do not validate min for draft\n    if (options.status === 'draft') {\n      return schema;\n    }\n\n    if ('min' in attribute && 'min' in schema) {\n      const min = toInteger(attribute.min);\n\n      if (min) {\n        return schema.min(min, {\n          ...translatedErrors.min,\n          values: {\n            min,\n          },\n        }) as TSchema;\n      }\n    }\n\n    return schema;\n  };\n\nconst addMaxValidation: ValidationFn =\n  (attribute) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    if ('max' in attribute) {\n      const max = toInteger(attribute.max);\n\n      if ('max' in schema && max) {\n        return schema.max(max, {\n          ...translatedErrors.max,\n          values: {\n            max,\n          },\n        }) as TSchema;\n      }\n    }\n\n    return schema;\n  };\n\nconst toInteger = (val?: string | number): number | undefined => {\n  if (typeof val === 'number' || val === undefined) {\n    return val;\n  } else {\n    const num = Number(val);\n    return isNaN(num) ? undefined : num;\n  }\n};\n\nconst addRegexValidation: ValidationFn =\n  (attribute) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    if ('regex' in attribute && attribute.regex && 'matches' in schema) {\n      return schema.matches(new RegExp(attribute.regex), {\n        message: {\n          id: translatedErrors.regex.id,\n          defaultMessage: 'The value does not match the defined pattern.',\n        },\n\n        excludeEmptyString: !attribute.required,\n      }) as TSchema;\n    }\n\n    return schema;\n  };\n\nexport { createYupSchema };\n"],"names":["arrayValidator","attribute","options","message","translatedErrors","required","test","value","status","Array","isArray","length","escapeRegex","str","replace","createYupSchema","attributes","components","createModelSchema","removedAttributes","yup","object","shape","Object","entries","reduce","acc","name","getNestedPathsForAttribute","removed","attrName","prefix","bracketRegex","RegExp","filter","p","startsWith","map","slice","DOCUMENT_META_FIELDS","includes","nestedRemoved","validations","addNullableValidation","addRequiredValidation","addMinLengthValidation","addMaxLengthValidation","addMinValidation","addMaxValidation","addRegexValidation","fn","transformSchema","pipe","type","component","repeatable","array","of","nullable","lazy","data","__component","validation","string","oneOf","keys","concat","mixed","id","number","createAttributeSchema","default","matches","boolean","json","email","enum","JSON","stringify","err","parse","regex","nullableSchema","schema","minLength","Number","isInteger","min","values","maxLength","max","toInteger","val","undefined","num","isNaN","defaultMessage","excludeEmptyString"],"mappings":"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"}