{"version":3,"file":"relations.mjs","sources":["../../../admin/src/services/relations.ts"],"sourcesContent":["import { generateNKeysBetween } from 'fractional-indexing';\n\nimport {\n  RelationResult as RelResult,\n  FindAvailable,\n  FindExisting,\n} from '../../../shared/contracts/relations';\n\nimport { contentManagerApi } from './api';\n\nimport type { Modules } from '@strapi/types';\nimport type { errors } from '@strapi/utils';\n\ninterface RelationResult extends RelResult {\n  __temp_key__: string;\n}\n\ntype GetRelationsResponse =\n  | {\n      results: Array<RelationResult>;\n      pagination: {\n        page: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['page']>;\n        pageSize: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['pageSize']>;\n        pageCount: number;\n        total: number;\n      } | null;\n      error?: never;\n    }\n  | {\n      results?: never;\n      pagination?: never;\n      error: errors.ApplicationError | errors.YupValidationError;\n    };\n\nconst relationsApi = contentManagerApi.injectEndpoints({\n  endpoints: (build) => ({\n    getRelations: build.query<\n      GetRelationsResponse,\n      FindExisting.Params & {\n        params?: FindExisting.Request['query'];\n      }\n    >({\n      query: ({ model, id, targetField, params }) => {\n        return {\n          url: `/content-manager/relations/${model}/${id}/${targetField}`,\n          method: 'GET',\n          config: {\n            params,\n          },\n        };\n      },\n      serializeQueryArgs: (args) => {\n        const { endpointName, queryArgs } = args;\n        return {\n          endpointName,\n          model: queryArgs.model,\n          id: queryArgs.id,\n          targetField: queryArgs.targetField,\n          locale: queryArgs.params?.locale,\n          status: queryArgs.params?.status,\n        };\n      },\n      merge: (currentCache, newItems) => {\n        if (currentCache.pagination && newItems.pagination) {\n          if (currentCache.pagination.page < newItems.pagination.page) {\n            /**\n             * Relations will always have unique IDs, so we can therefore assume\n             * that we only need to push the new items to the cache.\n             *\n             * Push new items at the beginning as latest items are shown first\n             */\n            currentCache.results = [\n              ...prepareTempKeys(newItems.results, currentCache.results),\n              ...currentCache.results,\n            ];\n            currentCache.pagination = newItems.pagination;\n          } else if (newItems.pagination.page === 1) {\n            /**\n             * We're resetting the relations\n             */\n            currentCache.results = prepareTempKeys(newItems.results);\n            currentCache.pagination = newItems.pagination;\n          }\n        }\n      },\n      forceRefetch({ currentArg, previousArg }) {\n        if (!currentArg?.params && !previousArg?.params) {\n          return false;\n        }\n\n        return (\n          currentArg?.params?.page !== previousArg?.params?.page ||\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\n        );\n      },\n      transformResponse: (response: FindExisting.Response) => {\n        if ('results' in response && response.results) {\n          return {\n            ...response,\n            results: prepareTempKeys(response.results.toReversed()),\n          };\n        } else {\n          return response;\n        }\n      },\n      providesTags: ['Relations'],\n    }),\n    searchRelations: build.query<\n      FindAvailable.Response,\n      FindAvailable.Params & {\n        params?: FindAvailable.Request['query'];\n      }\n    >({\n      query: ({ model, targetField, params }) => {\n        return {\n          url: `/content-manager/relations/${model}/${targetField}`,\n          method: 'GET',\n          config: {\n            params,\n          },\n        };\n      },\n      serializeQueryArgs: (args) => {\n        const { endpointName, queryArgs } = args;\n        return {\n          endpointName,\n          model: queryArgs.model,\n          targetField: queryArgs.targetField,\n          _q: queryArgs.params?._q,\n          idsToOmit: queryArgs.params?.idsToOmit,\n          idsToInclude: queryArgs.params?.idsToInclude,\n        };\n      },\n      merge: (currentCache, newItems) => {\n        if (currentCache.pagination && newItems.pagination) {\n          if (currentCache.pagination.page < newItems.pagination.page) {\n            /**\n             * Relations will always have unique IDs, so we can therefore assume\n             * that we only need to push the new items to the cache.\n             */\n            const existingIds = currentCache.results.map((item) => item.documentId);\n            const uniqueNewItems = newItems.results.filter(\n              (item) => !existingIds.includes(item.documentId)\n            );\n            currentCache.results.push(...uniqueNewItems);\n            currentCache.pagination = newItems.pagination;\n          } else if (newItems.pagination.page === 1) {\n            /**\n             * We're resetting the relations\n             */\n            currentCache.results = newItems.results;\n            currentCache.pagination = newItems.pagination;\n          }\n        }\n      },\n      forceRefetch({ currentArg, previousArg }) {\n        if (!currentArg?.params && !previousArg?.params) {\n          return false;\n        }\n\n        return (\n          currentArg?.params?.page !== previousArg?.params?.page ||\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\n        );\n      },\n      transformResponse: (response: FindAvailable.Response) => {\n        if (response.results) {\n          return {\n            ...response,\n            results: response.results,\n          };\n        } else {\n          return response;\n        }\n      },\n    }),\n  }),\n});\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each relation item. This gives us\n * a stable identifier regardless of it's ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = (relations: RelResult[], existingRelations: RelationResult[] = []) => {\n  const [firstItem] = existingRelations.slice(0);\n  const keys = generateNKeysBetween(null, firstItem?.__temp_key__ ?? null, relations.length);\n\n  return relations.map((datum, index) => ({\n    ...datum,\n    __temp_key__: keys[index],\n  }));\n};\n\nconst { useGetRelationsQuery, useLazySearchRelationsQuery } = relationsApi;\n\nexport { useGetRelationsQuery, useLazySearchRelationsQuery };\nexport type { RelationResult };\n"],"names":["relationsApi","contentManagerApi","injectEndpoints","endpoints","build","getRelations","query","model","id","targetField","params","url","method","config","serializeQueryArgs","args","endpointName","queryArgs","locale","status","merge","currentCache","newItems","pagination","page","results","prepareTempKeys","forceRefetch","currentArg","previousArg","pageSize","transformResponse","response","toReversed","providesTags","searchRelations","_q","idsToOmit","idsToInclude","existingIds","map","item","documentId","uniqueNewItems","filter","includes","push","relations","existingRelations","firstItem","slice","keys","generateNKeysBetween","__temp_key__","length","datum","index","useGetRelationsQuery","useLazySearchRelationsQuery"],"mappings":"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"}