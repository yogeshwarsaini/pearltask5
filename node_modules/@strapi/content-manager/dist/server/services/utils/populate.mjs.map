{"version":3,"file":"populate.mjs","sources":["../../../../server/src/services/utils/populate.ts"],"sourcesContent":["import { merge, isEmpty, set, propEq } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\nimport type { UID, Schema, Modules } from '@strapi/types';\nimport { getService } from '../../utils';\n\nconst { isVisibleAttribute, isScalarAttribute, getDoesAttributeRequireValidation } =\n  strapiUtils.contentTypes;\nconst { isAnyToMany } = strapiUtils.relations;\nconst { PUBLISHED_AT_ATTRIBUTE } = strapiUtils.contentTypes.constants;\n\nconst isMorphToRelation = (attribute: any) =>\n  isRelation(attribute) && attribute.relation.includes('morphTo');\nconst isMedia = propEq('type', 'media');\nconst isRelation = propEq('type', 'relation');\nconst isComponent = propEq('type', 'component');\nconst isDynamicZone = propEq('type', 'dynamiczone');\n\n// TODO: Import from @strapi/types when it's available there\ntype Model = Parameters<typeof isVisibleAttribute>[0];\nexport type Populate = Modules.EntityService.Params.Populate.Any<UID.Schema>;\n\ntype PopulateOptions = {\n  initialPopulate?: Populate;\n  countMany?: boolean;\n  countOne?: boolean;\n  maxLevel?: number;\n};\n\n/**\n * Populate the model for relation\n * @param attribute - Attribute containing a relation\n * @param attribute.relation - type of relation\n * @param model - Model of the populated entity\n * @param attributeName\n * @param options - Options to apply while populating\n */\nfunction getPopulateForRelation(\n  attribute: Schema.Attribute.AnyAttribute,\n  model: Model,\n  attributeName: string,\n  { countMany, countOne, initialPopulate }: PopulateOptions\n) {\n  const isManyRelation = isAnyToMany(attribute);\n\n  if (initialPopulate) {\n    return initialPopulate;\n  }\n\n  // If populating localizations attribute, also include validatable fields\n  // Mainly needed for bulk locale publishing, so the Client has all the information necessary to perform validations\n  if (attributeName === 'localizations') {\n    const validationPopulate = getPopulateForValidation(model.uid as UID.Schema);\n\n    return {\n      populate: validationPopulate.populate,\n    };\n  }\n\n  // always populate createdBy, updatedBy, localizations etc.\n  if (!isVisibleAttribute(model, attributeName)) {\n    return true;\n  }\n\n  if ((isManyRelation && countMany) || (!isManyRelation && countOne)) {\n    return { count: true };\n  }\n\n  return true;\n}\n\n/**\n * Populate the model for Dynamic Zone components\n * @param attribute - Attribute containing the components\n * @param attribute.components - IDs of components\n * @param options - Options to apply while populating\n */\nfunction getPopulateForDZ(\n  attribute: Schema.Attribute.DynamicZone,\n  options: PopulateOptions,\n  level: number\n) {\n  // Use fragments to populate the dynamic zone components\n  const populatedComponents = (attribute.components || []).reduce(\n    (acc: any, componentUID: UID.Component) => ({\n      ...acc,\n      [componentUID]: {\n        populate: getDeepPopulate(componentUID, options, level + 1),\n      },\n    }),\n    {}\n  );\n\n  return { on: populatedComponents };\n}\n\n/**\n * Get the populated value based on the type of the attribute\n * @param attributeName - Name of the attribute\n * @param model - Model of the populated entity\n * @param model.attributes\n * @param options - Options to apply while populating\n * @param options.countMany\n * @param options.countOne\n * @param options.maxLevel\n * @param level\n */\nfunction getPopulateFor(\n  attributeName: string,\n  model: any,\n  options: PopulateOptions,\n  level: number\n): { [key: string]: boolean | object } {\n  const attribute = model.attributes[attributeName];\n\n  switch (attribute.type) {\n    case 'relation':\n      // @ts-expect-error - TODO: support populate count typing\n      return {\n        [attributeName]: getPopulateForRelation(attribute, model, attributeName, options),\n      };\n    case 'component':\n      return {\n        [attributeName]: {\n          populate: getDeepPopulate(attribute.component, options, level + 1),\n        },\n      };\n    case 'media':\n      return {\n        [attributeName]: {\n          populate: {\n            folder: true,\n          },\n        },\n      };\n    case 'dynamiczone':\n      return {\n        [attributeName]: getPopulateForDZ(attribute, options, level),\n      };\n    default:\n      return {};\n  }\n}\n\n/**\n * Deeply populate a model based on UID\n * @param uid - Unique identifier of the model\n * @param options - Options to apply while populating\n * @param level - Current level of nested call\n */\nconst getDeepPopulate = (\n  uid: UID.Schema,\n  {\n    initialPopulate = {} as any,\n    countMany = false,\n    countOne = false,\n    maxLevel = Infinity,\n  }: PopulateOptions = {},\n  level = 1\n) => {\n  if (level > maxLevel) {\n    return {};\n  }\n\n  const model = strapi.getModel(uid);\n\n  if (!model) {\n    return {};\n  }\n\n  return Object.keys(model.attributes).reduce(\n    (populateAcc, attributeName: string) =>\n      merge(\n        populateAcc,\n        getPopulateFor(\n          attributeName,\n          model,\n          {\n            // @ts-expect-error - improve types\n            initialPopulate: initialPopulate?.[attributeName],\n            countMany,\n            countOne,\n            maxLevel,\n          },\n          level\n        )\n      ),\n    {}\n  );\n};\n\n/**\n * Deeply populate a model based on UID. Only populating fields that require validation.\n * @param uid - Unique identifier of the model\n * @param options - Options to apply while populating\n * @param level - Current level of nested call\n */\nconst getPopulateForValidation = (uid: UID.Schema): Record<string, any> => {\n  const model = strapi.getModel(uid);\n  if (!model) {\n    return {};\n  }\n\n  return Object.entries(model.attributes).reduce((populateAcc: any, [attributeName, attribute]) => {\n    if (isScalarAttribute(attribute)) {\n      // If the scalar attribute requires validation, add it to the fields array\n      if (getDoesAttributeRequireValidation(attribute)) {\n        populateAcc.fields = populateAcc.fields || [];\n        populateAcc.fields.push(attributeName);\n      }\n      return populateAcc;\n    }\n\n    if (isMedia(attribute)) {\n      if (getDoesAttributeRequireValidation(attribute)) {\n        populateAcc.populate = populateAcc.populate || {};\n        populateAcc.populate[attributeName] = {\n          populate: {\n            folder: true,\n          },\n        };\n        return populateAcc;\n      }\n    }\n\n    if (isComponent(attribute)) {\n      // @ts-expect-error - should be a component\n      const component = attribute.component;\n\n      // Get the validation result for this component\n      const componentResult = getPopulateForValidation(component);\n\n      if (Object.keys(componentResult).length > 0) {\n        populateAcc.populate = populateAcc.populate || {};\n        populateAcc.populate[attributeName] = componentResult;\n      }\n\n      return populateAcc;\n    }\n\n    if (isDynamicZone(attribute)) {\n      const components = (attribute as Schema.Attribute.DynamicZone).components;\n      // Handle dynamic zone components\n      const componentsResult = (components || []).reduce(\n        (acc, componentUID) => {\n          // Get validation populate for this component\n          const componentResult = getPopulateForValidation(componentUID);\n\n          // Only include component if it has fields requiring validation\n          if (Object.keys(componentResult).length > 0) {\n            acc[componentUID] = componentResult;\n          }\n\n          return acc;\n        },\n        {} as Record<string, any>\n      );\n\n      // Only add to populate if we have components requiring validation\n      if (Object.keys(componentsResult).length > 0) {\n        populateAcc.populate = populateAcc.populate || {};\n        populateAcc.populate[attributeName] = { on: componentsResult };\n      }\n    }\n\n    return populateAcc;\n  }, {});\n};\n\n/**\n * getDeepPopulateDraftCount works recursively on the attributes of a model\n * creating a populated object to count all the unpublished relations within the model\n * These relations can be direct to this content type or contained within components/dynamic zones\n * @param  uid of the model\n * @returns result\n * @returns result.populate\n * @returns result.hasRelations\n */\nconst getDeepPopulateDraftCount = (uid: UID.Schema) => {\n  const model = strapi.getModel(uid);\n  let hasRelations = false;\n\n  const populate = Object.keys(model.attributes).reduce((populateAcc: any, attributeName) => {\n    const attribute: Schema.Attribute.AnyAttribute = model.attributes[attributeName];\n\n    switch (attribute.type) {\n      case 'relation': {\n        // TODO: Support polymorphic relations\n        const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n        if (isMorphRelation) {\n          break;\n        }\n\n        if (isVisibleAttribute(model, attributeName)) {\n          populateAcc[attributeName] = {\n            count: true,\n            filters: { [PUBLISHED_AT_ATTRIBUTE]: { $null: true } },\n          };\n          hasRelations = true;\n        }\n        break;\n      }\n      case 'component': {\n        const { populate, hasRelations: childHasRelations } = getDeepPopulateDraftCount(\n          attribute.component\n        );\n        if (childHasRelations) {\n          populateAcc[attributeName] = {\n            populate,\n          };\n          hasRelations = true;\n        }\n        break;\n      }\n      case 'dynamiczone': {\n        const dzPopulateFragment = attribute.components?.reduce((acc, componentUID) => {\n          const { populate: componentPopulate, hasRelations: componentHasRelations } =\n            getDeepPopulateDraftCount(componentUID);\n\n          if (componentHasRelations) {\n            hasRelations = true;\n\n            return { ...acc, [componentUID]: { populate: componentPopulate } };\n          }\n\n          return acc;\n        }, {});\n\n        if (!isEmpty(dzPopulateFragment)) {\n          populateAcc[attributeName] = { on: dzPopulateFragment };\n        }\n        break;\n      }\n      default:\n    }\n\n    return populateAcc;\n  }, {});\n\n  return { populate, hasRelations };\n};\n\n/**\n *  Create a Strapi populate object which populates all attribute fields of a Strapi query.\n */\nconst getQueryPopulate = async (uid: UID.Schema, query: object): Promise<Populate> => {\n  let populateQuery: Populate = {};\n\n  await strapiUtils.traverse.traverseQueryFilters(\n    /**\n     *\n     * @param {Object} param0\n     * @param {string} param0.key - Attribute name\n     * @param {Object} param0.attribute - Attribute definition\n     * @param {string} param0.path - Content Type path to the attribute\n     * @returns\n     */\n    ({ attribute, path }: any) => {\n      // TODO: handle dynamic zones and morph relations\n      if (!attribute || isDynamicZone(attribute) || isMorphToRelation(attribute)) {\n        return;\n      }\n\n      // Populate all relations, components and media\n      if (isRelation(attribute) || isMedia(attribute) || isComponent(attribute)) {\n        const populatePath = path.attribute.replace(/\\./g, '.populate.');\n        // @ts-expect-error - lodash doesn't resolve the Populate type correctly\n        populateQuery = set(populatePath, {}, populateQuery);\n      }\n    },\n    { schema: strapi.getModel(uid), getModel: strapi.getModel.bind(strapi) },\n    query\n  );\n\n  return populateQuery;\n};\n\nconst buildDeepPopulate = (uid: UID.CollectionType) => {\n  return getService('populate-builder')(uid).populateDeep(Infinity).countRelations().build();\n};\n\nexport {\n  getDeepPopulate,\n  getDeepPopulateDraftCount,\n  getPopulateForValidation,\n  getQueryPopulate,\n  buildDeepPopulate,\n};\n"],"names":["isVisibleAttribute","isScalarAttribute","getDoesAttributeRequireValidation","strapiUtils","contentTypes","isAnyToMany","relations","PUBLISHED_AT_ATTRIBUTE","constants","isMorphToRelation","attribute","isRelation","relation","includes","isMedia","propEq","isComponent","isDynamicZone","getPopulateForRelation","model","attributeName","countMany","countOne","initialPopulate","isManyRelation","validationPopulate","getPopulateForValidation","uid","populate","count","getPopulateForDZ","options","level","populatedComponents","components","reduce","acc","componentUID","getDeepPopulate","on","getPopulateFor","attributes","type","component","folder","maxLevel","Infinity","strapi","getModel","Object","keys","populateAcc","merge","entries","fields","push","componentResult","length","componentsResult","getDeepPopulateDraftCount","hasRelations","isMorphRelation","toLowerCase","startsWith","filters","$null","childHasRelations","dzPopulateFragment","componentPopulate","componentHasRelations","isEmpty","getQueryPopulate","query","populateQuery","traverse","traverseQueryFilters","path","populatePath","replace","set","schema","bind","buildDeepPopulate","getService","populateDeep","countRelations","build"],"mappings":"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"}