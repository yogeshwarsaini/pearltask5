{"version":3,"file":"utils.mjs","sources":["../../../../server/src/history/services/utils.ts"],"sourcesContent":["import { difference, omit } from 'lodash/fp';\nimport { contentTypes } from '@strapi/utils';\nimport type { Core, Modules, Schema, Data, Struct, UID } from '@strapi/types';\n\nimport { FIELDS_TO_IGNORE } from '../constants';\nimport type { CreateHistoryVersion } from '../../../../shared/contracts/history-versions';\nimport type { HistoryVersions } from '../../../../shared/contracts';\nimport type { RelationResult } from '../../../../shared/contracts/relations';\n\nconst DEFAULT_RETENTION_DAYS = 90;\n\ntype RelationResponse = {\n  results: RelationResult[];\n  meta: { missingCount: number };\n};\n\nexport const createServiceUtils = ({ strapi }: { strapi: Core.Strapi }) => {\n  /**\n   * @description\n   * Get the difference between the version schema and the content type schema\n   */\n  const getSchemaAttributesDiff = (\n    versionSchemaAttributes: CreateHistoryVersion['schema'],\n    contentTypeSchemaAttributes: Struct.SchemaAttributes\n  ) => {\n    // Omit the same fields that were omitted when creating a history version\n    const sanitizedContentTypeSchemaAttributes = omit(\n      FIELDS_TO_IGNORE,\n      contentTypeSchemaAttributes\n    );\n\n    const reduceDifferenceToAttributesObject = (\n      diffKeys: string[],\n      source: CreateHistoryVersion['schema']\n    ) => {\n      return diffKeys.reduce<CreateHistoryVersion['schema']>(\n        (previousAttributesObject, diffKey) => {\n          previousAttributesObject[diffKey] = source[diffKey];\n\n          return previousAttributesObject;\n        },\n        {}\n      );\n    };\n\n    const versionSchemaKeys = Object.keys(versionSchemaAttributes);\n    const contentTypeSchemaAttributesKeys = Object.keys(sanitizedContentTypeSchemaAttributes);\n    // The attribute is new if it's on the content type schema but not on the version schema\n    const uniqueToContentType = difference(contentTypeSchemaAttributesKeys, versionSchemaKeys);\n    const added = reduceDifferenceToAttributesObject(\n      uniqueToContentType,\n      sanitizedContentTypeSchemaAttributes\n    );\n    // The attribute was removed or renamed if it's on the version schema but not on the content type schema\n    const uniqueToVersion = difference(versionSchemaKeys, contentTypeSchemaAttributesKeys);\n    const removed = reduceDifferenceToAttributesObject(uniqueToVersion, versionSchemaAttributes);\n\n    return { added, removed };\n  };\n\n  /**\n   * @description\n   * Gets the value to set for a relation when restoring a document\n   * @returns\n   * The relation if it exists or null\n   */\n  const getRelationRestoreValue = async (\n    versionRelationData: Modules.Documents.AnyDocument | Modules.Documents.AnyDocument[],\n    attribute: Schema.Attribute.RelationWithTarget\n  ) => {\n    if (Array.isArray(versionRelationData)) {\n      if (versionRelationData.length === 0) return versionRelationData;\n\n      const existingAndMissingRelations = await Promise.all(\n        versionRelationData.map((relation) => {\n          return strapi.documents(attribute.target).findOne({\n            documentId: relation.documentId,\n            locale: relation.locale || undefined,\n          });\n        })\n      );\n\n      return existingAndMissingRelations.filter((relation) => relation !== null);\n    }\n\n    return strapi.documents(attribute.target).findOne({\n      documentId: versionRelationData.documentId,\n      locale: versionRelationData.locale || undefined,\n    });\n  };\n\n  /**\n   * @description\n   * Gets the value to set for a media asset when restoring a document\n   * @returns\n   * The media asset if it exists or null\n   */\n  const getMediaRestoreValue = async (\n    versionRelationData: Modules.Documents.AnyDocument | Modules.Documents.AnyDocument[]\n  ) => {\n    if (Array.isArray(versionRelationData)) {\n      const existingAndMissingMedias = await Promise.all(\n        versionRelationData.map((media) => {\n          return strapi.db.query('plugin::upload.file').findOne({ where: { id: media.id } });\n        })\n      );\n\n      return existingAndMissingMedias.filter((media) => media != null);\n    }\n\n    return strapi.db\n      .query('plugin::upload.file')\n      .findOne({ where: { id: versionRelationData.id } });\n  };\n\n  const localesService = strapi.plugin('i18n')?.service('locales');\n  const i18nContentTypeService = strapi.plugin('i18n')?.service('content-types');\n\n  const getDefaultLocale = async () => (localesService ? localesService.getDefaultLocale() : null);\n\n  const isLocalizedContentType = (model: Schema.ContentType) =>\n    i18nContentTypeService ? i18nContentTypeService.isLocalizedContentType(model) : false;\n\n  /**\n   *\n   * @description\n   * Creates a dictionary of all locales available\n   */\n  const getLocaleDictionary = async (): Promise<{\n    [key: string]: { name: string; code: string };\n  }> => {\n    if (!localesService) return {};\n\n    const locales = (await localesService.find()) || [];\n    return locales.reduce(\n      (\n        acc: Record<string, NonNullable<HistoryVersions.HistoryVersionDataResponse['locale']>>,\n        locale: NonNullable<HistoryVersions.HistoryVersionDataResponse['locale']>\n      ) => {\n        acc[locale.code] = { name: locale.name, code: locale.code };\n\n        return acc;\n      },\n      {}\n    );\n  };\n\n  /**\n   *\n   * @description\n   * Gets the number of retention days defined on the license or configured by the user\n   */\n  const getRetentionDays = () => {\n    const featureConfig = strapi.ee.features.get('cms-content-history');\n    const licenseRetentionDays =\n      typeof featureConfig === 'object' && featureConfig?.options.retentionDays;\n    const userRetentionDays: number = strapi.config.get('admin.history.retentionDays');\n\n    // Allow users to override the license retention days, but not to increase it\n    if (userRetentionDays && userRetentionDays < licenseRetentionDays) {\n      return userRetentionDays;\n    }\n\n    // User didn't provide retention days value, use the license or fallback to default\n    return Math.min(licenseRetentionDays, DEFAULT_RETENTION_DAYS);\n  };\n\n  const getVersionStatus = async (\n    contentTypeUid: HistoryVersions.CreateHistoryVersion['contentType'],\n    document: Modules.Documents.AnyDocument | null\n  ) => {\n    const documentMetadataService = strapi.plugin('content-manager').service('document-metadata');\n    const meta = await documentMetadataService.getMetadata(contentTypeUid, document);\n\n    return documentMetadataService.getStatus(document, meta.availableStatus);\n  };\n\n  /**\n   * Lists all the fields of a component, excepts those that will be populated.\n   * The goal is to exclude the ID, because when restoring a component,\n   * referencing an ID for a component db row that was deleted creates an error.\n   * So we never store component IDs to ensure they're re-created while restoring a version.\n   */\n  const getComponentFields = (componentUID: UID.Component): string[] => {\n    return Object.entries(strapi.getModel(componentUID).attributes).reduce<string[]>(\n      (fieldsAcc, [key, attribute]) => {\n        if (!['relation', 'media', 'component', 'dynamiczone'].includes(attribute.type)) {\n          fieldsAcc.push(key);\n        }\n\n        return fieldsAcc;\n      },\n      []\n    );\n  };\n\n  /**\n   * @description\n   * Creates a populate object that looks for all the relations that need\n   * to be saved in history, and populates only the fields needed to later retrieve the content.\n   *\n   * @param uid - The content type UID\n   * @param useDatabaseSyntax - Whether to use the database syntax for populate, defaults to false\n   */\n  const getDeepPopulate = (uid: UID.Schema, useDatabaseSyntax = false) => {\n    const model = strapi.getModel(uid);\n    const attributes = Object.entries(model.attributes);\n    const fieldSelector = useDatabaseSyntax ? 'select' : 'fields';\n\n    return attributes.reduce((acc: any, [attributeName, attribute]) => {\n      switch (attribute.type) {\n        case 'relation': {\n          // TODO: Support polymorphic relations\n          const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n          if (isMorphRelation) {\n            break;\n          }\n\n          const isVisible = contentTypes.isVisibleAttribute(model, attributeName);\n          if (isVisible) {\n            acc[attributeName] = { [fieldSelector]: ['documentId', 'locale', 'publishedAt'] };\n          }\n          break;\n        }\n\n        case 'media': {\n          acc[attributeName] = { [fieldSelector]: ['id'] };\n          break;\n        }\n\n        case 'component': {\n          const populate = getDeepPopulate(attribute.component);\n          acc[attributeName] = {\n            populate,\n            [fieldSelector]: getComponentFields(attribute.component),\n          };\n          break;\n        }\n\n        case 'dynamiczone': {\n          // Use fragments to populate the dynamic zone components\n          const populatedComponents = (attribute.components || []).reduce(\n            (acc: any, componentUID: UID.Component) => {\n              acc[componentUID] = {\n                populate: getDeepPopulate(componentUID),\n                [fieldSelector]: getComponentFields(componentUID),\n              };\n              return acc;\n            },\n            {}\n          );\n\n          acc[attributeName] = { on: populatedComponents };\n          break;\n        }\n        default:\n          break;\n      }\n\n      return acc;\n    }, {});\n  };\n\n  /**\n   * @description\n   * Builds a response object for relations containing the related data and a count of missing relations\n   */\n  const buildMediaResponse = async (values: { id: Data.ID }[]): Promise<RelationResponse> => {\n    return (\n      values\n        // Until we implement proper pagination, limit relations to an arbitrary amount\n        .slice(0, 25)\n        .reduce(\n          async (currentRelationDataPromise, entry) => {\n            const currentRelationData = await currentRelationDataPromise;\n\n            // Entry can be null if it's a toOne relation\n            if (!entry) {\n              return currentRelationData;\n            }\n\n            const relatedEntry = await strapi.db\n              .query('plugin::upload.file')\n              .findOne({ where: { id: entry.id } });\n\n            if (relatedEntry) {\n              currentRelationData.results.push(relatedEntry);\n            } else {\n              // The related content has been deleted\n              currentRelationData.meta.missingCount += 1;\n            }\n\n            return currentRelationData;\n          },\n          Promise.resolve<RelationResponse>({\n            results: [],\n            meta: { missingCount: 0 },\n          })\n        )\n    );\n  };\n\n  /**\n   * @description\n   * Builds a response object for media containing the media assets data and a count of missing media assets\n   */\n  const buildRelationReponse = async (\n    values: {\n      documentId: string;\n      locale: string | null;\n    }[],\n    attributeSchema: Schema.Attribute.RelationWithTarget\n  ): Promise<RelationResponse> => {\n    return (\n      values\n        // Until we implement proper pagination, limit relations to an arbitrary amount\n        .slice(0, 25)\n        .reduce(\n          async (currentRelationDataPromise, entry) => {\n            const currentRelationData = await currentRelationDataPromise;\n\n            // Entry can be null if it's a toOne relation\n            if (!entry) {\n              return currentRelationData;\n            }\n            const relatedEntry = await strapi\n              .documents(attributeSchema.target)\n              .findOne({ documentId: entry.documentId, locale: entry.locale || undefined });\n\n            if (relatedEntry) {\n              currentRelationData.results.push({\n                ...relatedEntry,\n                status: await getVersionStatus(attributeSchema.target, relatedEntry),\n              });\n            } else {\n              // The related content has been deleted\n              currentRelationData.meta.missingCount += 1;\n            }\n\n            return currentRelationData;\n          },\n          Promise.resolve<RelationResponse>({\n            results: [],\n            meta: { missingCount: 0 },\n          })\n        )\n    );\n  };\n\n  return {\n    getSchemaAttributesDiff,\n    getRelationRestoreValue,\n    getMediaRestoreValue,\n    getDefaultLocale,\n    isLocalizedContentType,\n    getLocaleDictionary,\n    getRetentionDays,\n    getVersionStatus,\n    getDeepPopulate,\n    buildMediaResponse,\n    buildRelationReponse,\n  };\n};\n"],"names":["DEFAULT_RETENTION_DAYS","createServiceUtils","strapi","getSchemaAttributesDiff","versionSchemaAttributes","contentTypeSchemaAttributes","sanitizedContentTypeSchemaAttributes","omit","FIELDS_TO_IGNORE","reduceDifferenceToAttributesObject","diffKeys","source","reduce","previousAttributesObject","diffKey","versionSchemaKeys","Object","keys","contentTypeSchemaAttributesKeys","uniqueToContentType","difference","added","uniqueToVersion","removed","getRelationRestoreValue","versionRelationData","attribute","Array","isArray","length","existingAndMissingRelations","Promise","all","map","relation","documents","target","findOne","documentId","locale","undefined","filter","getMediaRestoreValue","existingAndMissingMedias","media","db","query","where","id","localesService","plugin","service","i18nContentTypeService","getDefaultLocale","isLocalizedContentType","model","getLocaleDictionary","locales","find","acc","code","name","getRetentionDays","featureConfig","ee","features","get","licenseRetentionDays","options","retentionDays","userRetentionDays","config","Math","min","getVersionStatus","contentTypeUid","document","documentMetadataService","meta","getMetadata","getStatus","availableStatus","getComponentFields","componentUID","entries","getModel","attributes","fieldsAcc","key","includes","type","push","getDeepPopulate","uid","useDatabaseSyntax","fieldSelector","attributeName","isMorphRelation","toLowerCase","startsWith","isVisible","contentTypes","isVisibleAttribute","populate","component","populatedComponents","components","on","buildMediaResponse","values","slice","currentRelationDataPromise","entry","currentRelationData","relatedEntry","results","missingCount","resolve","buildRelationReponse","attributeSchema","status"],"mappings":"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"}