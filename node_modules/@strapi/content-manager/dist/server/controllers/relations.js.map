{"version":3,"file":"relations.js","sources":["../../../server/src/controllers/relations.ts"],"sourcesContent":["import { prop, uniq, uniqBy, concat, flow, isEmpty } from 'lodash/fp';\n\nimport { isOperatorOfType, contentTypes, relations, errors } from '@strapi/utils';\nimport type { Data, Modules, UID } from '@strapi/types';\n\nimport { getService } from '../utils';\nimport { validateFindAvailable, validateFindExisting } from './validation/relations';\nimport { isListable } from '../services/utils/configuration/attributes';\n\nconst { PUBLISHED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE } = contentTypes.constants;\n\ninterface RelationEntity {\n  id: Data.ID;\n  documentId: Modules.Documents.ID;\n  updatedAt: string | Date;\n  publishedAt?: string | Date;\n  [key: string]: unknown;\n}\n\nconst addFiltersClause = (params: any, filtersClause: any) => {\n  params.filters = params.filters || {};\n  params.filters.$and = params.filters.$and || [];\n  params.filters.$and.push(filtersClause);\n};\n\nconst sanitizeMainField = (model: any, mainField: any, userAbility: any) => {\n  const permissionChecker = getService('permission-checker').create({\n    userAbility,\n    model: model.uid,\n  });\n\n  // Whether the main field can be displayed or not, regardless of permissions.\n  const isMainFieldListable = isListable(model, mainField);\n  // Whether the user has the permission to access the model's main field (using RBAC abilities)\n  const canReadMainField = permissionChecker.can.read(null, mainField);\n\n  if (!isMainFieldListable || !canReadMainField) {\n    // Default to 'documentId' if the actual main field shouldn't be displayed\n    return 'documentId';\n  }\n\n  // Edge cases\n\n  // 1. Enforce 'name' as the main field for users and permissions' roles\n  if (model.uid === 'plugin::users-permissions.role') {\n    return 'name';\n  }\n\n  return mainField;\n};\n\n/**\n *\n * All relations sent to this function should have the same status or no status\n */\nconst addStatusToRelations = async (targetUid: UID.Schema, relations: RelationEntity[]) => {\n  if (!contentTypes.hasDraftAndPublish(strapi.getModel(targetUid))) {\n    return relations;\n  }\n\n  const documentMetadata = getService('document-metadata');\n\n  if (!relations.length) {\n    return relations;\n  }\n\n  const firstRelation = relations[0];\n\n  const filters: any = {\n    documentId: { $in: relations.map((r) => r.documentId) },\n    // NOTE: find the \"opposite\" status\n    publishedAt: firstRelation.publishedAt !== null ? { $null: true } : { $notNull: true },\n  };\n\n  const availableStatus = await strapi.query(targetUid).findMany({\n    select: ['id', 'documentId', 'locale', 'updatedAt', 'createdAt', 'publishedAt'],\n    filters,\n  });\n\n  return relations.map((relation: RelationEntity) => {\n    const availableStatuses = availableStatus.filter(\n      (availableDocument: RelationEntity) =>\n        availableDocument.documentId === relation.documentId &&\n        (relation.locale ? availableDocument.locale === relation.locale : true)\n    );\n\n    return {\n      ...relation,\n      status: documentMetadata.getStatus(relation, availableStatuses),\n    };\n  });\n};\n\nconst getPublishedAtClause = (status: string, uid: UID.Schema) => {\n  const model = strapi.getModel(uid);\n\n  /**\n   * If dp is disabled, ignore the filter\n   */\n  if (!model || !contentTypes.hasDraftAndPublish(model)) {\n    return {};\n  }\n\n  // Prioritize the draft status in case it's not provided\n  return status === 'published' ? { $notNull: true } : { $null: true };\n};\n\nconst validateLocale = (sourceUid: UID.Schema, targetUid: UID.ContentType, locale?: string) => {\n  const sourceModel = strapi.getModel(sourceUid);\n  const targetModel = strapi.getModel(targetUid);\n\n  const isLocalized = strapi.plugin('i18n').service('content-types').isLocalizedContentType;\n  const isSourceLocalized = isLocalized(sourceModel);\n  const isTargetLocalized = isLocalized(targetModel);\n\n  return {\n    locale,\n    isSourceLocalized,\n    isTargetLocalized,\n  };\n};\n\nconst validateStatus = (\n  sourceUid: UID.Schema,\n  status?: Modules.Documents.Params.PublicationStatus.Kind\n) => {\n  const sourceModel = strapi.getModel(sourceUid);\n\n  const isDP = contentTypes.hasDraftAndPublish;\n  const isSourceDP = isDP(sourceModel);\n\n  // Default to draft if not set\n  if (!isSourceDP) return { status: undefined };\n\n  switch (status) {\n    case 'published':\n      return { status: 'published' };\n    default:\n      // Assign to draft if the status is not valid\n      return { status: 'draft' };\n  }\n};\n\nexport default {\n  async extractAndValidateRequestInfo(ctx: any, id?: Data.ID) {\n    const { userAbility } = ctx.state;\n    const { model, targetField } = ctx.params;\n\n    const sourceSchema = strapi.getModel(model);\n    if (!sourceSchema) {\n      throw new errors.ValidationError(`The model ${model} doesn't exist`);\n    }\n\n    const attribute: any = sourceSchema.attributes[targetField];\n    if (!attribute || attribute.type !== 'relation') {\n      throw new errors.ValidationError(\n        `The relational field ${targetField} doesn't exist on ${model}`\n      );\n    }\n\n    const sourceUid = model;\n    const targetUid = attribute.target;\n\n    const { locale, isSourceLocalized, isTargetLocalized } = validateLocale(\n      sourceUid,\n      targetUid,\n      ctx.request?.query?.locale\n    );\n    const { status } = validateStatus(sourceUid, ctx.request?.query?.status);\n\n    const permissionChecker = getService('permission-checker').create({\n      userAbility,\n      model,\n    });\n\n    const isComponent = sourceSchema.modelType === 'component';\n    if (!isComponent) {\n      if (permissionChecker.cannot.read(null, targetField)) {\n        return ctx.forbidden();\n      }\n    }\n\n    let entryId: string | number | null = null;\n\n    if (id) {\n      const where: Record<string, any> = {};\n\n      if (!isComponent) {\n        where.documentId = id;\n\n        if (status) {\n          where.publishedAt = getPublishedAtClause(status, sourceUid);\n        }\n\n        if (locale && isSourceLocalized) {\n          where.locale = locale;\n        }\n      } else {\n        // If the source is a component, we only need to filter by the\n        // component's entity id\n        where.id = id;\n      }\n\n      const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);\n      const populate = await getService('populate-builder')(model)\n        .populateFromQuery(permissionQuery)\n        .build();\n\n      const currentEntity = await strapi.db.query(model).findOne({\n        where,\n        populate,\n      });\n\n      // We need to check if the entity exists\n      // and if the user has the permission to read it in this way\n      // There may be multiple entities (publication states) under this\n      // documentId + locale. We only need to check if one exists\n      if (!currentEntity) {\n        throw new errors.NotFoundError();\n      }\n\n      if (!isComponent) {\n        if (permissionChecker.cannot.read(currentEntity, targetField)) {\n          throw new errors.ForbiddenError();\n        }\n      }\n\n      entryId = currentEntity.id;\n    }\n\n    const modelConfig = isComponent\n      ? await getService('components').findConfiguration(sourceSchema)\n      : await getService('content-types').findConfiguration(sourceSchema);\n\n    const targetSchema = strapi.getModel(targetUid);\n\n    const mainField = flow(\n      prop(`metadatas.${targetField}.edit.mainField`),\n      (mainField) => mainField || 'id',\n      (mainField) => sanitizeMainField(targetSchema, mainField, userAbility)\n    )(modelConfig);\n\n    const fieldsToSelect = uniq([\n      mainField,\n      PUBLISHED_AT_ATTRIBUTE,\n      UPDATED_AT_ATTRIBUTE,\n      'documentId',\n    ]);\n\n    if (isTargetLocalized) {\n      fieldsToSelect.push('locale');\n    }\n\n    return {\n      entryId,\n      locale,\n      status,\n      attribute,\n      fieldsToSelect,\n      mainField,\n      source: { schema: sourceSchema, isLocalized: isSourceLocalized },\n      target: { schema: targetSchema, isLocalized: isTargetLocalized },\n      sourceSchema,\n      targetSchema,\n      targetField,\n    };\n  },\n\n  /**\n   * Used to find new relations to add in a relational field.\n   *\n   * Component and document relations are dealt a bit differently (they don't have a document_id).\n   */\n  async findAvailable(ctx: any) {\n    const { id } = ctx.request.query;\n\n    await validateFindAvailable(ctx.request.query);\n\n    const {\n      locale,\n      status,\n      targetField,\n      fieldsToSelect,\n      mainField,\n      source: {\n        schema: { uid: sourceUid, modelType: sourceModelType },\n        isLocalized: isSourceLocalized,\n      },\n      target: {\n        schema: { uid: targetUid },\n        isLocalized: isTargetLocalized,\n      },\n    } = await this.extractAndValidateRequestInfo(ctx, id);\n\n    const { idsToOmit, idsToInclude, _q, ...query } = ctx.request.query;\n\n    const permissionChecker = getService('permission-checker').create({\n      userAbility: ctx.state.userAbility,\n      model: targetUid,\n    });\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(query);\n\n    const queryParams = {\n      sort: mainField,\n      // cannot select other fields as the user may not have the permissions\n      fields: fieldsToSelect,\n      ...permissionQuery,\n    };\n\n    // If no status is requested, we find all the draft relations and later update them\n    // with the latest available status\n    addFiltersClause(queryParams, {\n      publishedAt: getPublishedAtClause(status, targetUid),\n    });\n\n    // We will only filter by locale if the target content type is localized\n    const filterByLocale = isTargetLocalized && locale;\n    if (filterByLocale) {\n      addFiltersClause(queryParams, { locale });\n    }\n\n    if (id) {\n      /**\n       * Exclude the relations that are already related to the source\n       *\n       * We also optionally filter the target relations by the requested\n       * status and locale if provided.\n       */\n      const subQuery = strapi.db.queryBuilder(sourceUid);\n\n      // The alias refers to the DB table of the target content type model\n      const alias = subQuery.getAlias();\n\n      const where: Record<string, any> = {\n        [`${alias}.id`]: { $notNull: true },\n        [`${alias}.document_id`]: { $notNull: true },\n      };\n\n      /**\n       * Content Types -> Specify document id\n       * Components    -> Specify entity id (they don't have a document id)\n       */\n      if (sourceModelType === 'contentType') {\n        where.document_id = id;\n      } else {\n        where.id = id;\n      }\n\n      // Add the status and locale filters if they are provided\n      const publishedAt = getPublishedAtClause(status, targetUid);\n      if (!isEmpty(publishedAt)) {\n        where[`${alias}.published_at`] = publishedAt;\n      }\n\n      // If target has localization we need to filter by locale\n      if (isTargetLocalized && locale) {\n        where[`${alias}.locale`] = locale;\n      }\n\n      if (isSourceLocalized && locale) {\n        where.locale = locale;\n      }\n\n      /**\n       * UI can provide a list of ids to omit,\n       * those are the relations user set in the UI but has not persisted.\n       * We don't want to include them in the available relations.\n       */\n      if ((idsToInclude?.length ?? 0) !== 0) {\n        where[`${alias}.id`].$notIn = idsToInclude;\n      }\n\n      const knexSubQuery = subQuery\n        .where(where)\n        .join({ alias, targetField })\n        .select(`${alias}.id`)\n        .getKnexQuery();\n\n      addFiltersClause(queryParams, {\n        id: { $notIn: knexSubQuery },\n      });\n    }\n\n    /**\n     * Apply a filter to the mainField based on the search query and filter operator\n     * searching should be allowed only on mainField for permission reasons\n     */\n    if (_q) {\n      const _filter = isOperatorOfType('where', query._filter) ? query._filter : '$containsi';\n      addFiltersClause(queryParams, { [mainField]: { [_filter]: _q } });\n    }\n\n    if (idsToOmit?.length > 0) {\n      // If we have ids to omit, we should filter them out\n      addFiltersClause(queryParams, {\n        id: { $notIn: uniq(idsToOmit) },\n      });\n    }\n\n    const dbQuery = strapi.get('query-params').transform(targetUid, queryParams);\n\n    const res = await strapi.db.query(targetUid).findPage(dbQuery);\n\n    ctx.body = {\n      ...res,\n      results: await addStatusToRelations(targetUid, res.results),\n    };\n  },\n\n  async findExisting(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { id } = ctx.params;\n\n    await validateFindExisting(ctx.request.query);\n\n    const {\n      entryId,\n      attribute,\n      targetField,\n      fieldsToSelect,\n      status,\n      source: { schema: sourceSchema },\n      target: { schema: targetSchema },\n    } = await this.extractAndValidateRequestInfo(ctx, id);\n\n    const { uid: sourceUid } = sourceSchema;\n    const { uid: targetUid } = targetSchema;\n\n    const permissionQuery = await getService('permission-checker')\n      .create({ userAbility, model: targetUid })\n      .sanitizedQuery.read({ fields: fieldsToSelect });\n\n    /**\n     * loadPages can not be used for single relations,\n     * this unifies the loading regardless of it's type\n     *\n     * NOTE: Relations need to be loaded using any db.query method\n     *       to ensure the proper ordering is applied\n     */\n    const dbQuery = strapi.db.query(sourceUid);\n    const loadRelations = relations.isAnyToMany(attribute)\n      ? (...args: Parameters<typeof dbQuery.loadPages>) => dbQuery.loadPages(...args)\n      : (...args: Parameters<typeof dbQuery.load>) =>\n          dbQuery\n            .load(...args)\n            // Ensure response is an array\n            .then((res) => ({ results: res ? [res] : [] }));\n\n    const filters: {\n      publishedAt?: Record<string, any>;\n    } = {};\n\n    if (sourceSchema?.options?.draftAndPublish) {\n      if (targetSchema?.options?.draftAndPublish) {\n        if (status === 'published') {\n          filters.publishedAt = { $notNull: true };\n        } else {\n          filters.publishedAt = { $null: true };\n        }\n      }\n    } else if (targetSchema?.options?.draftAndPublish) {\n      // NOTE: we must return the drafts as some targets might not have a published version yet\n      filters.publishedAt = { $null: true };\n    }\n\n    /**\n     * If user does not have access to specific relations (custom conditions),\n     * only the ids of the relations are returned.\n     *\n     * - First query loads all the ids.\n     * - Second one also loads the main field, and excludes forbidden relations.\n     *\n     * The response contains the union of the two queries.\n     */\n    const res = await loadRelations({ id: entryId }, targetField, {\n      select: ['id', 'documentId', 'locale', 'publishedAt', 'updatedAt'],\n      ordering: 'desc',\n      page: ctx.request.query.page,\n      pageSize: ctx.request.query.pageSize,\n      filters,\n    });\n\n    /**\n     * Add all ids to load in permissionQuery\n     * If any of the relations are not accessible, the permissionQuery will exclude them\n     */\n    const loadedIds = res.results.map((item: any) => item.id);\n    addFiltersClause(permissionQuery, { id: { $in: loadedIds } });\n\n    /**\n     * Load the relations with the main field, the sanitized permission query\n     * will exclude the relations the user does not have access to.\n     *\n     * Pagination is not necessary as the permissionQuery contains the ids to load.\n     */\n    const sanitizedRes = await loadRelations({ id: entryId }, targetField, {\n      ...strapi.get('query-params').transform(targetUid, permissionQuery),\n      ordering: 'desc',\n    });\n\n    // NOTE: the order is very import to make sure sanitized relations are kept in priority\n    const relationsUnion = uniqBy('id', concat(sanitizedRes.results, res.results));\n\n    ctx.body = {\n      pagination: res.pagination || {\n        page: 1,\n        pageCount: 1,\n        pageSize: 10,\n        total: relationsUnion.length,\n      },\n      results: await addStatusToRelations(targetUid, relationsUnion),\n    };\n  },\n};\n"],"names":["PUBLISHED_AT_ATTRIBUTE","UPDATED_AT_ATTRIBUTE","contentTypes","constants","addFiltersClause","params","filtersClause","filters","$and","push","sanitizeMainField","model","mainField","userAbility","permissionChecker","getService","create","uid","isMainFieldListable","isListable","canReadMainField","can","read","addStatusToRelations","targetUid","relations","hasDraftAndPublish","strapi","getModel","documentMetadata","length","firstRelation","documentId","$in","map","r","publishedAt","$null","$notNull","availableStatus","query","findMany","select","relation","availableStatuses","filter","availableDocument","locale","status","getStatus","getPublishedAtClause","validateLocale","sourceUid","sourceModel","targetModel","isLocalized","plugin","service","isLocalizedContentType","isSourceLocalized","isTargetLocalized","validateStatus","isDP","isSourceDP","undefined","extractAndValidateRequestInfo","ctx","id","state","targetField","sourceSchema","errors","ValidationError","attribute","attributes","type","target","request","isComponent","modelType","cannot","forbidden","entryId","where","permissionQuery","sanitizedQuery","populate","populateFromQuery","build","currentEntity","db","findOne","NotFoundError","ForbiddenError","modelConfig","findConfiguration","targetSchema","flow","prop","fieldsToSelect","uniq","source","schema","findAvailable","validateFindAvailable","sourceModelType","idsToOmit","idsToInclude","_q","queryParams","sort","fields","filterByLocale","subQuery","queryBuilder","alias","getAlias","document_id","isEmpty","$notIn","knexSubQuery","join","getKnexQuery","_filter","isOperatorOfType","dbQuery","get","transform","res","findPage","body","results","findExisting","validateFindExisting","loadRelations","isAnyToMany","args","loadPages","load","then","options","draftAndPublish","ordering","page","pageSize","loadedIds","item","sanitizedRes","relationsUnion","uniqBy","concat","pagination","pageCount","total"],"mappings":"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"}