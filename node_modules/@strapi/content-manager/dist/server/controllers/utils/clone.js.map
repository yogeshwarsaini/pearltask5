{"version":3,"file":"clone.js","sources":["../../../../server/src/controllers/utils/clone.ts"],"sourcesContent":["import { set } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\nimport { ProhibitedCloningField } from '../../../../shared/contracts/collection-types';\n\nconst { isVisibleAttribute } = strapiUtils.contentTypes;\n\n/**\n * Use an array of strings to represent the path to a field, so we can show breadcrumbs in the admin\n * We can't use special characters as delimiters, because the path includes display names\n * for dynamic zone components, which can contain any character.\n */\n\nfunction checkRelation(model: any, attributeName: any, path: string[]): ProhibitedCloningField[] {\n  // we don't care about createdBy, updatedBy, localizations etc.\n  if (!isVisibleAttribute(model, attributeName)) {\n    // Return empty array and not null so we can always spread the result\n    return [];\n  }\n\n  /**\n   * Only one-to-many and one-to-one (when they're reversed, not one-way) are dangerous,\n   * because the other relations don't \"steal\" the relation from the entry we're cloning\n   */\n  const { relation, inversedBy, mappedBy } = model.attributes[attributeName];\n\n  if (\n    ['oneToOne', 'oneToMany'].includes(relation) &&\n    [mappedBy, inversedBy].some((key) => key != null)\n  ) {\n    return [[[...path, attributeName], 'relation']];\n  }\n\n  return [];\n}\n\nconst getProhibitedCloningFields = (\n  uid: any,\n  pathPrefix: string[] = []\n): ProhibitedCloningField[] => {\n  const model = strapi.getModel(uid);\n\n  const prohibitedFields = Object.keys(model.attributes).reduce<ProhibitedCloningField[]>(\n    (acc, attributeName) => {\n      const attribute: any = model.attributes[attributeName];\n      const attributePath = [...pathPrefix, attributeName];\n\n      switch (attribute.type) {\n        case 'relation':\n          return [...acc, ...checkRelation(model, attributeName, pathPrefix)];\n        case 'component':\n          return [...acc, ...getProhibitedCloningFields(attribute.component, attributePath)];\n        case 'dynamiczone':\n          return [\n            ...acc,\n            ...(attribute.components || []).flatMap((componentUID: any) =>\n              getProhibitedCloningFields(componentUID, [\n                ...attributePath,\n                strapi.getModel(componentUID).info.displayName,\n              ])\n            ),\n          ];\n        case 'uid':\n          return [...acc, [attributePath, 'unique']];\n        default:\n          if (attribute?.unique) {\n            return [...acc, [attributePath, 'unique']];\n          }\n          return acc;\n      }\n    },\n    []\n  );\n\n  return prohibitedFields;\n};\n\n/**\n * Iterates all attributes of the content type, and removes the ones that are not creatable.\n *   - If it's a relation, it sets the value to [] or null.\n *   - If it's a regular attribute, it sets the value to null.\n * When cloning, if you don't set a field it will be copied from the original entry. So we need to\n * remove the fields that the user can't create.\n */\nconst excludeNotCreatableFields =\n  (uid: any, permissionChecker: any) =>\n  (body: any, path = []): any => {\n    const model = strapi.getModel(uid);\n    const canCreate = (path: any) => permissionChecker.can.create(null, path);\n\n    return Object.keys(model.attributes).reduce((body, attributeName) => {\n      const attribute = model.attributes[attributeName];\n      const attributePath = [...path, attributeName].join('.');\n\n      // Ignore the attribute if it's not visible\n      if (!isVisibleAttribute(model, attributeName)) {\n        return body;\n      }\n\n      switch (attribute.type) {\n        // Relation should be empty if the user can't create it\n        case 'relation': {\n          if (canCreate(attributePath)) return body;\n          return set(attributePath, { set: [] }, body);\n        }\n        // Go deeper into the component\n        case 'component': {\n          return excludeNotCreatableFields(attribute.component, permissionChecker)(body, [\n            ...path,\n            attributeName,\n          ] as any);\n        }\n        // Attribute should be null if the user can't create it\n        default: {\n          if (canCreate(attributePath)) return body;\n          return set(attributePath, null, body);\n        }\n      }\n    }, body);\n  };\n\nexport { getProhibitedCloningFields, excludeNotCreatableFields };\n"],"names":["isVisibleAttribute","strapiUtils","contentTypes","checkRelation","model","attributeName","path","relation","inversedBy","mappedBy","attributes","includes","some","key","getProhibitedCloningFields","uid","pathPrefix","strapi","getModel","prohibitedFields","Object","keys","reduce","acc","attribute","attributePath","type","component","components","flatMap","componentUID","info","displayName","unique","excludeNotCreatableFields","permissionChecker","body","canCreate","can","create","join","set"],"mappings":";;;;;AAIA,MAAM,EAAEA,kBAAkB,EAAE,GAAGC,YAAYC,YAAY;AAEvD;;;;AAIC,IAED,SAASC,aAAcC,CAAAA,KAAU,EAAEC,aAAkB,EAAEC,IAAc,EAAA;;IAEnE,IAAI,CAACN,kBAAmBI,CAAAA,KAAAA,EAAOC,aAAgB,CAAA,EAAA;;AAE7C,QAAA,OAAO,EAAE;AACX;AAEA;;;AAGC,MACD,MAAM,EAAEE,QAAQ,EAAEC,UAAU,EAAEC,QAAQ,EAAE,GAAGL,KAAAA,CAAMM,UAAU,CAACL,aAAc,CAAA;IAE1E,IACE;AAAC,QAAA,UAAA;AAAY,QAAA;KAAY,CAACM,QAAQ,CAACJ,QACnC,CAAA,IAAA;AAACE,QAAAA,QAAAA;AAAUD,QAAAA;AAAW,KAAA,CAACI,IAAI,CAAC,CAACC,GAAAA,GAAQA,OAAO,IAC5C,CAAA,EAAA;QACA,OAAO;AAAC,YAAA;AAAC,gBAAA;AAAIP,oBAAAA,GAAAA,IAAAA;AAAMD,oBAAAA;AAAc,iBAAA;AAAE,gBAAA;AAAW;AAAC,SAAA;AACjD;AAEA,IAAA,OAAO,EAAE;AACX;AAEA,MAAMS,0BAA6B,GAAA,CACjCC,GACAC,EAAAA,UAAAA,GAAuB,EAAE,GAAA;IAEzB,MAAMZ,KAAAA,GAAQa,MAAOC,CAAAA,QAAQ,CAACH,GAAAA,CAAAA;IAE9B,MAAMI,gBAAAA,GAAmBC,MAAOC,CAAAA,IAAI,CAACjB,KAAAA,CAAMM,UAAU,CAAEY,CAAAA,MAAM,CAC3D,CAACC,GAAKlB,EAAAA,aAAAA,GAAAA;AACJ,QAAA,MAAMmB,SAAiBpB,GAAAA,KAAAA,CAAMM,UAAU,CAACL,aAAc,CAAA;AACtD,QAAA,MAAMoB,aAAgB,GAAA;AAAIT,YAAAA,GAAAA,UAAAA;AAAYX,YAAAA;AAAc,SAAA;AAEpD,QAAA,OAAQmB,UAAUE,IAAI;YACpB,KAAK,UAAA;gBACH,OAAO;AAAIH,oBAAAA,GAAAA,GAAAA;AAAQpB,oBAAAA,GAAAA,aAAAA,CAAcC,OAAOC,aAAeW,EAAAA,UAAAA;AAAY,iBAAA;YACrE,KAAK,WAAA;gBACH,OAAO;AAAIO,oBAAAA,GAAAA,GAAAA;uBAAQT,0BAA2BU,CAAAA,SAAAA,CAAUG,SAAS,EAAEF,aAAAA;AAAe,iBAAA;YACpF,KAAK,aAAA;gBACH,OAAO;AACFF,oBAAAA,GAAAA,GAAAA;AACA,oBAAA,GAACC,CAAAA,SAAAA,CAAUI,UAAU,IAAI,EAAC,EAAGC,OAAO,CAAC,CAACC,YACvChB,GAAAA,0BAAAA,CAA2BgB,YAAc,EAAA;AACpCL,4BAAAA,GAAAA,aAAAA;AACHR,4BAAAA,MAAAA,CAAOC,QAAQ,CAACY,YAAcC,CAAAA,CAAAA,IAAI,CAACC;AACpC,yBAAA,CAAA;AAEJ,iBAAA;YACH,KAAK,KAAA;gBACH,OAAO;AAAIT,oBAAAA,GAAAA,GAAAA;AAAK,oBAAA;AAACE,wBAAAA,aAAAA;AAAe,wBAAA;AAAS;AAAC,iBAAA;AAC5C,YAAA;AACE,gBAAA,IAAID,WAAWS,MAAQ,EAAA;oBACrB,OAAO;AAAIV,wBAAAA,GAAAA,GAAAA;AAAK,wBAAA;AAACE,4BAAAA,aAAAA;AAAe,4BAAA;AAAS;AAAC,qBAAA;AAC5C;gBACA,OAAOF,GAAAA;AACX;AACF,KAAA,EACA,EAAE,CAAA;IAGJ,OAAOJ,gBAAAA;AACT;AAEA;;;;;;IAOA,MAAMe,4BACJ,CAACnB,GAAAA,EAAUoB,oBACX,CAACC,IAAAA,EAAW9B,OAAO,EAAE,GAAA;QACnB,MAAMF,KAAAA,GAAQa,MAAOC,CAAAA,QAAQ,CAACH,GAAAA,CAAAA;QAC9B,MAAMsB,SAAAA,GAAY,CAAC/B,IAAc6B,GAAAA,iBAAAA,CAAkBG,GAAG,CAACC,MAAM,CAAC,IAAMjC,EAAAA,IAAAA,CAAAA;QAEpE,OAAOc,MAAAA,CAAOC,IAAI,CAACjB,KAAAA,CAAMM,UAAU,CAAEY,CAAAA,MAAM,CAAC,CAACc,IAAM/B,EAAAA,aAAAA,GAAAA;AACjD,YAAA,MAAMmB,SAAYpB,GAAAA,KAAAA,CAAMM,UAAU,CAACL,aAAc,CAAA;AACjD,YAAA,MAAMoB,aAAgB,GAAA;AAAInB,gBAAAA,GAAAA,IAAAA;AAAMD,gBAAAA;AAAc,aAAA,CAACmC,IAAI,CAAC,GAAA,CAAA;;YAGpD,IAAI,CAACxC,kBAAmBI,CAAAA,KAAAA,EAAOC,aAAgB,CAAA,EAAA;gBAC7C,OAAO+B,IAAAA;AACT;AAEA,YAAA,OAAQZ,UAAUE,IAAI;;gBAEpB,KAAK,UAAA;AAAY,oBAAA;wBACf,IAAIW,SAAAA,CAAUZ,gBAAgB,OAAOW,IAAAA;AACrC,wBAAA,OAAOK,OAAIhB,aAAe,EAAA;AAAEgB,4BAAAA,GAAAA,EAAK;yBAAML,EAAAA,IAAAA,CAAAA;AACzC;;gBAEA,KAAK,WAAA;AAAa,oBAAA;AAChB,wBAAA,OAAOF,yBAA0BV,CAAAA,SAAAA,CAAUG,SAAS,EAAEQ,mBAAmBC,IAAM,EAAA;AAC1E9B,4BAAAA,GAAAA,IAAAA;AACHD,4BAAAA;AACD,yBAAA,CAAA;AACH;;AAEA,gBAAA;AAAS,oBAAA;wBACP,IAAIgC,SAAAA,CAAUZ,gBAAgB,OAAOW,IAAAA;wBACrC,OAAOK,MAAAA,CAAIhB,eAAe,IAAMW,EAAAA,IAAAA,CAAAA;AAClC;AACF;SACCA,EAAAA,IAAAA,CAAAA;AACL;;;;;"}