{"version":3,"file":"Auth.js","sources":["../../../../../admin/src/features/Auth.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport { useLocation, useNavigate } from 'react-router-dom';\n\nimport { Login } from '../../../shared/contracts/authentication';\nimport { createContext } from '../components/Context';\nimport { useTypedDispatch, useTypedSelector } from '../core/store/hooks';\nimport { useStrapiApp } from '../features/StrapiApp';\nimport { useQueryParams } from '../hooks/useQueryParams';\nimport { login as loginAction, logout as logoutAction, setLocale } from '../reducer';\nimport { adminApi } from '../services/api';\nimport {\n  useGetMeQuery,\n  useGetMyPermissionsQuery,\n  useLazyCheckPermissionsQuery,\n  useLoginMutation,\n  useLogoutMutation,\n  useRenewTokenMutation,\n} from '../services/auth';\n\nimport type {\n  Permission as PermissionContract,\n  SanitizedAdminUser,\n} from '../../../shared/contracts/shared';\n\ninterface Permission\n  extends Pick<PermissionContract, 'action' | 'subject'>,\n    Partial<Omit<PermissionContract, 'action' | 'subject'>> {}\n\ninterface User\n  extends Pick<SanitizedAdminUser, 'email' | 'firstname' | 'lastname' | 'username' | 'roles'>,\n    Partial<Omit<SanitizedAdminUser, 'email' | 'firstname' | 'lastname' | 'username' | 'roles'>> {}\n\ninterface AuthContextValue {\n  login: (\n    body: Login.Request['body'] & { rememberMe: boolean }\n  ) => Promise<Awaited<ReturnType<ReturnType<typeof useLoginMutation>[0]>>>;\n  logout: () => Promise<void>;\n  /**\n   * @alpha\n   * @description given a list of permissions, this function checks\n   * those against the current user's permissions or those passed as\n   * the second argument, if the user has those permissions the complete\n   * permission object form the API is returned. Therefore, if the list is\n   * empty, the user does not have any of those permissions.\n   */\n  checkUserHasPermissions: (\n    permissions?: Array<Pick<Permission, 'action'> & Partial<Omit<Permission, 'action'>>>,\n    passedPermissions?: Permission[],\n    rawQueryContext?: string\n  ) => Promise<Permission[]>;\n  isLoading: boolean;\n  permissions: Permission[];\n  refetchPermissions: () => Promise<void>;\n  token: string | null;\n  user?: User;\n}\n\nconst [Provider, useAuth] = createContext<AuthContextValue>('Auth');\n\ninterface AuthProviderProps {\n  children: React.ReactNode;\n  /**\n   * @internal could be removed at any time.\n   */\n  _defaultPermissions?: Permission[];\n\n  // NOTE: this is used for testing purposed only\n  _disableRenewToken?: boolean;\n}\n\nconst STORAGE_KEYS = {\n  TOKEN: 'jwtToken',\n  STATUS: 'isLoggedIn',\n};\n\nconst AuthProvider = ({\n  children,\n  _defaultPermissions = [],\n  _disableRenewToken = false,\n}: AuthProviderProps) => {\n  const dispatch = useTypedDispatch();\n  const runRbacMiddleware = useStrapiApp('AuthProvider', (state) => state.rbac.run);\n  const location = useLocation();\n  const [{ rawQuery }] = useQueryParams();\n\n  const locationRef = React.useRef(location);\n\n  // Update ref without causing re-render\n  React.useEffect(() => {\n    locationRef.current = location;\n  }, [location]);\n\n  const token = useTypedSelector((state) => state.admin_app.token ?? null);\n\n  const { data: user, isLoading: isLoadingUser } = useGetMeQuery(undefined, {\n    /**\n     * If there's no token, we don't try to fetch\n     * the user data because it will fail.\n     */\n    skip: !token,\n  });\n\n  const {\n    data: userPermissions = _defaultPermissions,\n    refetch,\n    isUninitialized,\n    isLoading: isLoadingPermissions,\n  } = useGetMyPermissionsQuery(undefined, {\n    skip: !token,\n  });\n\n  const navigate = useNavigate();\n\n  const [loginMutation] = useLoginMutation();\n  const [renewTokenMutation] = useRenewTokenMutation();\n  const [logoutMutation] = useLogoutMutation();\n\n  const clearStateAndLogout = React.useCallback(() => {\n    dispatch(adminApi.util.resetApiState());\n    dispatch(logoutAction());\n    navigate('/auth/login');\n  }, [dispatch, navigate]);\n\n  /**\n   * Fetch data from storages on mount and store it in our state.\n   * It's not normally stored in session storage unless the user\n   * does click \"remember me\" when they login. We also need to renew the token.\n   */\n  React.useEffect(() => {\n    if (token && !_disableRenewToken) {\n      renewTokenMutation({ token }).then((res) => {\n        if ('data' in res) {\n          dispatch(\n            loginAction({\n              token: res.data.token,\n            })\n          );\n        } else {\n          clearStateAndLogout();\n        }\n      });\n    }\n  }, [token, dispatch, renewTokenMutation, clearStateAndLogout, _disableRenewToken]);\n\n  React.useEffect(() => {\n    if (user) {\n      if (user.preferedLanguage) {\n        dispatch(setLocale(user.preferedLanguage));\n      }\n    }\n  }, [dispatch, user]);\n\n  React.useEffect(() => {\n    /**\n     * This will log a user out of all tabs if they log out in one tab.\n     */\n    const handleUserStorageChange = (event: StorageEvent) => {\n      if (event.key === STORAGE_KEYS.STATUS && event.newValue === null) {\n        clearStateAndLogout();\n      }\n    };\n\n    window.addEventListener('storage', handleUserStorageChange);\n\n    return () => {\n      window.removeEventListener('storage', handleUserStorageChange);\n    };\n  });\n\n  const login = React.useCallback<AuthContextValue['login']>(\n    async ({ rememberMe, ...body }) => {\n      const res = await loginMutation(body);\n\n      /**\n       * There will always be a `data` key in the response\n       * because if something fails, it will throw an error.\n       */\n      if ('data' in res) {\n        const { token } = res.data;\n\n        dispatch(\n          loginAction({\n            token,\n            persist: rememberMe,\n          })\n        );\n      }\n\n      return res;\n    },\n    [dispatch, loginMutation]\n  );\n\n  const logout = React.useCallback(async () => {\n    await logoutMutation();\n    clearStateAndLogout();\n  }, [clearStateAndLogout, logoutMutation]);\n\n  const refetchPermissions = React.useCallback(async () => {\n    if (!isUninitialized) {\n      await refetch();\n    }\n  }, [isUninitialized, refetch]);\n\n  const [checkPermissions] = useLazyCheckPermissionsQuery();\n  const checkUserHasPermissions: AuthContextValue['checkUserHasPermissions'] = React.useCallback(\n    async (\n      permissions,\n      passedPermissions,\n      // TODO:\n      // Here we have parameterised checkUserHasPermissions in order to pass\n      // query context from elsewhere in the application.\n      // See packages/core/content-manager/admin/src/features/DocumentRBAC.tsx\n\n      // This is in order to calculate permissions on accurate query params.\n      // We should be able to rely on the query params in this provider\n      // If we need to pass additional context to the RBAC middleware\n      // we should define a better context type.\n      rawQueryContext\n    ) => {\n      /**\n       * If there's no permissions to check, then we allow it to\n       * pass to preserve existing behaviours.\n       *\n       * TODO: should we review this? it feels more dangerous than useful.\n       */\n      if (!permissions || permissions.length === 0) {\n        return [{ action: '', subject: '' }];\n      }\n\n      /**\n       * Given the provided permissions, return the permissions from either passedPermissions\n       * or userPermissions as this is expected to be the full permission entity.\n       */\n      const actualUserPermissions = passedPermissions ?? userPermissions;\n\n      const matchingPermissions = actualUserPermissions.filter(\n        (permission) =>\n          permissions.findIndex(\n            (perm) =>\n              perm.action === permission.action &&\n              // Only check the subject if it's provided\n              (perm.subject == undefined || perm.subject === permission.subject)\n          ) >= 0\n      );\n\n      const middlewaredPermissions = await runRbacMiddleware(\n        {\n          user,\n          permissions: userPermissions,\n          pathname: locationRef.current.pathname,\n          search: (rawQueryContext || rawQuery).split('?')[1] ?? '',\n        },\n        matchingPermissions\n      );\n\n      const shouldCheckConditions = middlewaredPermissions.some(\n        (perm) => Array.isArray(perm.conditions) && perm.conditions.length > 0\n      );\n\n      if (!shouldCheckConditions) {\n        return middlewaredPermissions;\n      }\n\n      const { data, error } = await checkPermissions({\n        permissions: middlewaredPermissions.map((perm) => ({\n          action: perm.action,\n          subject: perm.subject,\n        })),\n      });\n\n      if (error) {\n        throw error;\n      } else {\n        return middlewaredPermissions.filter((_, index) => data?.data[index] === true);\n      }\n    },\n    [checkPermissions, rawQuery, runRbacMiddleware, user, userPermissions]\n  );\n\n  const isLoading = isLoadingUser || isLoadingPermissions;\n\n  return (\n    <Provider\n      token={token}\n      user={user}\n      login={login}\n      logout={logout}\n      permissions={userPermissions}\n      checkUserHasPermissions={checkUserHasPermissions}\n      refetchPermissions={refetchPermissions}\n      isLoading={isLoading}\n    >\n      {children}\n    </Provider>\n  );\n};\n\nexport { AuthProvider, useAuth, STORAGE_KEYS };\nexport type { AuthContextValue, Permission, User };\n"],"names":["Provider","useAuth","createContext","STORAGE_KEYS","TOKEN","STATUS","AuthProvider","children","_defaultPermissions","_disableRenewToken","dispatch","useTypedDispatch","runRbacMiddleware","useStrapiApp","state","rbac","run","location","useLocation","rawQuery","useQueryParams","locationRef","React","useRef","useEffect","current","token","useTypedSelector","admin_app","data","user","isLoading","isLoadingUser","useGetMeQuery","undefined","skip","userPermissions","refetch","isUninitialized","isLoadingPermissions","useGetMyPermissionsQuery","navigate","useNavigate","loginMutation","useLoginMutation","renewTokenMutation","useRenewTokenMutation","logoutMutation","useLogoutMutation","clearStateAndLogout","useCallback","adminApi","util","resetApiState","logoutAction","then","res","loginAction","preferedLanguage","setLocale","handleUserStorageChange","event","key","newValue","window","addEventListener","removeEventListener","login","rememberMe","body","persist","logout","refetchPermissions","checkPermissions","useLazyCheckPermissionsQuery","checkUserHasPermissions","permissions","passedPermissions","rawQueryContext","length","action","subject","actualUserPermissions","matchingPermissions","filter","permission","findIndex","perm","middlewaredPermissions","pathname","search","split","shouldCheckConditions","some","Array","isArray","conditions","error","map","_","index","_jsx"],"mappings":"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"}