{"version":3,"file":"getFetchClient.js","sources":["../../../../../admin/src/utils/getFetchClient.ts"],"sourcesContent":["import pipe from 'lodash/fp/pipe';\nimport qs from 'qs';\n\nimport { getCookieValue } from './cookies';\n\nimport type { errors } from '@strapi/utils';\n\nexport type ApiError =\n  | errors.ApplicationError\n  | errors.ForbiddenError\n  | errors.NotFoundError\n  | errors.NotImplementedError\n  | errors.PaginationError\n  | errors.PayloadTooLargeError\n  | errors.PolicyError\n  | errors.RateLimitError\n  | errors.UnauthorizedError\n  | errors.ValidationError\n  | errors.YupValidationError;\n\nconst STORAGE_KEYS = {\n  TOKEN: 'jwtToken',\n  USER: 'userInfo',\n};\n\ntype FetchResponse<TData = any> = {\n  data: TData;\n  status?: number;\n};\n\ntype FetchOptions = {\n  params?: any;\n  signal?: AbortSignal;\n  headers?: Record<string, string>;\n  validateStatus?: ((status: number) => boolean) | null;\n};\n\ntype FetchConfig = {\n  signal?: AbortSignal;\n};\n\ninterface ErrorResponse {\n  data: {\n    data?: any;\n    error: ApiError & { status?: number };\n  };\n}\n\nclass FetchError extends Error {\n  public name: string;\n  public message: string;\n  public response?: ErrorResponse;\n  public code?: number;\n  public status?: number;\n\n  constructor(message: string, response?: ErrorResponse) {\n    super(message);\n    this.name = 'FetchError';\n    this.message = message;\n    this.response = response;\n    this.code = response?.data?.error?.status;\n    this.status = response?.data?.error?.status;\n\n    // Ensure correct stack trace in error object\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FetchError);\n    }\n  }\n}\n\nconst isFetchError = (error: unknown): error is FetchError => {\n  return error instanceof FetchError;\n};\n\nconst getToken = (): string | null => {\n  const fromLocalStorage = localStorage.getItem(STORAGE_KEYS.TOKEN);\n  if (fromLocalStorage) {\n    return JSON.parse(fromLocalStorage);\n  }\n\n  const fromCookie = getCookieValue(STORAGE_KEYS.TOKEN);\n  return fromCookie ?? null;\n};\n\ntype FetchClient = {\n  get: <TData = any>(url: string, config?: FetchOptions) => Promise<FetchResponse<TData>>;\n  put: <TData = any, TSend = any>(\n    url: string,\n    data?: TSend,\n    config?: FetchOptions\n  ) => Promise<FetchResponse<TData>>;\n  post: <TData = any, TSend = any>(\n    url: string,\n    data?: TSend,\n    config?: FetchOptions\n  ) => Promise<FetchResponse<TData>>;\n  del: <TData = any>(url: string, config?: FetchOptions) => Promise<FetchResponse<TData>>;\n};\n\n/**\n * @public\n * @param {FetchConfig} [defaultOptions={}] - Fetch Configs.\n * @returns {FetchClient} A fetch client object with methods for making HTTP requests.\n * @description This is an abstraction around the native fetch exposed by a function. It provides a simple interface to handle API calls\n * to the Strapi backend.\n * @example\n * ```tsx\n * import { getFetchClient } from '@strapi/admin/admin';\n *\n * const myFunct = () => {\n *   const { get } = getFetchClient();\n *   const requestURL = \"/some-endpoint\";\n *\n *   const { data } = await get(requestURL);\n *\n *   return data;\n * };\n * ```\n */\nconst getFetchClient = (defaultOptions: FetchConfig = {}): FetchClient => {\n  const backendURL = window.strapi.backendURL;\n  const defaultHeader = {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${getToken()}`,\n  };\n\n  const isFormDataRequest = (body: unknown) => body instanceof FormData;\n  const addPrependingSlash = (url: string) => (url.charAt(0) !== '/' ? `/${url}` : url);\n\n  // This regular expression matches a string that starts with either \"http://\" or \"https://\" or any other protocol name in lower case letters, followed by \"://\" and ends with anything else\n  const hasProtocol = (url: string) => new RegExp('^(?:[a-z+]+:)?//', 'i').test(url);\n\n  // Check if the url has a prepending slash, if not add a slash\n  const normalizeUrl = (url: string) => (hasProtocol(url) ? url : addPrependingSlash(url));\n\n  // Add a response interceptor to return the response\n  const responseInterceptor = async <TData = any>(\n    response: Response,\n    validateStatus?: FetchOptions['validateStatus']\n  ): Promise<FetchResponse<TData>> => {\n    try {\n      const result = await response.json();\n\n      /**\n       * validateStatus allows us to customize when a response should throw an error\n       * In native Fetch API, a response is considered \"not ok\"\n       * when the status code falls in the 200 to 299 (inclusive) range\n       */\n      if (!response.ok && result.error && !validateStatus?.(response.status)) {\n        throw new FetchError(result.error.message, { data: result });\n      }\n\n      if (!response.ok && !validateStatus?.(response.status)) {\n        throw new FetchError('Unknown Server Error');\n      }\n\n      return { data: result };\n    } catch (error) {\n      if (error instanceof SyntaxError && response.ok) {\n        // Making sure that a SyntaxError doesn't throw if it's successful\n        return { data: [], status: response.status } as FetchResponse<any>;\n      } else {\n        throw error;\n      }\n    }\n  };\n\n  const paramsSerializer =\n    <Param = unknown>(params?: Param) =>\n    (url: string) => {\n      if (params) {\n        if (typeof params === 'string') {\n          return `${url}?${params}`;\n        }\n\n        /**\n         * TODO V6: Encoding should be enabled in this step\n         * So the rest of the app doesn't have to worry about it,\n         * It's considered a breaking change because it impacts any API request, including the user's custom code\n         */\n        const serializedParams = qs.stringify(params, { encode: false });\n        return `${url}?${serializedParams}`;\n      }\n      return url;\n    };\n\n  const addBaseUrl = (url: Parameters<typeof fetch>[0]) => {\n    return `${backendURL}${url}`;\n  };\n\n  /**\n   * We use the factory method because the options\n   * are unique to the individual request\n   */\n  const makeCreateRequestUrl = (options?: FetchOptions) =>\n    pipe(normalizeUrl, addBaseUrl, paramsSerializer(options?.params));\n\n  const fetchClient: FetchClient = {\n    get: async <TData>(url: string, options?: FetchOptions): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n      /**\n       * this applies all our transformations to the URL\n       * - normalizing (making sure it has the correct slash)\n       * - appending our BaseURL which comes from the window.strapi object\n       * - serializing our params with QS\n       */\n      const createRequestUrl = makeCreateRequestUrl(options);\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'GET',\n        headers,\n      });\n\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n    post: async <TData, TSend = any>(\n      url: string,\n      data?: TSend,\n      options?: FetchOptions\n    ): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n\n      const createRequestUrl = makeCreateRequestUrl(options);\n\n      /**\n       * we have to remove the Content-Type value if it was a formData request\n       * the browser will automatically set the header value\n       */\n      if (isFormDataRequest(data)) {\n        headers.delete('Content-Type');\n      }\n\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'POST',\n        headers,\n        body: isFormDataRequest(data) ? (data as FormData) : JSON.stringify(data),\n      });\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n    put: async <TData, TSend = any>(\n      url: string,\n      data?: TSend,\n      options?: FetchOptions\n    ): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n\n      const createRequestUrl = makeCreateRequestUrl(options);\n\n      /**\n       * we have to remove the Content-Type value if it was a formData request\n       * the browser will automatically set the header value\n       */\n      if (isFormDataRequest(data)) {\n        headers.delete('Content-Type');\n      }\n\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'PUT',\n        headers,\n        body: isFormDataRequest(data) ? (data as FormData) : JSON.stringify(data),\n      });\n\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n    del: async <TData>(url: string, options?: FetchOptions): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n\n      const createRequestUrl = makeCreateRequestUrl(options);\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'DELETE',\n        headers,\n      });\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n  };\n\n  return fetchClient;\n};\n\nexport { getFetchClient, isFetchError, FetchError };\nexport type { FetchOptions, FetchResponse, FetchConfig, FetchClient, ErrorResponse };\n"],"names":["STORAGE_KEYS","TOKEN","USER","FetchError","Error","constructor","message","response","name","code","data","error","status","captureStackTrace","isFetchError","getToken","fromLocalStorage","localStorage","getItem","JSON","parse","fromCookie","getCookieValue","getFetchClient","defaultOptions","backendURL","window","strapi","defaultHeader","Accept","Authorization","isFormDataRequest","body","FormData","addPrependingSlash","url","charAt","hasProtocol","RegExp","test","normalizeUrl","responseInterceptor","validateStatus","result","json","ok","SyntaxError","paramsSerializer","params","serializedParams","qs","stringify","encode","addBaseUrl","makeCreateRequestUrl","options","pipe","fetchClient","get","headers","Headers","createRequestUrl","fetch","signal","method","post","delete","put","del"],"mappings":"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"}