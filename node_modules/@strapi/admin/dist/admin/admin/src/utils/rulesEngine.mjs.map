{"version":3,"file":"rulesEngine.mjs","sources":["../../../../../admin/src/utils/rulesEngine.ts"],"sourcesContent":["import jsonLogic from 'json-logic-js';\nimport { z } from 'zod';\n\nexport const ConditionSchema = z.object({\n  dependsOn: z.string().min(1),\n  operator: z.enum(['is', 'isNot']),\n  value: z.union([z.string(), z.number(), z.boolean()]),\n});\n\nexport type Condition = z.infer<typeof ConditionSchema>;\nexport type JsonLogicCondition = jsonLogic.RulesLogic<jsonLogic.AdditionalOperation>;\nexport type RulesEngine = {\n  generate: (condition: Condition) => JsonLogicCondition;\n  validate: (condition: Condition) => void;\n  evaluate: (condition: JsonLogicCondition, data: unknown) => boolean;\n};\n\nexport function createRulesEngine(): RulesEngine {\n  /**\n   * Transforms a high-level `Condition` object into a JSON Logic-compatible condition.\n   *\n   * Converts operators like 'is' and 'isNot' into their JSON Logic equivalents ('==' and '!=').\n   * Throws an error if the operator is not supported.\n   *\n   * @param condition - The condition object to convert.\n   * @returns A JSON Logic AST representing the condition.\n   * @throws {Error} If the operator is not recognized.\n   */\n  const generate = (condition: Condition): JsonLogicCondition => {\n    const { dependsOn, operator, value } = condition;\n    const operatorsMap = {\n      is: '==',\n      isNot: '!=',\n    };\n    if (!operatorsMap[operator]) {\n      throw new Error(`Invalid operator: ${operator}`);\n    }\n    return { [operatorsMap[operator]]: [{ var: dependsOn }, value] };\n  };\n\n  /**\n   * Validates a condition object against the `ConditionSchema`.\n   *\n   * Ensures that the condition adheres to the expected structure and types.\n   *\n   * @param condition - The condition object to validate.\n   * @throws {ZodError} If the condition is invalid.\n   */\n  const validate = (condition: Condition) => {\n    ConditionSchema.parse(condition);\n  };\n\n  /**\n   * Evaluates a JSON Logic condition against provided data.\n   * @throws {Error} If the condition is invalid.\n   */\n  const evaluate = (\n    condition: jsonLogic.RulesLogic<jsonLogic.AdditionalOperation>,\n    data: unknown\n  ): boolean => {\n    try {\n      return jsonLogic.apply(condition, data);\n    } catch (err: any) {\n      throw new Error(`Invalid condition: ${err.message}`);\n    }\n  };\n\n  return {\n    generate,\n    validate,\n    evaluate,\n  };\n}\n"],"names":["ConditionSchema","z","object","dependsOn","string","min","operator","enum","value","union","number","boolean","createRulesEngine","generate","condition","operatorsMap","is","isNot","Error","var","validate","parse","evaluate","data","jsonLogic","apply","err","message"],"mappings":";;;AAGaA,MAAAA,eAAAA,GAAkBC,CAAEC,CAAAA,MAAM,CAAC;AACtCC,IAAAA,SAAAA,EAAWF,CAAEG,CAAAA,MAAM,EAAGC,CAAAA,GAAG,CAAC,CAAA,CAAA;IAC1BC,QAAUL,EAAAA,CAAAA,CAAEM,IAAI,CAAC;AAAC,QAAA,IAAA;AAAM,QAAA;AAAQ,KAAA,CAAA;IAChCC,KAAOP,EAAAA,CAAAA,CAAEQ,KAAK,CAAC;AAACR,QAAAA,CAAAA,CAAEG,MAAM,EAAA;AAAIH,QAAAA,CAAAA,CAAES,MAAM,EAAA;AAAIT,QAAAA,CAAAA,CAAEU,OAAO;AAAG,KAAA;AACtD,CAAG;AAUI,SAASC,iBAAAA,GAAAA;AACd;;;;;;;;;MAUA,MAAMC,WAAW,CAACC,SAAAA,GAAAA;AAChB,QAAA,MAAM,EAAEX,SAAS,EAAEG,QAAQ,EAAEE,KAAK,EAAE,GAAGM,SAAAA;AACvC,QAAA,MAAMC,YAAe,GAAA;YACnBC,EAAI,EAAA,IAAA;YACJC,KAAO,EAAA;AACT,SAAA;AACA,QAAA,IAAI,CAACF,YAAY,CAACT,QAAAA,CAAS,EAAE;AAC3B,YAAA,MAAM,IAAIY,KAAM,CAAA,CAAC,kBAAkB,EAAEZ,SAAS,CAAC,CAAA;AACjD;QACA,OAAO;AAAE,YAAA,CAACS,YAAY,CAACT,QAAS,CAAA,GAAG;AAAC,gBAAA;oBAAEa,GAAKhB,EAAAA;AAAU,iBAAA;AAAGK,gBAAAA;AAAM;AAAC,SAAA;AACjE,KAAA;AAEA;;;;;;;MAQA,MAAMY,WAAW,CAACN,SAAAA,GAAAA;AAChBd,QAAAA,eAAAA,CAAgBqB,KAAK,CAACP,SAAAA,CAAAA;AACxB,KAAA;AAEA;;;MAIA,MAAMQ,QAAW,GAAA,CACfR,SACAS,EAAAA,IAAAA,GAAAA;QAEA,IAAI;YACF,OAAOC,SAAAA,CAAUC,KAAK,CAACX,SAAWS,EAAAA,IAAAA,CAAAA;AACpC,SAAA,CAAE,OAAOG,GAAU,EAAA;YACjB,MAAM,IAAIR,MAAM,CAAC,mBAAmB,EAAEQ,GAAIC,CAAAA,OAAO,CAAC,CAAC,CAAA;AACrD;AACF,KAAA;IAEA,OAAO;AACLd,QAAAA,QAAAA;AACAO,QAAAA,QAAAA;AACAE,QAAAA;AACF,KAAA;AACF;;;;"}