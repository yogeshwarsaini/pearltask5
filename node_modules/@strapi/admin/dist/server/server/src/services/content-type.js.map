{"version":3,"file":"content-type.js","sources":["../../../../../server/src/services/content-type.ts"],"sourcesContent":["import _ from 'lodash';\nimport { uniq, startsWith } from 'lodash/fp';\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\nimport type { Modules, Struct } from '@strapi/types';\nimport { getService } from '../utils';\nimport actionDomain from '../domain/action';\nimport permissionDomain from '../domain/permission';\n\ninterface FieldOptions {\n  prefix?: string; // prefix to add to the path\n  nestingLevel?: number; // level of nesting to achieve\n  requiredOnly?: boolean; // only returns required nestedFields\n  existingFields?: string[]; // fields that are already selected, meaning that some sub-fields may be required\n  restrictedSubjects?: string[]; // subjectsId to ignore\n  components?: {\n    // components where components attributes can be found\n    [key: string]: any;\n  };\n}\n\n/**\n * Creates an array of paths to the fields and nested fields, without path nodes\n */\nconst getNestedFields = (\n  model: Struct.ContentTypeSchema,\n  {\n    prefix = '',\n    nestingLevel = 15,\n    components = {},\n    requiredOnly = false,\n    existingFields = [],\n  }: FieldOptions\n): string[] => {\n  if (nestingLevel === 0) {\n    return prefix ? [prefix] : [];\n  }\n\n  const nonAuthorizableFields = contentTypesUtils.getNonVisibleAttributes(model);\n\n  return _.reduce(\n    model.attributes,\n    (fields: any, attr: any, key: any) => {\n      if (nonAuthorizableFields.includes(key)) return fields;\n\n      const fieldPath = prefix ? `${prefix}.${key}` : key;\n      const shouldBeIncluded = !requiredOnly || attr.required === true;\n      const insideExistingFields = existingFields && existingFields.some(startsWith(fieldPath));\n\n      if (attr.type === 'component') {\n        if (shouldBeIncluded || insideExistingFields) {\n          const compoFields = getNestedFields(components[attr.component], {\n            nestingLevel: nestingLevel - 1,\n            prefix: fieldPath,\n            components,\n            requiredOnly,\n            existingFields,\n          });\n\n          if (compoFields.length === 0 && shouldBeIncluded) {\n            return fields.concat(fieldPath);\n          }\n\n          return fields.concat(compoFields);\n        }\n        return fields;\n      }\n\n      if (shouldBeIncluded) {\n        return fields.concat(fieldPath);\n      }\n\n      return fields;\n    },\n    []\n  );\n};\n\n/**\n * Creates an array of paths to the fields and nested fields, with path nodes\n */\nconst getNestedFieldsWithIntermediate = (\n  model: Struct.ContentTypeSchema,\n  { prefix = '', nestingLevel = 15, components = {} }: FieldOptions\n): string[] => {\n  if (nestingLevel === 0) {\n    return [];\n  }\n\n  const nonAuthorizableFields = contentTypesUtils.getNonVisibleAttributes(model);\n\n  return _.reduce(\n    model.attributes,\n    (fields: any, attr: any, key: any) => {\n      if (nonAuthorizableFields.includes(key)) return fields;\n\n      const fieldPath = prefix ? `${prefix}.${key}` : key;\n      fields.push(fieldPath);\n\n      if (attr.type === 'component') {\n        const compoFields = getNestedFieldsWithIntermediate(components[attr.component], {\n          nestingLevel: nestingLevel - 1,\n          prefix: fieldPath,\n          components,\n        });\n\n        fields.push(...compoFields);\n      }\n\n      return fields;\n    },\n    []\n  );\n};\n\n/**\n * Creates an array of permissions with the \"properties.fields\" attribute filled\n */\nconst getPermissionsWithNestedFields = (\n  actions: any[],\n  { nestingLevel, restrictedSubjects = [] }: FieldOptions = {}\n): Modules.Permissions.PermissionRule[] => {\n  return actions.reduce((permissions, action) => {\n    const validSubjects = action.subjects.filter(\n      (subject: any) => !restrictedSubjects.includes(subject)\n    );\n\n    // Create a Permission for each subject (content-type uid) within the action\n    for (const subject of validSubjects) {\n      const fields = actionDomain.appliesToProperty('fields', action)\n        ? getNestedFields(strapi.contentTypes[subject], {\n            components: strapi.components,\n            nestingLevel,\n          })\n        : undefined;\n\n      const permission = permissionDomain.create({\n        action: action.actionId,\n        subject,\n        properties: { fields },\n      });\n\n      permissions.push(permission);\n    }\n\n    return permissions;\n  }, []);\n};\n\n/**\n * Cleans permissions' fields (add required ones, remove the non-existing ones)\n */\nconst cleanPermissionFields = (\n  permissions: Modules.Permissions.PermissionRule[]\n): Modules.Permissions.PermissionRule[] => {\n  const { actionProvider } = getService('permission');\n\n  return permissions.map((permission: any) => {\n    const {\n      action: actionId,\n      subject,\n      properties: { fields },\n    } = permission;\n\n    const action = actionProvider.get(actionId) as any;\n\n    // todo see if it's possible to check property on action + subject (async)\n    if (!actionDomain.appliesToProperty('fields', action)) {\n      return permissionDomain.deleteProperty('fields', permission);\n    }\n\n    if (!subject || !strapi.contentTypes[subject]) {\n      return permission;\n    }\n\n    const possibleFields = getNestedFieldsWithIntermediate(strapi.contentTypes[subject], {\n      components: strapi.components,\n    });\n\n    const currentFields: string[] = fields || [];\n\n    const validUserFields: string[] = uniq(\n      possibleFields.filter((pf) =>\n        currentFields.some((cf) => pf === cf || startsWith(`${cf}.`, pf))\n      )\n    );\n\n    // A field is considered \"not nested\" if no other valid user field starts with this field's path followed by a dot.\n    // This helps to remove redundant parent paths when a more specific child path is already included.\n    // For example, if 'component.title' is present, 'component' would be filtered out by this condition.\n    const isNotNestedField = (field: string) =>\n      !validUserFields.some(\n        (validUserField: string) =>\n          validUserField !== field && startsWith(`${field}.`, validUserField)\n      );\n\n    // Filter out fields that are parent paths of other included fields.\n    const newFields = validUserFields.filter(isNotNestedField);\n\n    return permissionDomain.setProperty('fields', newFields, permission);\n  }, []);\n};\n\nexport {\n  getNestedFields,\n  getPermissionsWithNestedFields,\n  cleanPermissionFields,\n  getNestedFieldsWithIntermediate,\n};\n"],"names":["getNestedFields","model","prefix","nestingLevel","components","requiredOnly","existingFields","nonAuthorizableFields","contentTypesUtils","getNonVisibleAttributes","_","reduce","attributes","fields","attr","key","includes","fieldPath","shouldBeIncluded","required","insideExistingFields","some","startsWith","type","compoFields","component","length","concat","getNestedFieldsWithIntermediate","push","getPermissionsWithNestedFields","actions","restrictedSubjects","permissions","action","validSubjects","subjects","filter","subject","actionDomain","appliesToProperty","strapi","contentTypes","undefined","permission","permissionDomain","create","actionId","properties","cleanPermissionFields","actionProvider","getService","map","get","deleteProperty","possibleFields","currentFields","validUserFields","uniq","pf","cf","isNotNestedField","field","validUserField","newFields","setProperty"],"mappings":"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"}