{"version":3,"file":"unidirectional-relations.js","sources":["../../../../src/services/document-service/utils/unidirectional-relations.ts"],"sourcesContent":["/* eslint-disable no-continue */\nimport { keyBy, omit } from 'lodash/fp';\n\nimport type { UID, Schema } from '@strapi/types';\n\ninterface LoadContext {\n  oldVersions: { id: string; locale: string }[];\n  newVersions: { id: string; locale: string }[];\n}\n\n/**\n * Loads lingering relations that need to be updated when overriding a published or draft entry.\n * This is necessary because the relations are uni-directional and the target entry is not aware of the source entry.\n * This is not the case for bi-directional relations, where the target entry is also linked to the source entry.\n */\nconst load = async (uid: UID.ContentType, { oldVersions, newVersions }: LoadContext) => {\n  const updates = [] as any;\n\n  // Iterate all components and content types to find relations that need to be updated\n  await strapi.db.transaction(async ({ trx }) => {\n    const contentTypes = Object.values(strapi.contentTypes) as Schema.ContentType[];\n    const components = Object.values(strapi.components) as Schema.Component[];\n\n    for (const model of [...contentTypes, ...components]) {\n      const dbModel = strapi.db.metadata.get(model.uid);\n\n      for (const attribute of Object.values(dbModel.attributes) as any) {\n        /**\n         * Only consider unidirectional relations\n         */\n        if (\n          attribute.type !== 'relation' ||\n          attribute.target !== uid ||\n          attribute.inversedBy ||\n          attribute.mappedBy\n        ) {\n          continue;\n        }\n\n        // TODO: joinColumn relations\n        const joinTable = attribute.joinTable;\n        if (!joinTable) {\n          continue;\n        }\n\n        const { name: sourceColumnName } = joinTable.joinColumn;\n        const { name: targetColumnName } = joinTable.inverseJoinColumn;\n\n        /**\n         * Load all relations that need to be updated\n         */\n        // NOTE: when the model has draft and publish, we can assume relation are only draft to draft & published to published\n        const ids = oldVersions.map((entry) => entry.id);\n\n        const oldVersionsRelations = await strapi.db\n          .getConnection()\n          .select('*')\n          .from(joinTable.name)\n          .whereIn(targetColumnName, ids)\n          .transacting(trx);\n\n        if (oldVersionsRelations.length > 0) {\n          updates.push({ joinTable, relations: oldVersionsRelations });\n        }\n\n        /**\n         * if publishing\n         *  if published version exists\n         *    updated published versions links\n         *  else\n         *    create link to newly published version\n         *\n         * if discarding\n         *    if published version link exists & not draft version link\n         *       create link to new draft version\n         */\n\n        if (!model.options?.draftAndPublish) {\n          const ids = newVersions.map((entry) => entry.id);\n\n          const newVersionsRelations = await strapi.db\n            .getConnection()\n            .select('*')\n            .from(joinTable.name)\n            .whereIn(targetColumnName, ids)\n            .transacting(trx);\n\n          if (newVersionsRelations.length > 0) {\n            // when publishing a draft that doesn't have a published version yet,\n            // copy the links to the draft over to the published version\n            // when discarding a published version, if no drafts exists\n            const discardToAdd = newVersionsRelations\n              .filter((relation) => {\n                const matchingOldVerion = oldVersionsRelations.find((oldRelation) => {\n                  return oldRelation[sourceColumnName] === relation[sourceColumnName];\n                });\n\n                return !matchingOldVerion;\n              })\n              .map(omit('id'));\n\n            updates.push({ joinTable, relations: discardToAdd });\n          }\n        }\n      }\n    }\n  });\n\n  return updates;\n};\n\n/**\n * Updates uni directional relations to target the right entries when overriding published or draft entries.\n *\n * @param oldEntries The old entries that are being overridden\n * @param newEntries The new entries that are overriding the old ones\n * @param oldRelations The relations that were previously loaded with `load` @see load\n */\nconst sync = async (\n  oldEntries: { id: string; locale: string }[],\n  newEntries: { id: string; locale: string }[],\n  oldRelations: { joinTable: any; relations: any[] }[]\n) => {\n  /**\n   * Create a map of old entry ids to new entry ids\n   *\n   * Will be used to update the relation target ids\n   */\n  const newEntryByLocale = keyBy('locale', newEntries);\n  const oldEntriesMap = oldEntries.reduce(\n    (acc, entry) => {\n      const newEntry = newEntryByLocale[entry.locale];\n      if (!newEntry) return acc;\n      acc[entry.id] = newEntry.id;\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  await strapi.db.transaction(async ({ trx }) => {\n    // Iterate old relations that are deleted and insert the new ones\n    for (const { joinTable, relations } of oldRelations) {\n      // Update old ids with the new ones\n      const column = joinTable.inverseJoinColumn.name;\n\n      const newRelations = relations.map((relation) => {\n        const newId = oldEntriesMap[relation[column]];\n        return { ...relation, [column]: newId };\n      });\n\n      // Insert those relations into the join table\n      await trx.batchInsert(joinTable.name, newRelations, 1000);\n    }\n  });\n};\n\nexport { load, sync };\n"],"names":["load","uid","oldVersions","newVersions","updates","strapi","db","transaction","trx","contentTypes","Object","values","components","model","dbModel","metadata","get","attribute","attributes","type","target","inversedBy","mappedBy","joinTable","name","sourceColumnName","joinColumn","targetColumnName","inverseJoinColumn","ids","map","entry","id","oldVersionsRelations","getConnection","select","from","whereIn","transacting","length","push","relations","options","draftAndPublish","newVersionsRelations","discardToAdd","filter","relation","matchingOldVerion","find","oldRelation","omit","sync","oldEntries","newEntries","oldRelations","newEntryByLocale","keyBy","oldEntriesMap","reduce","acc","newEntry","locale","column","newRelations","newId","batchInsert"],"mappings":";;;;AAUA;;;;IAKA,MAAMA,OAAO,OAAOC,GAAAA,EAAsB,EAAEC,WAAW,EAAEC,WAAW,EAAe,GAAA;AACjF,IAAA,MAAMC,UAAU,EAAE;;IAGlB,MAAMC,MAAAA,CAAOC,EAAE,CAACC,WAAW,CAAC,OAAO,EAAEC,GAAG,EAAE,GAAA;AACxC,QAAA,MAAMC,YAAeC,GAAAA,MAAAA,CAAOC,MAAM,CAACN,OAAOI,YAAY,CAAA;AACtD,QAAA,MAAMG,UAAaF,GAAAA,MAAAA,CAAOC,MAAM,CAACN,OAAOO,UAAU,CAAA;AAElD,QAAA,KAAK,MAAMC,KAAS,IAAA;AAAIJ,YAAAA,GAAAA,YAAAA;AAAiBG,YAAAA,GAAAA;SAAW,CAAE;YACpD,MAAME,OAAAA,GAAUT,OAAOC,EAAE,CAACS,QAAQ,CAACC,GAAG,CAACH,KAAAA,CAAMZ,GAAG,CAAA;AAEhD,YAAA,KAAK,MAAMgB,SAAaP,IAAAA,MAAAA,CAAOC,MAAM,CAACG,OAAAA,CAAQI,UAAU,CAAU,CAAA;AAChE;;AAEC,YACD,IACED,SAAAA,CAAUE,IAAI,KAAK,cACnBF,SAAUG,CAAAA,MAAM,KAAKnB,GAAAA,IACrBgB,SAAUI,CAAAA,UAAU,IACpBJ,SAAAA,CAAUK,QAAQ,EAClB;AACA,oBAAA;AACF;;gBAGA,MAAMC,SAAAA,GAAYN,UAAUM,SAAS;AACrC,gBAAA,IAAI,CAACA,SAAW,EAAA;AACd,oBAAA;AACF;AAEA,gBAAA,MAAM,EAAEC,IAAMC,EAAAA,gBAAgB,EAAE,GAAGF,UAAUG,UAAU;AACvD,gBAAA,MAAM,EAAEF,IAAMG,EAAAA,gBAAgB,EAAE,GAAGJ,UAAUK,iBAAiB;AAE9D;;AAEC;AAED,gBAAA,MAAMC,MAAM3B,WAAY4B,CAAAA,GAAG,CAAC,CAACC,KAAAA,GAAUA,MAAMC,EAAE,CAAA;gBAE/C,MAAMC,oBAAAA,GAAuB,MAAM5B,MAAOC,CAAAA,EAAE,CACzC4B,aAAa,EAAA,CACbC,MAAM,CAAC,GAAA,CAAA,CACPC,IAAI,CAACb,SAAAA,CAAUC,IAAI,CACnBa,CAAAA,OAAO,CAACV,gBAAkBE,EAAAA,GAAAA,CAAAA,CAC1BS,WAAW,CAAC9B,GAAAA,CAAAA;gBAEf,IAAIyB,oBAAAA,CAAqBM,MAAM,GAAG,CAAG,EAAA;AACnCnC,oBAAAA,OAAAA,CAAQoC,IAAI,CAAC;AAAEjB,wBAAAA,SAAAA;wBAAWkB,SAAWR,EAAAA;AAAqB,qBAAA,CAAA;AAC5D;AAEA;;;;;;;;;;AAUC,YAED,IAAI,CAACpB,KAAM6B,CAAAA,OAAO,EAAEC,eAAiB,EAAA;AACnC,oBAAA,MAAMd,MAAM1B,WAAY2B,CAAAA,GAAG,CAAC,CAACC,KAAAA,GAAUA,MAAMC,EAAE,CAAA;oBAE/C,MAAMY,oBAAAA,GAAuB,MAAMvC,MAAOC,CAAAA,EAAE,CACzC4B,aAAa,EAAA,CACbC,MAAM,CAAC,GAAA,CAAA,CACPC,IAAI,CAACb,SAAAA,CAAUC,IAAI,CACnBa,CAAAA,OAAO,CAACV,gBAAkBE,EAAAA,GAAAA,CAAAA,CAC1BS,WAAW,CAAC9B,GAAAA,CAAAA;oBAEf,IAAIoC,oBAAAA,CAAqBL,MAAM,GAAG,CAAG,EAAA;;;;AAInC,wBAAA,MAAMM,YAAeD,GAAAA,oBAAAA,CAClBE,MAAM,CAAC,CAACC,QAAAA,GAAAA;AACP,4BAAA,MAAMC,iBAAoBf,GAAAA,oBAAAA,CAAqBgB,IAAI,CAAC,CAACC,WAAAA,GAAAA;AACnD,gCAAA,OAAOA,WAAW,CAACzB,gBAAAA,CAAiB,KAAKsB,QAAQ,CAACtB,gBAAiB,CAAA;AACrE,6BAAA,CAAA;AAEA,4BAAA,OAAO,CAACuB,iBAAAA;yBAETlB,CAAAA,CAAAA,GAAG,CAACqB,OAAK,CAAA,IAAA,CAAA,CAAA;AAEZ/C,wBAAAA,OAAAA,CAAQoC,IAAI,CAAC;AAAEjB,4BAAAA,SAAAA;4BAAWkB,SAAWI,EAAAA;AAAa,yBAAA,CAAA;AACpD;AACF;AACF;AACF;AACF,KAAA,CAAA;IAEA,OAAOzC,OAAAA;AACT;AAEA;;;;;;AAMC,IACKgD,MAAAA,IAAAA,GAAO,OACXC,UAAAA,EACAC,UACAC,EAAAA,YAAAA,GAAAA;AAEA;;;;MAKA,MAAMC,gBAAmBC,GAAAA,QAAAA,CAAM,QAAUH,EAAAA,UAAAA,CAAAA;AACzC,IAAA,MAAMI,aAAgBL,GAAAA,UAAAA,CAAWM,MAAM,CACrC,CAACC,GAAK7B,EAAAA,KAAAA,GAAAA;AACJ,QAAA,MAAM8B,QAAWL,GAAAA,gBAAgB,CAACzB,KAAAA,CAAM+B,MAAM,CAAC;QAC/C,IAAI,CAACD,UAAU,OAAOD,GAAAA;AACtBA,QAAAA,GAAG,CAAC7B,KAAMC,CAAAA,EAAE,CAAC,GAAG6B,SAAS7B,EAAE;QAC3B,OAAO4B,GAAAA;AACT,KAAA,EACA,EAAC,CAAA;IAGH,MAAMvD,MAAAA,CAAOC,EAAE,CAACC,WAAW,CAAC,OAAO,EAAEC,GAAG,EAAE,GAAA;;AAExC,QAAA,KAAK,MAAM,EAAEe,SAAS,EAAEkB,SAAS,EAAE,IAAIc,YAAc,CAAA;;AAEnD,YAAA,MAAMQ,MAASxC,GAAAA,SAAAA,CAAUK,iBAAiB,CAACJ,IAAI;AAE/C,YAAA,MAAMwC,YAAevB,GAAAA,SAAAA,CAAUX,GAAG,CAAC,CAACiB,QAAAA,GAAAA;AAClC,gBAAA,MAAMkB,QAAQP,aAAa,CAACX,QAAQ,CAACgB,OAAO,CAAC;gBAC7C,OAAO;AAAE,oBAAA,GAAGhB,QAAQ;AAAE,oBAAA,CAACgB,SAASE;AAAM,iBAAA;AACxC,aAAA,CAAA;;AAGA,YAAA,MAAMzD,IAAI0D,WAAW,CAAC3C,SAAUC,CAAAA,IAAI,EAAEwC,YAAc,EAAA,IAAA,CAAA;AACtD;AACF,KAAA,CAAA;AACF;;;;;"}