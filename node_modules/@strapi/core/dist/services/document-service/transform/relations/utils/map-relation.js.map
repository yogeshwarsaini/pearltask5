{"version":3,"file":"map-relation.js","sources":["../../../../../../src/services/document-service/transform/relations/utils/map-relation.ts"],"sourcesContent":["/* eslint-disable node/no-callback-literal */\nimport { isObject, curry, isNil } from 'lodash/fp';\n\nimport { traverseEntity, async } from '@strapi/utils';\n\nimport { Relation } from './types';\n\nconst isNumeric = (value: any): value is number => {\n  if (Array.isArray(value)) return false; // Handle [1, 'docId'] case\n  const parsed = parseInt(value, 10);\n  return !Number.isNaN(parsed);\n};\n\nconst toArray = (value: any) => {\n  // Keep value as it is if it's a nullish value\n  if (isNil(value)) return value;\n  if (Array.isArray(value)) return value;\n\n  return [value];\n};\n\n/**\n * There are multiple ways to create Strapi relations.\n * This is a utility to traverse and transform relation data\n *\n *\n * For consistency and ease of use, the response will always be an object with the following shape:\n * { set: [{...}], connect: [{...}], disconnect: [{...}] }\n *\n * @example\n * transformRelationData({\n *  onLongHand: (relation) => {\n *    // Change the id of the relation\n *    return { id: 'other' };\n *  },\n * }, relation)\n */\nconst mapRelation = async (\n  callback: (relation: any) => any,\n  rel: Relation,\n  isRecursive = false\n): Promise<Relation> => {\n  let relation: Relation = rel;\n\n  const wrapInSet = (value: any) => {\n    // Ignore wrapping if it's a recursive call\n    if (isRecursive) {\n      return value;\n    }\n    return { set: toArray(value) };\n  };\n\n  // undefined | null\n  if (isNil(relation)) {\n    return callback(relation);\n  }\n\n  // LongHand[] | ShortHand[]\n  if (Array.isArray(relation)) {\n    return async\n      .map(relation, (r: Relation) => mapRelation(callback, r, true))\n      .then((result: any) => result.flat().filter(Boolean))\n      .then(wrapInSet);\n  }\n\n  // LongHand\n  if (isObject(relation)) {\n    // { id: 1 } || { documentId: 1 }\n    if ('id' in relation || 'documentId' in relation) {\n      const result = await callback(relation);\n      return wrapInSet(result);\n    }\n\n    // If not connecting anything, return default visitor\n    if (!relation.set && !relation.disconnect && !relation.connect) {\n      return callback(relation);\n    }\n\n    // { set }\n    if (relation.set) {\n      const set: any = await mapRelation(callback, relation.set, true);\n      relation = { ...relation, set: toArray(set) };\n    }\n\n    // { disconnect}\n    if (relation.disconnect) {\n      const disconnect: any = await mapRelation(callback, relation.disconnect, true);\n      relation = { ...relation, disconnect: toArray(disconnect) };\n    }\n\n    // { connect }\n    if (relation.connect) {\n      // Transform the relation to connect\n      const connect: any = await mapRelation(callback, relation.connect, true);\n      relation = { ...relation, connect: toArray(connect) };\n    }\n\n    return relation;\n  }\n\n  // ShortHand\n  if (isNumeric(relation)) {\n    const result = await callback({ id: relation });\n    return wrapInSet(result);\n  }\n\n  if (typeof relation === 'string') {\n    const result = await callback({ documentId: relation });\n    return wrapInSet(result);\n  }\n\n  // Anything else\n  return callback(relation);\n};\n\ntype TraverseEntity = Parameters<typeof traverseEntity>;\n\n/**\n * Utility function, same as `traverseEntity` but only for relations.\n */\nconst traverseEntityRelations = async (\n  visitor: TraverseEntity[0],\n  options: TraverseEntity[1],\n  data: TraverseEntity[2]\n) => {\n  return traverseEntity(\n    async (options, utils) => {\n      const { attribute } = options;\n\n      if (!attribute) {\n        return;\n      }\n\n      if (attribute.type !== 'relation') {\n        return;\n      }\n\n      // TODO: Handle join columns\n      if (attribute.useJoinTable === false) {\n        return;\n      }\n\n      return visitor(options, utils);\n    },\n    options,\n    data\n  );\n};\n\nconst mapRelationCurried = curry(mapRelation);\nconst traverseEntityRelationsCurried = curry(traverseEntityRelations);\n\nexport {\n  mapRelationCurried as mapRelation,\n  traverseEntityRelationsCurried as traverseEntityRelations,\n};\n"],"names":["isNumeric","value","Array","isArray","parsed","parseInt","Number","isNaN","toArray","isNil","mapRelation","callback","rel","isRecursive","relation","wrapInSet","set","async","map","r","then","result","flat","filter","Boolean","isObject","disconnect","connect","id","documentId","traverseEntityRelations","visitor","options","data","traverseEntity","utils","attribute","type","useJoinTable","mapRelationCurried","curry","traverseEntityRelationsCurried"],"mappings":"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"}