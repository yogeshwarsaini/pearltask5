{"version":3,"file":"workflows.js","sources":["../../../server/src/services/workflows.ts"],"sourcesContent":["import type { Core } from '@strapi/types';\nimport { set, isString, map, get } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\nimport { WORKFLOW_MODEL_UID, WORKFLOW_POPULATE } from '../constants/workflows';\nimport { getService } from '../utils';\nimport { getWorkflowContentTypeFilter } from '../utils/review-workflows';\nimport workflowsContentTypesFactory from './workflow-content-types';\n\nconst processFilters = ({ strapi }: { strapi: Core.Strapi }, filters: any = {}) => {\n  const processedFilters = { ...filters };\n\n  if (isString(filters.contentTypes)) {\n    processedFilters.contentTypes = getWorkflowContentTypeFilter({ strapi }, filters.contentTypes);\n  }\n\n  return processedFilters;\n};\n\n// TODO: How can we improve this? Maybe using traversePopulate?\nconst processPopulate = (populate: any) => {\n  // If it does not exist or it's not an object (like an array) return the default populate\n  if (!populate) {\n    return WORKFLOW_POPULATE;\n  }\n\n  return populate;\n};\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => {\n  const workflowsContentTypes = workflowsContentTypesFactory({ strapi });\n  const workflowValidator = getService('validation', { strapi });\n  const metrics = getService('workflow-metrics', { strapi });\n\n  return {\n    /**\n     * Returns all the workflows matching the user-defined filters.\n     * @param {object} opts - Options for the query.\n     * @param {object} opts.filters - Filters object.\n     * @returns {Promise<object[]>} - List of workflows that match the user's filters.\n     */\n    async find(opts: any = {}) {\n      const filters = processFilters({ strapi }, opts.filters);\n      const populate = processPopulate(opts.populate);\n\n      const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, {\n        ...opts,\n        filters,\n        populate,\n      });\n\n      return strapi.db.query(WORKFLOW_MODEL_UID).findMany(query);\n    },\n\n    /**\n     * Returns the workflow with the specified ID.\n     * @param {string} id - ID of the requested workflow.\n     * @param {object} opts - Options for the query.\n     * @returns {Promise<object>} - Workflow object matching the requested ID.\n     */\n    findById(id: any, opts: { populate?: any } = {}) {\n      const populate = processPopulate(opts.populate);\n\n      const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, { populate });\n\n      return strapi.db.query(WORKFLOW_MODEL_UID).findOne({\n        ...query,\n        where: { id },\n      });\n    },\n\n    /**\n     * Creates a new workflow.\n     * @param {object} opts - Options for creating the new workflow.\n     * @returns {Promise<object>} - Workflow object that was just created.\n     * @throws {ValidationError} - If the workflow has no stages.\n     */\n    async create(opts: { data: any }) {\n      let createOpts = { ...opts, populate: WORKFLOW_POPULATE };\n\n      workflowValidator.validateWorkflowStages(opts.data.stages);\n      await workflowValidator.validateWorkflowCount(1);\n\n      return strapi.db.transaction(async () => {\n        // Create stages\n        const stages = await getService('stages', { strapi }).createMany(opts.data.stages);\n        const mapIds = map(get('id'));\n\n        createOpts = set('data.stages', mapIds(stages), createOpts);\n\n        if (opts.data.stageRequiredToPublishName) {\n          const stageRequiredToPublish = stages.find(\n            (stage: any) => stage.name === opts.data.stageRequiredToPublishName\n          );\n          if (!stageRequiredToPublish) {\n            throw new errors.ApplicationError('Stage required to publish does not exist');\n          }\n\n          createOpts = set('data.stageRequiredToPublish', stageRequiredToPublish.id, createOpts);\n        }\n\n        // Update (un)assigned Content Types\n        if (opts.data.contentTypes) {\n          await workflowsContentTypes.migrate({\n            destContentTypes: opts.data.contentTypes,\n            stageId: stages[0].id,\n          });\n        }\n\n        // Create Workflow\n        const createdWorkflow = await strapi.db\n          .query(WORKFLOW_MODEL_UID)\n          .create(strapi.get('query-params').transform(WORKFLOW_MODEL_UID, createOpts));\n\n        metrics.sendDidCreateWorkflow(createdWorkflow.id, !!opts.data.stageRequiredToPublishName);\n\n        if (opts.data.stageRequiredToPublishName) {\n          await strapi\n            .plugin('content-releases')\n            .service('release-action')\n            .validateActionsByContentTypes(opts.data.contentTypes);\n        }\n\n        return createdWorkflow;\n      });\n    },\n\n    /**\n     * Updates an existing workflow.\n     * @param {object} workflow - The existing workflow to update.\n     * @param {object} opts - Options for updating the workflow.\n     * @returns {Promise<object>} - Workflow object that was just updated.\n     * @throws {ApplicationError} - If the supplied stage ID does not belong to the workflow.\n     */\n    async update(workflow: any, opts: any) {\n      const stageService = getService('stages', { strapi });\n      let updateOpts = { ...opts, populate: { ...WORKFLOW_POPULATE } };\n      let updatedStages: any = [];\n      let updatedStageIds: any;\n\n      await workflowValidator.validateWorkflowCount();\n\n      return strapi.db.transaction(async () => {\n        // Update stages\n        if (opts.data.stages) {\n          workflowValidator.validateWorkflowStages(opts.data.stages);\n          opts.data.stages.forEach((stage: any) =>\n            this.assertStageBelongsToWorkflow(stage.id, workflow)\n          );\n\n          updatedStages = await stageService.replaceStages(\n            workflow.stages,\n            opts.data.stages,\n            workflow.contentTypes\n          );\n          updatedStageIds = updatedStages.map((stage: any) => stage.id);\n\n          updateOpts = set('data.stages', updatedStageIds, updateOpts);\n        }\n\n        if (opts.data.stageRequiredToPublishName !== undefined) {\n          const stages = updatedStages ?? workflow.stages;\n\n          if (opts.data.stageRequiredToPublishName === null) {\n            updateOpts = set('data.stageRequiredToPublish', null, updateOpts);\n          } else {\n            const stageRequiredToPublish = stages.find(\n              (stage: any) => stage.name === opts.data.stageRequiredToPublishName\n            );\n\n            if (!stageRequiredToPublish) {\n              throw new errors.ApplicationError('Stage required to publish does not exist');\n            }\n\n            updateOpts = set('data.stageRequiredToPublish', stageRequiredToPublish.id, updateOpts);\n          }\n        }\n\n        // Update (un)assigned Content Types\n        if (opts.data.contentTypes) {\n          await workflowsContentTypes.migrate({\n            srcContentTypes: workflow.contentTypes,\n            destContentTypes: opts.data.contentTypes,\n            stageId: updatedStageIds ? updatedStageIds[0] : workflow.stages[0].id,\n          });\n        }\n\n        metrics.sendDidEditWorkflow(workflow.id, !!opts.data.stageRequiredToPublishName);\n\n        const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, updateOpts);\n\n        // Update Workflow\n        const updatedWorkflow = await strapi.db.query(WORKFLOW_MODEL_UID).update({\n          ...query,\n          where: { id: workflow.id },\n        });\n\n        await strapi\n          .plugin('content-releases')\n          .service('release-action')\n          .validateActionsByContentTypes([\n            ...workflow.contentTypes,\n            ...(opts.data.contentTypes || []),\n          ]);\n\n        return updatedWorkflow;\n      });\n    },\n\n    /**\n     * Deletes an existing workflow.\n     * Also deletes all the workflow stages and migrate all assigned the content types.\n     * @param {*} workflow\n     * @param {*} opts\n     * @returns\n     */\n    async delete(workflow: any, opts: any) {\n      const stageService = getService('stages', { strapi });\n\n      const workflowCount = await this.count();\n\n      if (workflowCount <= 1) {\n        throw new errors.ApplicationError('Can not delete the last workflow');\n      }\n\n      return strapi.db.transaction(async () => {\n        // Delete stages\n        await stageService.deleteMany(workflow.stages);\n\n        // Unassign all content types, this will migrate the content types to null\n        await workflowsContentTypes.migrate({\n          srcContentTypes: workflow.contentTypes,\n          destContentTypes: [],\n        });\n\n        const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, opts);\n\n        // Delete Workflow\n        const deletedWorkflow = await strapi.db.query(WORKFLOW_MODEL_UID).delete({\n          ...query,\n          where: { id: workflow.id },\n        });\n\n        await strapi\n          .plugin('content-releases')\n          .service('release-action')\n          .validateActionsByContentTypes(workflow.contentTypes);\n\n        return deletedWorkflow;\n      });\n    },\n    /**\n     * Returns the total count of workflows.\n     * @returns {Promise<number>} - Total count of workflows.\n     */\n    count() {\n      return strapi.db.query(WORKFLOW_MODEL_UID).count();\n    },\n\n    /**\n     * Finds the assigned workflow for a given content type ID.\n     * @param {string} uid - Content type ID to find the assigned workflow for.\n     * @param {object} opts - Options for the query.\n     * @returns {Promise<object|null>} - Assigned workflow object if found, or null.\n     */\n    async getAssignedWorkflow(uid: any, opts: any = {}) {\n      const workflows = await this._getAssignedWorkflows(uid, opts);\n\n      return workflows.length > 0 ? workflows[0] : null;\n    },\n\n    /**\n     * Finds all the assigned workflows for a given content type ID.\n     * Normally, there should only be one workflow assigned to a content type.\n     * However, edge cases can occur where a content type is assigned to multiple workflows.\n     * @param {string} uid - Content type ID to find the assigned workflows for.\n     * @param {object} opts - Options for the query.\n     * @returns {Promise<object[]>} - List of assigned workflow objects.\n     */\n    async _getAssignedWorkflows(uid: any, opts = {}) {\n      return this.find({\n        ...opts,\n        filters: { contentTypes: getWorkflowContentTypeFilter({ strapi }, uid) },\n      });\n    },\n\n    /**\n     * Asserts that a content type has an assigned workflow.\n     * @param {string} uid - Content type ID to verify the assignment of.\n     * @returns {Promise<object>} - Workflow object associated with the content type ID.\n     * @throws {ApplicationError} - If no assigned workflow is found for the content type ID.\n     */\n    async assertContentTypeBelongsToWorkflow(uid: any) {\n      const workflow = await this.getAssignedWorkflow(uid, {\n        populate: 'stages',\n      });\n\n      if (!workflow) {\n        throw new errors.ApplicationError(\n          `Review workflows is not activated on Content Type ${uid}.`\n        );\n      }\n\n      return workflow;\n    },\n\n    /**\n     * Asserts that a stage belongs to a given workflow.\n     * @param {string} stageId - ID of stage to check.\n     * @param {object} workflow - Workflow object to check against.\n     * @returns\n     * @throws {ApplicationError} - If the stage does not belong to the specified workflow.\n     */\n    assertStageBelongsToWorkflow(stageId: any, workflow: any) {\n      if (!stageId) {\n        return;\n      }\n\n      const belongs = workflow.stages.some((stage: any) => stage.id === stageId);\n      if (!belongs) {\n        throw new errors.ApplicationError(`Stage does not belong to workflow \"${workflow.name}\"`);\n      }\n    },\n  };\n};\n"],"names":["processFilters","strapi","filters","processedFilters","isString","contentTypes","getWorkflowContentTypeFilter","processPopulate","populate","WORKFLOW_POPULATE","workflowsContentTypes","workflowsContentTypesFactory","workflowValidator","getService","metrics","find","opts","query","get","transform","WORKFLOW_MODEL_UID","db","findMany","findById","id","findOne","where","create","createOpts","validateWorkflowStages","data","stages","validateWorkflowCount","transaction","createMany","mapIds","map","set","stageRequiredToPublishName","stageRequiredToPublish","stage","name","errors","ApplicationError","migrate","destContentTypes","stageId","createdWorkflow","sendDidCreateWorkflow","plugin","service","validateActionsByContentTypes","update","workflow","stageService","updateOpts","updatedStages","updatedStageIds","forEach","assertStageBelongsToWorkflow","replaceStages","undefined","srcContentTypes","sendDidEditWorkflow","updatedWorkflow","delete","workflowCount","count","deleteMany","deletedWorkflow","getAssignedWorkflow","uid","workflows","_getAssignedWorkflows","length","assertContentTypeBelongsToWorkflow","belongs","some"],"mappings":"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"}