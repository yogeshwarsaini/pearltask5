{"version":3,"file":"index.js","sources":["../../../../src/strapi/remote/flows/index.ts"],"sourcesContent":["import type { TransferStage } from '../../../../types';\n\nexport type Step =\n  | { kind: 'action'; action: string }\n  | { kind: 'transfer'; stage: TransferStage; locked?: boolean };\n\nexport { default as DEFAULT_TRANSFER_FLOW } from './default';\n\ninterface IState {\n  step: Step | null;\n}\n\nexport interface TransferFlow {\n  has(step: Step): boolean;\n  can(step: Step): boolean;\n  cannot(step: Step): boolean;\n  set(step: Step): this;\n  get(): Step | null;\n}\n\nexport const createFlow = (flow: readonly Step[]): TransferFlow => {\n  const state: IState = { step: null };\n\n  /**\n   * Equality check between two steps\n   */\n  const stepEqual = (stepA: Step, stepB: Step): boolean => {\n    if (stepA.kind === 'action' && stepB.kind === 'action') {\n      return stepA.action === stepB.action;\n    }\n\n    if (stepA.kind === 'transfer' && stepB.kind === 'transfer') {\n      return stepA.stage === stepB.stage;\n    }\n\n    return false;\n  };\n\n  /**\n   * Find the index for a given step\n   */\n  const findStepIndex = (step: Step) => flow.findIndex((flowStep) => stepEqual(step, flowStep));\n\n  return {\n    has(step: Step) {\n      return findStepIndex(step) !== -1;\n    },\n\n    can(step: Step) {\n      if (state.step === null) {\n        return true;\n      }\n\n      const indexesDifference = findStepIndex(step) - findStepIndex(state.step);\n\n      // It's possible to send multiple time the same transfer step in a row\n      if (indexesDifference === 0 && step.kind === 'transfer') {\n        return true;\n      }\n\n      return indexesDifference > 0;\n    },\n\n    cannot(step: Step) {\n      return !this.can(step);\n    },\n\n    set(step: Step) {\n      const canSwitch = this.can(step);\n\n      if (!canSwitch) {\n        throw new Error('Impossible to proceed to the given step');\n      }\n\n      state.step = step;\n\n      return this;\n    },\n\n    get() {\n      return state.step;\n    },\n  };\n};\n"],"names":["createFlow","flow","state","step","stepEqual","stepA","stepB","kind","action","stage","findStepIndex","findIndex","flowStep","has","can","indexesDifference","cannot","set","canSwitch","Error","get"],"mappings":";;AAoBO,MAAMA,aAAa,CAACC,IAAAA,GAAAA;AACzB,IAAA,MAAMC,KAAgB,GAAA;QAAEC,IAAM,EAAA;AAAK,KAAA;AAEnC;;MAGA,MAAMC,SAAY,GAAA,CAACC,KAAaC,EAAAA,KAAAA,GAAAA;AAC9B,QAAA,IAAID,MAAME,IAAI,KAAK,YAAYD,KAAMC,CAAAA,IAAI,KAAK,QAAU,EAAA;AACtD,YAAA,OAAOF,KAAMG,CAAAA,MAAM,KAAKF,KAAAA,CAAME,MAAM;AACtC;AAEA,QAAA,IAAIH,MAAME,IAAI,KAAK,cAAcD,KAAMC,CAAAA,IAAI,KAAK,UAAY,EAAA;AAC1D,YAAA,OAAOF,KAAMI,CAAAA,KAAK,KAAKH,KAAAA,CAAMG,KAAK;AACpC;QAEA,OAAO,KAAA;AACT,KAAA;AAEA;;MAGA,MAAMC,aAAgB,GAAA,CAACP,IAAeF,GAAAA,IAAAA,CAAKU,SAAS,CAAC,CAACC,QAAaR,GAAAA,SAAAA,CAAUD,IAAMS,EAAAA,QAAAA,CAAAA,CAAAA;IAEnF,OAAO;AACLC,QAAAA,GAAAA,CAAAA,CAAIV,IAAU,EAAA;YACZ,OAAOO,aAAAA,CAAcP,UAAU,CAAC,CAAA;AAClC,SAAA;AAEAW,QAAAA,GAAAA,CAAAA,CAAIX,IAAU,EAAA;YACZ,IAAID,KAAAA,CAAMC,IAAI,KAAK,IAAM,EAAA;gBACvB,OAAO,IAAA;AACT;AAEA,YAAA,MAAMY,iBAAoBL,GAAAA,aAAAA,CAAcP,IAAQO,CAAAA,GAAAA,aAAAA,CAAcR,MAAMC,IAAI,CAAA;;AAGxE,YAAA,IAAIY,iBAAsB,KAAA,CAAA,IAAKZ,IAAKI,CAAAA,IAAI,KAAK,UAAY,EAAA;gBACvD,OAAO,IAAA;AACT;AAEA,YAAA,OAAOQ,iBAAoB,GAAA,CAAA;AAC7B,SAAA;AAEAC,QAAAA,MAAAA,CAAAA,CAAOb,IAAU,EAAA;AACf,YAAA,OAAO,CAAC,IAAI,CAACW,GAAG,CAACX,IAAAA,CAAAA;AACnB,SAAA;AAEAc,QAAAA,GAAAA,CAAAA,CAAId,IAAU,EAAA;AACZ,YAAA,MAAMe,SAAY,GAAA,IAAI,CAACJ,GAAG,CAACX,IAAAA,CAAAA;AAE3B,YAAA,IAAI,CAACe,SAAW,EAAA;AACd,gBAAA,MAAM,IAAIC,KAAM,CAAA,yCAAA,CAAA;AAClB;AAEAjB,YAAAA,KAAAA,CAAMC,IAAI,GAAGA,IAAAA;AAEb,YAAA,OAAO,IAAI;AACb,SAAA;AAEAiB,QAAAA,GAAAA,CAAAA,GAAAA;AACE,YAAA,OAAOlB,MAAMC,IAAI;AACnB;AACF,KAAA;AACF;;;;"}