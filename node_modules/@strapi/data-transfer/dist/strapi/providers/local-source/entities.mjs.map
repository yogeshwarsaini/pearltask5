{"version":3,"file":"entities.mjs","sources":["../../../../src/strapi/providers/local-source/entities.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\nimport type { Core, Struct } from '@strapi/types';\n\nimport * as shared from '../../queries';\nimport { IEntity } from '../../../../types';\n\n/**\n * Generate and consume content-types streams in order to stream each entity individually\n */\nexport const createEntitiesStream = (strapi: Core.Strapi): Readable => {\n  const contentTypes: Struct.ContentTypeSchema[] = Object.values(strapi.contentTypes);\n\n  async function* contentTypeStreamGenerator() {\n    for (const contentType of contentTypes) {\n      const query = shared.entity.createEntityQuery(strapi).call(null, contentType.uid);\n\n      const stream: Readable = strapi.db\n        // Create a query builder instance (default type is 'select')\n        .queryBuilder(contentType.uid)\n        // Fetch all columns\n        .select('*')\n        // Apply the populate\n        .populate(query.deepPopulateComponentLikeQuery)\n        // Get a readable stream\n        .stream();\n\n      yield { contentType, stream };\n    }\n  }\n\n  return Readable.from(\n    (async function* entitiesGenerator(): AsyncGenerator<{\n      entity: IEntity;\n      contentType: Struct.ContentTypeSchema;\n    }> {\n      for await (const { stream, contentType } of contentTypeStreamGenerator()) {\n        try {\n          for await (const entity of stream) {\n            yield { entity, contentType };\n          }\n        } catch {\n          // ignore\n        } finally {\n          stream.destroy();\n        }\n      }\n    })()\n  );\n};\n\n/**\n * Create an entity transform stream which convert the output of\n * the multi-content-types stream to the transfer entity format\n */\nexport const createEntitiesTransformStream = (): Transform => {\n  return new Transform({\n    objectMode: true,\n    transform(data, _encoding, callback) {\n      const { entity, contentType } = data;\n      const { id, ...attributes } = entity;\n\n      callback(null, {\n        type: contentType.uid,\n        id,\n        data: attributes,\n      });\n    },\n  });\n};\n"],"names":["createEntitiesStream","strapi","contentTypes","Object","values","contentTypeStreamGenerator","contentType","query","shared","call","uid","stream","db","queryBuilder","select","populate","deepPopulateComponentLikeQuery","Readable","from","entitiesGenerator","entity","destroy","createEntitiesTransformStream","Transform","objectMode","transform","data","_encoding","callback","id","attributes","type"],"mappings":";;;;AAMA;;IAGaA,MAAAA,oBAAAA,GAAuB,CAACC,MAAAA,GAAAA;AACnC,IAAA,MAAMC,YAA2CC,GAAAA,MAAAA,CAAOC,MAAM,CAACH,OAAOC,YAAY,CAAA;IAElF,gBAAgBG,0BAAAA,GAAAA;QACd,KAAK,MAAMC,eAAeJ,YAAc,CAAA;YACtC,MAAMK,KAAAA,GAAQC,iBAA+B,CAACP,MAAAA,CAAAA,CAAQQ,IAAI,CAAC,IAAMH,EAAAA,WAAAA,CAAYI,GAAG,CAAA;AAEhF,YAAA,MAAMC,MAAmBV,GAAAA,MAAAA,CAAOW,EAC9B;AACCC,aAAAA,YAAY,CAACP,WAAAA,CAAYI,GAAG,CAC7B;aACCI,MAAM,CAAC,IACR;AACCC,aAAAA,QAAQ,CAACR,KAAAA,CAAMS,8BAA8B,CAC9C;aACCL,MAAM,EAAA;YAET,MAAM;AAAEL,gBAAAA,WAAAA;AAAaK,gBAAAA;AAAO,aAAA;AAC9B;AACF;AAEA,IAAA,OAAOM,QAASC,CAAAA,IAAI,CACjB,gBAAgBC,iBAAAA,GAAAA;AAIf,QAAA,WAAW,MAAM,EAAER,MAAM,EAAEL,WAAW,EAAE,IAAID,0BAA8B,EAAA,CAAA;YACxE,IAAI;gBACF,WAAW,MAAMe,UAAUT,MAAQ,CAAA;oBACjC,MAAM;AAAES,wBAAAA,MAAAA;AAAQd,wBAAAA;AAAY,qBAAA;AAC9B;AACF,aAAA,CAAE,OAAM;;aAEE,QAAA;AACRK,gBAAAA,MAAAA,CAAOU,OAAO,EAAA;AAChB;AACF;AACF,KAAA,EAAA,CAAA;AAEJ;AAEA;;;UAIaC,6BAAgC,GAAA,IAAA;AAC3C,IAAA,OAAO,IAAIC,SAAU,CAAA;QACnBC,UAAY,EAAA,IAAA;AACZC,QAAAA,SAAAA,CAAAA,CAAUC,IAAI,EAAEC,SAAS,EAAEC,QAAQ,EAAA;AACjC,YAAA,MAAM,EAAER,MAAM,EAAEd,WAAW,EAAE,GAAGoB,IAAAA;AAChC,YAAA,MAAM,EAAEG,EAAE,EAAE,GAAGC,YAAY,GAAGV,MAAAA;AAE9BQ,YAAAA,QAAAA,CAAS,IAAM,EAAA;AACbG,gBAAAA,IAAAA,EAAMzB,YAAYI,GAAG;AACrBmB,gBAAAA,EAAAA;gBACAH,IAAMI,EAAAA;AACR,aAAA,CAAA;AACF;AACF,KAAA,CAAA;AACF;;;;"}