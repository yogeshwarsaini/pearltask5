{"version":3,"file":"index.js","sources":["../../../../src/engine/validation/schemas/index.ts"],"sourcesContent":["import type { Struct } from '@strapi/types';\nimport { isArray, isObject, reject } from 'lodash/fp';\nimport type { Diff } from '../../../utils/json';\nimport * as utils from '../../../utils';\n\nconst OPTIONAL_CONTENT_TYPES = ['audit-log'] as const;\n\nconst isAttributeIgnorable = (diff: Diff) => {\n  return (\n    diff.path.length === 3 &&\n    // Root property must be attributes\n    diff.path[0] === 'attributes' &&\n    // Need a valid string attribute name\n    typeof diff.path[1] === 'string' &&\n    // The diff must be on ignorable attribute properties\n    ['private', 'required', 'configurable', 'default'].includes(diff.path[2])\n  );\n};\n\n// TODO: clean up the type checking, which will require cleaning up the typings in utils/json.ts\n// exclude admin tables that are not transferable and are optionally available (such as audit logs which are only available in EE)\nconst isOptionalAdminType = (diff: Diff) => {\n  // added/deleted\n  if ('value' in diff && isObject(diff.value)) {\n    const name = (diff?.value as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  // modified\n  if ('values' in diff && isArray(diff.values) && isObject(diff.values[0])) {\n    const name = (diff?.values[0] as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  return false;\n};\n\nconst isIgnorableStrict = (diff: Diff) => isAttributeIgnorable(diff) || isOptionalAdminType(diff);\n\nconst strategies = {\n  // No diffs\n  exact(diffs: Diff[]) {\n    return diffs;\n  },\n\n  // Strict: all content types must match except:\n  // - the property within a content type is an ignorable one\n  // - those that are (not transferrable and optionally available), for example EE features such as audit logs\n  strict(diffs: Diff[]) {\n    return reject(isIgnorableStrict, diffs);\n  },\n};\n\nconst compareSchemas = <T, P>(a: T, b: P, strategy: keyof typeof strategies) => {\n  const diffs = utils.json.diff(a, b);\n  return strategies[strategy](diffs);\n};\n\nexport { compareSchemas };\n"],"names":["OPTIONAL_CONTENT_TYPES","isAttributeIgnorable","diff","path","length","includes","isOptionalAdminType","isObject","value","name","info","singularName","isArray","values","isIgnorableStrict","strategies","exact","diffs","strict","reject","compareSchemas","a","b","strategy","utils"],"mappings":";;;;;;;;AAKA,MAAMA,sBAAyB,GAAA;AAAC,IAAA;AAAY,CAAA;AAE5C,MAAMC,uBAAuB,CAACC,IAAAA,GAAAA;AAC5B,IAAA,OACEA,KAAKC,IAAI,CAACC,MAAM,KAAK;AAErBF,IAAAA,IAAAA,CAAKC,IAAI,CAAC,CAAE,CAAA,KAAK;AAEjB,IAAA,OAAOD,KAAKC,IAAI,CAAC,CAAE,CAAA,KAAK;AAExB,IAAA;AAAC,QAAA,SAAA;AAAW,QAAA,UAAA;AAAY,QAAA,cAAA;AAAgB,QAAA;AAAU,KAAA,CAACE,QAAQ,CAACH,IAAKC,CAAAA,IAAI,CAAC,CAAE,CAAA,CAAA;AAE5E,CAAA;AAEA;AACA;AACA,MAAMG,sBAAsB,CAACJ,IAAAA,GAAAA;;AAE3B,IAAA,IAAI,OAAWA,IAAAA,IAAAA,IAAQK,WAASL,CAAAA,IAAAA,CAAKM,KAAK,CAAG,EAAA;QAC3C,MAAMC,IAAAA,GAAQP,IAAMM,EAAAA,KAAAA,EAAoCE,IAAMC,EAAAA,YAAAA;QAC9D,OAAQX,sBAA6DK,CAAAA,QAAQ,CAACI,IAAAA,CAAAA;AAChF;;IAGA,IAAI,QAAA,IAAYP,IAAQU,IAAAA,UAAAA,CAAQV,IAAKW,CAAAA,MAAM,CAAKN,IAAAA,WAAAA,CAASL,IAAKW,CAAAA,MAAM,CAAC,CAAA,CAAE,CAAG,EAAA;AACxE,QAAA,MAAMJ,OAAQP,IAAMW,EAAAA,MAAM,CAAC,CAAA,CAAE,EAA+BH,IAAMC,EAAAA,YAAAA;QAClE,OAAQX,sBAA6DK,CAAAA,QAAQ,CAACI,IAAAA,CAAAA;AAChF;IAEA,OAAO,KAAA;AACT,CAAA;AAEA,MAAMK,iBAAoB,GAAA,CAACZ,IAAeD,GAAAA,oBAAAA,CAAqBC,SAASI,mBAAoBJ,CAAAA,IAAAA,CAAAA;AAE5F,MAAMa,UAAa,GAAA;;AAEjBC,IAAAA,KAAAA,CAAAA,CAAMC,KAAa,EAAA;QACjB,OAAOA,KAAAA;AACT,KAAA;;;;AAKAC,IAAAA,MAAAA,CAAAA,CAAOD,KAAa,EAAA;AAClB,QAAA,OAAOE,UAAOL,iBAAmBG,EAAAA,KAAAA,CAAAA;AACnC;AACF,CAAA;AAEMG,MAAAA,cAAAA,GAAiB,CAAOC,CAAAA,EAAMC,CAAMC,EAAAA,QAAAA,GAAAA;AACxC,IAAA,MAAMN,QAAQO,SAAe,CAACH,CAAGC,EAAAA,CAAAA,CAAAA;IACjC,OAAOP,UAAU,CAACQ,QAAAA,CAAS,CAACN,KAAAA,CAAAA;AAC9B;;;;"}