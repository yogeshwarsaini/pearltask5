{"version":3,"file":"stream.js","sources":["../../src/utils/stream.ts"],"sourcesContent":["import { Transform, Readable } from 'stream';\n\ntype TransformOptions = ConstructorParameters<typeof Transform>[0];\n\n/**\n * Create a filter stream that discard chunks which doesn't satisfies the given predicate\n *\n * @param predicate - A filter predicate, takes a stream data chunk as parameter and returns a boolean value\n * @param options - Transform stream options\n */\nexport const filter = <T>(\n  predicate: (value: T) => boolean | Promise<boolean>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const keep = await predicate(chunk);\n\n      callback(null, keep ? chunk : undefined);\n    },\n  });\n};\n\n/**\n * Create a map stream that transform chunks using the given predicate\n *\n * @param predicate - A map predicate, takes a stream data chunk as parameter and returns a mapped value\n * @param options - Transform stream options\n */\nexport const map = <T, U = T>(\n  predicate: (value: T) => U | Promise<U>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const mappedValue = await predicate(chunk);\n\n      callback(null, mappedValue);\n    },\n  });\n};\n\n/**\n * Collect every chunks from a Readable stream.\n *\n * @param stream - The redable stream to collect data from\n * @param options.destroy - If set to true, it automatically calls `destroy()` on the given stream upon receiving the 'end' event\n */\nexport const collect = <T = unknown>(\n  stream: Readable,\n  options: { destroy: boolean } = { destroy: true }\n): Promise<T[]> => {\n  const chunks: T[] = [];\n\n  return new Promise((resolve, reject) => {\n    stream\n      .on('close', () => resolve(chunks))\n      .on('error', reject)\n      .on('data', (chunk) => chunks.push(chunk))\n      .on('end', () => {\n        if (options.destroy) {\n          stream.destroy();\n        }\n\n        resolve(chunks);\n      });\n  });\n};\n"],"names":["filter","predicate","options","objectMode","Transform","transform","chunk","_encoding","callback","keep","undefined","map","mappedValue","collect","stream","destroy","chunks","Promise","resolve","reject","on","push"],"mappings":";;;;AAIA;;;;;AAKC,IACM,MAAMA,MAAS,GAAA,CACpBC,WACAC,OAA4B,GAAA;IAAEC,UAAY,EAAA;AAAK,CAAC,GAAA;AAEhD,IAAA,OAAO,IAAIC,gBAAU,CAAA;AACnB,QAAA,GAAGF,OAAO;AAEV,QAAA,MAAMG,SAAUC,CAAAA,CAAAA,KAAK,EAAEC,SAAS,EAAEC,QAAQ,EAAA;YACxC,MAAMC,IAAAA,GAAO,MAAMR,SAAUK,CAAAA,KAAAA,CAAAA;YAE7BE,QAAS,CAAA,IAAA,EAAMC,OAAOH,KAAQI,GAAAA,SAAAA,CAAAA;AAChC;AACF,KAAA,CAAA;AACF;AAEA;;;;;AAKC,IACM,MAAMC,GAAM,GAAA,CACjBV,WACAC,OAA4B,GAAA;IAAEC,UAAY,EAAA;AAAK,CAAC,GAAA;AAEhD,IAAA,OAAO,IAAIC,gBAAU,CAAA;AACnB,QAAA,GAAGF,OAAO;AAEV,QAAA,MAAMG,SAAUC,CAAAA,CAAAA,KAAK,EAAEC,SAAS,EAAEC,QAAQ,EAAA;YACxC,MAAMI,WAAAA,GAAc,MAAMX,SAAUK,CAAAA,KAAAA,CAAAA;AAEpCE,YAAAA,QAAAA,CAAS,IAAMI,EAAAA,WAAAA,CAAAA;AACjB;AACF,KAAA,CAAA;AACF;AAEA;;;;;AAKC,IACM,MAAMC,OAAU,GAAA,CACrBC,QACAZ,OAAgC,GAAA;IAAEa,OAAS,EAAA;AAAK,CAAC,GAAA;AAEjD,IAAA,MAAMC,SAAc,EAAE;IAEtB,OAAO,IAAIC,OAAQ,CAAA,CAACC,OAASC,EAAAA,MAAAA,GAAAA;QAC3BL,MACGM,CAAAA,EAAE,CAAC,OAAS,EAAA,IAAMF,QAAQF,MAC1BI,CAAAA,CAAAA,CAAAA,EAAE,CAAC,OAASD,EAAAA,MAAAA,CAAAA,CACZC,EAAE,CAAC,MAAA,EAAQ,CAACd,KAAUU,GAAAA,MAAAA,CAAOK,IAAI,CAACf,KAAAA,CAAAA,CAAAA,CAClCc,EAAE,CAAC,KAAO,EAAA,IAAA;YACT,IAAIlB,OAAAA,CAAQa,OAAO,EAAE;AACnBD,gBAAAA,MAAAA,CAAOC,OAAO,EAAA;AAChB;YAEAG,OAAQF,CAAAA,MAAAA,CAAAA;AACV,SAAA,CAAA;AACJ,KAAA,CAAA;AACF;;;;;;"}