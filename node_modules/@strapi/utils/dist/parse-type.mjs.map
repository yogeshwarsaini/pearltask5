{"version":3,"file":"parse-type.mjs","sources":["../src/parse-type.ts"],"sourcesContent":["import * as _ from 'lodash';\nimport * as dates from 'date-fns';\n\nconst timeRegex = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\n\nconst isDate = (v: unknown): v is Date => {\n  return dates.isDate(v);\n};\n\nconst parseTime = (value: unknown): string => {\n  if (isDate(value)) {\n    return dates.format(value, 'HH:mm:ss.SSS');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n  const result = value.match(timeRegex);\n\n  if (result === null) {\n    throw new Error('Invalid time format, expected HH:mm:ss.SSS');\n  }\n\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\n  const fractionPart = _.padEnd(fraction.slice(1), 3, '0');\n\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\n};\n\nconst parseDate = (value: unknown) => {\n  if (isDate(value)) {\n    return dates.format(value, 'yyyy-MM-dd');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n\n    if (dates.isValid(date)) return dates.format(date, 'yyyy-MM-dd');\n\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  }\n};\n\nconst parseDateTimeOrTimestamp = (value: unknown) => {\n  if (isDate(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n    if (dates.isValid(date)) return date;\n\n    const milliUnixDate = dates.parse(value, 'T', new Date());\n    if (dates.isValid(milliUnixDate)) return milliUnixDate;\n\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  }\n};\n\ntype TypeMap = {\n  boolean: boolean;\n  integer: number;\n  biginteger: number;\n  float: number;\n  decimal: number;\n  time: string;\n  date: string;\n  timestamp: Date;\n  datetime: Date;\n};\n\nexport interface ParseTypeOptions<T extends keyof TypeMap> {\n  type: T;\n  value: unknown;\n  forceCast?: boolean;\n}\n\nconst parseBoolean = (value: unknown, options: { forceCast?: boolean }): boolean => {\n  const { forceCast = false } = options;\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    if (['true', 't', '1', 1].includes(value)) {\n      return true;\n    }\n\n    if (['false', 'f', '0', 0].includes(value)) {\n      return false;\n    }\n  }\n\n  if (forceCast) {\n    return Boolean(value);\n  }\n\n  throw new Error('Invalid boolean input. Expected \"t\",\"1\",\"true\",\"false\",\"0\",\"f\"');\n};\n\n/**\n * Cast basic values based on attribute type\n */\nconst parseType = <Type extends keyof TypeMap>(options: ParseTypeOptions<Type>): TypeMap[Type] => {\n  const { type, value, forceCast } = options;\n\n  switch (type) {\n    case 'boolean':\n      return parseBoolean(value, { forceCast }) as TypeMap[Type];\n    case 'integer':\n    case 'biginteger':\n    case 'float':\n    case 'decimal': {\n      return _.toNumber(value) as TypeMap[Type];\n    }\n    case 'time': {\n      return parseTime(value) as TypeMap[Type];\n    }\n    case 'date': {\n      return parseDate(value) as TypeMap[Type];\n    }\n    case 'timestamp':\n    case 'datetime': {\n      return parseDateTimeOrTimestamp(value) as TypeMap[Type];\n    }\n    default:\n      return value as TypeMap[Type];\n  }\n};\n\nexport default parseType;\n"],"names":["timeRegex","isDate","v","dates","parseTime","value","format","Error","result","match","hours","minutes","seconds","fraction","fractionPart","_","padEnd","slice","parseDate","date","parseISO","isValid","error","parseDateTimeOrTimestamp","milliUnixDate","parse","Date","parseBoolean","options","forceCast","includes","Boolean","parseType","type","toNumber"],"mappings":"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"}