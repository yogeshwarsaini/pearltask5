{"version":3,"file":"query-populate.mjs","sources":["../../src/traverse/query-populate.ts"],"sourcesContent":["import {\n  curry,\n  isString,\n  isArray,\n  isEmpty,\n  split,\n  isObject,\n  trim,\n  constant,\n  isNil,\n  identity,\n  cloneDeep,\n  join,\n  first,\n} from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\nimport { Attribute } from '../types';\nimport { isMorphToRelationalAttribute } from '../content-types';\n\nconst isKeyword = (keyword: string) => {\n  return ({ key, attribute }: { key: string; attribute: Attribute }) => {\n    return !attribute && keyword === key;\n  };\n};\n\nconst isWildcard = (value: unknown): value is '*' => value === '*';\n\nconst isPopulateString = (value: unknown): value is string => {\n  return isString(value) && !isWildcard(value);\n};\n\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst populate = traverseFactory()\n  .intercept(isPopulateString, async (visitor, options, populate, { recurse }) => {\n    /**\n     * Ensure the populate clause its in the extended format ( { populate: { ... } }, and not just a string)\n     * This gives a consistent structure to track the \"parent\" node of each nested populate clause\n     */\n    const populateObject = pathsToObjectPopulate([populate]);\n    const traversedPopulate = (await recurse(visitor, options, populateObject)) as PopulateObject;\n    const [result] = objectPopulateToPaths(traversedPopulate);\n\n    return result;\n  })\n  // Array of strings ['foo', 'bar.baz'] => map(recurse), then filter out empty items\n  .intercept(isStringArray, async (visitor, options, populate, { recurse }) => {\n    const paths = await Promise.all(\n      populate.map((subClause) => recurse(visitor, options, subClause))\n    );\n\n    return paths.filter((item) => !isNil(item));\n  })\n  // for wildcard, generate custom utilities to modify the values\n  .parse(isWildcard, () => ({\n    /**\n     * Since value is '*', we don't need to transform it\n     */\n    transform: identity,\n\n    /**\n     * '*' isn't a key/value structure, so regardless\n     *  of the given key, it returns the data ('*')\n     */\n    get: (_key, data) => data,\n\n    /**\n     * '*' isn't a key/value structure, so regardless\n     * of the given `key`, use `value` as the new `data`\n     */\n    set: (_key, value) => value,\n\n    /**\n     * '*' isn't a key/value structure, but we need to simulate at least one to enable\n     * the data traversal. We're using '' since it represents a falsy string value\n     */\n    keys: constant(['']),\n\n    /**\n     * Removing '*' means setting it to undefined, regardless of the given key\n     */\n    remove: constant(undefined),\n  }))\n\n  // Parse string values\n  .parse(isString, () => {\n    const tokenize = split('.');\n    const recompose = join('.');\n\n    return {\n      transform: trim,\n\n      remove(key, data) {\n        const [root] = tokenize(data);\n\n        return root === key ? undefined : data;\n      },\n\n      set(key, value, data) {\n        const [root] = tokenize(data);\n\n        if (root !== key) {\n          return data;\n        }\n\n        return isNil(value) || isEmpty(value) ? root : `${root}.${value}`;\n      },\n\n      keys(data) {\n        const v = first(tokenize(data));\n        return v ? [v] : [];\n      },\n\n      get(key, data) {\n        const [root, ...rest] = tokenize(data);\n\n        return key === root ? recompose(rest) : undefined;\n      },\n    };\n  })\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      // eslint-disable-next-line no-unused-vars\n      const { [key]: ignored, ...rest } = data;\n\n      return rest;\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  .ignore(({ key, attribute }) => {\n    // we don't want to recurse using traversePopulate and instead let\n    // the visitors recurse with the appropriate traversal (sort, filters, etc...)\n    return ['sort', 'filters', 'fields'].includes(key) && !attribute;\n  })\n  .on(\n    // Handle recursion on populate.\"populate\"\n    isKeyword('populate'),\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      const newValue = await recurse(visitor, { schema, path, getModel, parent }, value);\n\n      set(key, newValue);\n    }\n  )\n  .on(\n    isKeyword('on'),\n    async ({ key, visitor, path, value, getModel, parent }, { set, recurse }) => {\n      const newOn: Record<string, unknown> = {};\n\n      if (!isObj(value)) {\n        return;\n      }\n\n      for (const [uid, subPopulate] of Object.entries(value)) {\n        const model = getModel(uid);\n        const newPath = { ...path, raw: `${path.raw}[${uid}]` };\n\n        newOn[uid] = await recurse(\n          visitor,\n          { schema: model, path: newPath, getModel, parent },\n          subPopulate\n        );\n      }\n\n      set(key, newOn);\n    }\n  )\n  // Handle populate on relation\n  .onRelation(\n    async ({ key, value, attribute, visitor, path, schema, getModel }, { set, recurse }) => {\n      if (isNil(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      if (isMorphToRelationalAttribute(attribute)) {\n        // Don't traverse values that cannot be parsed\n        if (!isObject(value) || !('on' in value && isObject(value?.on))) {\n          return;\n        }\n\n        // If there is a populate fragment defined, traverse it\n        const newValue = await recurse(\n          visitor,\n          { schema, path, getModel, parent },\n          { on: value?.on }\n        );\n\n        set(key, newValue);\n\n        return;\n      }\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle populate on media\n  .onMedia(async ({ key, path, schema, attribute, visitor, value, getModel }, { recurse, set }) => {\n    if (isNil(value)) {\n      return;\n    }\n\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  })\n  // Handle populate on components\n  .onComponent(\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { recurse, set }) => {\n      if (isNil(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle populate on dynamic zones\n  .onDynamicZone(\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { set, recurse }) => {\n      if (isNil(value) || !isObject(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      // Handle fragment syntax\n      if ('on' in value && value.on) {\n        const newOn = await recurse(visitor, { schema, path, getModel, parent }, { on: value.on });\n\n        set(key, newOn);\n      }\n    }\n  );\n\nexport default curry(populate.traverse);\n\ntype PopulateObject = {\n  [key: string]: true | { populate: PopulateObject };\n};\n\nconst objectPopulateToPaths = (input: PopulateObject): string[] => {\n  const paths: string[] = [];\n\n  function traverse(currentObj: PopulateObject, parentPath: string) {\n    for (const [key, value] of Object.entries(currentObj)) {\n      const currentPath = parentPath ? `${parentPath}.${key}` : key;\n      if (value === true) {\n        paths.push(currentPath);\n      } else {\n        traverse((value as { populate: PopulateObject }).populate, currentPath);\n      }\n    }\n  }\n\n  traverse(input, '');\n\n  return paths;\n};\n\nconst pathsToObjectPopulate = (input: string[]): PopulateObject => {\n  const result: PopulateObject = {};\n\n  function traverse(object: PopulateObject, keys: string[]): void {\n    const [first, ...rest] = keys;\n    if (rest.length === 0) {\n      object[first] = true;\n    } else {\n      if (!object[first] || typeof object[first] === 'boolean') {\n        object[first] = { populate: {} };\n      }\n      traverse((object[first] as { populate: PopulateObject }).populate, rest);\n    }\n  }\n\n  input.forEach((clause) => traverse(result, clause.split('.')));\n\n  return result;\n};\n"],"names":["isKeyword","keyword","key","attribute","isWildcard","value","isPopulateString","isString","isStringArray","isArray","every","isObj","isObject","populate","traverseFactory","intercept","visitor","options","recurse","populateObject","pathsToObjectPopulate","traversedPopulate","result","objectPopulateToPaths","paths","Promise","all","map","subClause","filter","item","isNil","parse","transform","identity","get","_key","data","set","keys","constant","remove","undefined","tokenize","split","recompose","join","trim","root","isEmpty","v","first","rest","cloneDeep","ignored","Object","ignore","includes","on","path","schema","getModel","parent","newValue","newOn","uid","subPopulate","entries","model","newPath","raw","onRelation","isMorphToRelationalAttribute","targetSchemaUID","target","targetSchema","onMedia","onComponent","component","onDynamicZone","curry","traverse","input","currentObj","parentPath","currentPath","push","object","length","forEach","clause"],"mappings":"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"}