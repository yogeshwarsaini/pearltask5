{"version":3,"file":"throw-unrecognized-fields.mjs","sources":["../../../src/validate/visitors/throw-unrecognized-fields.ts"],"sourcesContent":["import {\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isRelationalAttribute,\n  constants,\n  isComponentSchema,\n  isMediaAttribute,\n  hasRelationReordering,\n} from '../../content-types';\nimport type { Visitor } from '../../traverse-entity';\nimport { throwInvalidKey } from '../utils';\n\n// TODO these should all be centralized somewhere instead of maintaining a list\nconst ID_FIELDS = [constants.DOC_ID_ATTRIBUTE, constants.DOC_ID_ATTRIBUTE];\nconst ALLOWED_ROOT_LEVEL_FIELDS = [...ID_FIELDS];\nconst MORPH_TO_ALLOWED_FIELDS = ['__type'];\nconst DYNAMIC_ZONE_ALLOWED_FIELDS = ['__component'];\nconst RELATION_REORDERING_FIELDS = ['connect', 'disconnect', 'set', 'options'];\n\nconst throwUnrecognizedFields: Visitor = ({ key, attribute, path, schema, parent }) => {\n  // We only look at properties that are not attributes\n  if (attribute) {\n    return;\n  }\n\n  // At root level (path.attribute === null), only accept allowed fields\n  if (path.attribute === null) {\n    if (ALLOWED_ROOT_LEVEL_FIELDS.includes(key)) {\n      return;\n    }\n\n    return throwInvalidKey({ key, path: attribute });\n  }\n\n  // allow special morphTo keys\n  if (isMorphToRelationalAttribute(parent?.attribute) && MORPH_TO_ALLOWED_FIELDS.includes(key)) {\n    return;\n  }\n\n  // allow special dz keys\n  if (\n    isComponentSchema(schema) &&\n    isDynamicZoneAttribute(parent?.attribute) &&\n    DYNAMIC_ZONE_ALLOWED_FIELDS.includes(key)\n  ) {\n    return;\n  }\n\n  // allow special relation reordering keys in manyToX and XtoMany relations\n  if (hasRelationReordering(parent?.attribute) && RELATION_REORDERING_FIELDS.includes(key)) {\n    return;\n  }\n\n  // allow id fields where it is needed for setting a relational id rather than trying to create with a given id\n  const canUseID = isRelationalAttribute(parent?.attribute) || isMediaAttribute(parent?.attribute);\n  if (canUseID && !ID_FIELDS.includes(key)) {\n    return;\n  }\n\n  // if we couldn't find any reason for it to be here, throw\n  throwInvalidKey({ key, path: attribute });\n};\n\nexport default throwUnrecognizedFields;\n"],"names":["ID_FIELDS","constants","DOC_ID_ATTRIBUTE","ALLOWED_ROOT_LEVEL_FIELDS","MORPH_TO_ALLOWED_FIELDS","DYNAMIC_ZONE_ALLOWED_FIELDS","RELATION_REORDERING_FIELDS","throwUnrecognizedFields","key","attribute","path","schema","parent","includes","throwInvalidKey","isMorphToRelationalAttribute","isComponentSchema","isDynamicZoneAttribute","hasRelationReordering","canUseID","isRelationalAttribute","isMediaAttribute"],"mappings":";;;AAYA;AACA,MAAMA,SAAY,GAAA;AAACC,IAAAA,SAAAA,CAAUC,gBAAgB;AAAED,IAAAA,SAAAA,CAAUC;AAAiB,CAAA;AAC1E,MAAMC,yBAA4B,GAAA;AAAIH,IAAAA,GAAAA;AAAU,CAAA;AAChD,MAAMI,uBAA0B,GAAA;AAAC,IAAA;AAAS,CAAA;AAC1C,MAAMC,2BAA8B,GAAA;AAAC,IAAA;AAAc,CAAA;AACnD,MAAMC,0BAA6B,GAAA;AAAC,IAAA,SAAA;AAAW,IAAA,YAAA;AAAc,IAAA,KAAA;AAAO,IAAA;AAAU,CAAA;AAE9E,MAAMC,uBAAmC,GAAA,CAAC,EAAEC,GAAG,EAAEC,SAAS,EAAEC,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAE,GAAA;;AAEhF,IAAA,IAAIH,SAAW,EAAA;AACb,QAAA;AACF;;IAGA,IAAIC,IAAAA,CAAKD,SAAS,KAAK,IAAM,EAAA;QAC3B,IAAIN,yBAAAA,CAA0BU,QAAQ,CAACL,GAAM,CAAA,EAAA;AAC3C,YAAA;AACF;AAEA,QAAA,OAAOM,eAAgB,CAAA;AAAEN,YAAAA,GAAAA;YAAKE,IAAMD,EAAAA;AAAU,SAAA,CAAA;AAChD;;AAGA,IAAA,IAAIM,6BAA6BH,MAAQH,EAAAA,SAAAA,CAAAA,IAAcL,uBAAwBS,CAAAA,QAAQ,CAACL,GAAM,CAAA,EAAA;AAC5F,QAAA;AACF;;IAGA,IACEQ,iBAAAA,CAAkBL,WAClBM,sBAAuBL,CAAAA,MAAAA,EAAQH,cAC/BJ,2BAA4BQ,CAAAA,QAAQ,CAACL,GACrC,CAAA,EAAA;AACA,QAAA;AACF;;AAGA,IAAA,IAAIU,sBAAsBN,MAAQH,EAAAA,SAAAA,CAAAA,IAAcH,0BAA2BO,CAAAA,QAAQ,CAACL,GAAM,CAAA,EAAA;AACxF,QAAA;AACF;;AAGA,IAAA,MAAMW,QAAWC,GAAAA,qBAAAA,CAAsBR,MAAQH,EAAAA,SAAAA,CAAAA,IAAcY,iBAAiBT,MAAQH,EAAAA,SAAAA,CAAAA;AACtF,IAAA,IAAIU,QAAY,IAAA,CAACnB,SAAUa,CAAAA,QAAQ,CAACL,GAAM,CAAA,EAAA;AACxC,QAAA;AACF;;IAGAM,eAAgB,CAAA;AAAEN,QAAAA,GAAAA;QAAKE,IAAMD,EAAAA;AAAU,KAAA,CAAA;AACzC;;;;"}